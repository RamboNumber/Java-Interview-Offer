# 04_大型电商系统v1.0项目实战

## 站在架构师的角度为团队设计软件开发流程和规范

### 01_电商项目v1.0版本的授课思路介绍

第一个版本的简单思路介绍 

（1）要把之前分析过的电商系统v1.0需求全部做出来，形成一个电商系统v1.0版本，认为是一个电商系统的雏形

（2）软件工程、项目管理、Spring Boot、设计模式 

1、软件工程 

软件工程，如果你是计算机科班出身的，尤其是大学的专业是软件工程这门专业的话，实际上你必定会有一门专业课，叫做《软件工程》。但是问题在于什么呢？软件工程不是那样学的，不是上来就一本特别抽象和高度归纳的一本老外写的书，你就能学会的。学习软件工程，靠的不是大学里的课本，你需要的是真正在简单了解整个软件工程的流程之后，快速的去运用整个软件工程的流程和思路去做一个项目出来。真正用软件工程做过项目之后，你立马就可以体会到软件工程是什么东西？ 

现在的一个问题，很多同学，可能上大学的时候都学习过软件工程这个东西，结果。。。。当时根本没弄明白是怎么回事，所以应付一下考试，直接就给忘了

然后更加坑爹的，你参加工作之后，刚开始你就是一个小兵，然后就是照着公司里的流程和规范在走，完全还是没法从全局上去把控什么叫做软件工程。但是问题在于说，如果我们这个课程，架构师，把控软件工程的流程和规范。 

就我目前观察，反正市面上几乎所有的所谓的Java高级或者架构师的培训课程，都没有人去讲解软件工程的 

一句话概括一下软件工程：就是从0开始如何完成一个软件项目，涵盖了做一个软件项目的所有的流程 

（1）站在架构师的角度来制定软件工程流程和规范 

你现在是一个架构师，你带了一个小团队，比如说几个人，去主导公司里的一个重要项目的开发 

京东app的后台系统，刚开始3个人，一个leader带2个小弟

微信，刚开始的时候，就几个人

搜狗，就六七个人，就开始干了

百度，淘宝，阿里，刚开始就几个人 

一个业务快速发展，需要的工程师越来越多，需要更多的人去开发不同的业务系统；一个系统访问量越来越大，职能拆分团队，dba团队，运维团队，后端团队，前端团队 

做的第一件事情，一定是制定一份这个项目开发的软件工程的流程与规范，瞎做，第一步做什么？第二步做什么？如何一步一步的将一个项目给干出来？ 

这个过程，就是一个软件工程的流程 -> 每个步骤到底要怎么做，要按照什么统一的规范来做，软件工程的规范 

一般来说，我在团队里面就会说是系统开发的流程和规范 -> 软件工程的流程和规范 

第一件事情：业务调研，我们已经做完了。在公司里，如果在互联网行业里，这个业务调研，不是我们做的；产品经理的角色，跟系统的用户去聊，去调研需求，梳理出来一份产品设计文档，有的时候也可以叫做业务调研文档，业务调研 -> 产品设计 

- 业务调研：主要是完全跟技术无关，站在业务的角度去定义系统要干嘛
  - 组织结构图：部门+岗位
  - 业务流程图：泳道图，一级业务流程+二级业务流程
    - 系统多个模块的整体业务流程
    - 每个模块内部的业务流程
  - 业务表单
  - 业务需求
- 需求分析：站在技术的角度，去分析系统要干嘛
  - 用例图
    - 用例表：用例名称+多个参与者+每个参与者对这个用例做的事情
    - 用例描述+用例流程（泳道图）
    - 用例图：参与者+用例，一个用例就是一个功能需求
    - 用例划分
      - 每个模块都划分出对应的用例来
      - 从业务流程图的运行节点中，抽取用例
  - 领域类图
    - 主要根据业务表单来抽象
  - 非功能需求
    - 物理部署需求
    - 实施需求
    - 易用性需求
    - 性能需求
    - 可靠性需求
- 概要设计：架构师一个人去做的
  - 逻辑架构图：根据需求，画出来逻辑上，系统要长成什么样子
  - 运行架构图：时序图、活动图（可选）、状态图（可选），系统的逻辑架构有了，系统跑起来是什么流程
  - 物理架构图：组件图、配置图，系统长什么样子，系统跑起来流程是什么，系统真正怎么去部署
- 概要设计评审
- 详细设计：下推给项目组里的每个人去做
  - 数据架构图
    - 数据库ER模型图
    - 数据库逻辑设计图
    - 数据库物理设计图
  - 接口设计
  - 开发架构图：实现类图、包图
  - 系统运行流程图（活动图）
  - 测试用例设计
    - 单元测试用例设计
    - 冒烟测试用例设计
  - 日志设计
- 详细设计评审
- 项目管理计划（每个人给出自己的排期计划）
  - 活动图
  - 网络图
  - 进度计划（甘特图）
  - 资源配置
- 工程初始化
  - 每个人本地的开发环境搭建
  - 资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请
  - 数据库初始化
  - 代码初始化和上传
- 版本控制
- 编码开发
- 系统测试
  - 单元测试（白盒测试）
  - 冒烟测试
  - 静态代码扫描
  - 代码审查
  - 集成测试（联调测试，也可能是RD自己干，不是QA干）
  - 系统测试（QA去干，黑盒测试）
  - 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）
- 系统上线
- 系统运维：跟进bug的反馈，排查线上日志，解决bug

概括一下 

我们这里的软件工程的流程，基本上就完全涵盖了标准软件工程的核心流程 

软件工程：安全性和可靠性（安全架构、可靠性架构，后面讲解），高级软件工程（SOA、分布式、嵌入式，有些到了微服务架构会详解，有些不是我们的范围，到了后面会讲解） 

软件项目管理：我们这里就要带着大家来实践了 

作为一个架构师，为自己要负责的项目，定义好一整套的软件工程流程，同时对流程中的每个步骤定义好规范 

（2）基于真实的电商系统项目来完整执行和实施一整套的软件工程流程和规范 

2、项目管理 

软件工程和项目管理，密不可分 

因为是这样的，你现在已经知道整个软件的流程和每一个步骤的规范要做什么，要怎么做。但是你如何带着一个团队，给他们分配好任务，带着他们一步一步的把这个流程全部做完呢？ 

要做到这一点，就是要依靠项目管理，对整个项目进行管理和把控，确保说带着一个team可以把你定义好的一整套东西全部做出来 

（1）项目管理：项目管理计划、项目执行和监控、风险管理、变更管理、质量管理（配置管理+测试管理+缺陷管理），5大过程域、9大领域、44个定义（我不想这样去讲，涵盖的非常非常的完整） 

我们第一个版本，不会去涵盖所有的完整的项目管理的东西，庞大了，抽取出来我们项目做的时候平时常用，最实用的一些东西，拎出来，带着大家在项目实战中去演练和体会。到了后面，随着我们的项目越来越复杂，项目管理的东西也会不断新增更多的内容进去。举个例子，就是说，比如说，你到了后面，可能一个大系统拆分给了多个小team去做，同时涉及到并行在执行的多个项目，多项目集群管理。 

（2）瀑布式 vs 敏捷式 

做项目，按照我刚才上面说的那一整套东西，包括软件工程流程+项目管理流程，就是非常经典的一套瀑布式的过程。瀑布式不是说就不好，其实是有其用处的，在我的个人经验里，我觉得，就是尤其是在一个项目从0到1的时候，采取瀑布式的方式来做，是挺靠谱的。需求变动是比较少的，还没有涉及到终端用户的反馈，其实就是一个初始产品的研发 

但是从1到10的时候，此时系统已经上线了，面向终端用户去使用了，大量的需求迭代，并行的多个项目，直接会喷涌而来，此时瀑布式的方式来做，就不太灵活了，这个时候可能就需要用到敏捷式的开发流程和项目管理 

我一开始在从0到1的时候，采取瀑布式的方式，大家可以学会 

接着从1到10的时候，到微服务的环节，本来就要涉及到微服务的持续集成、持续交付、敏捷开发、敏捷项目管理 

其实这个过程是很自然的，也是很合理的，因为我是经历过大量的项目，从0到1，再从1到10的，这个过程的转变，基本就是这样的 

（3）站在互联网项目的角度进行项目管理 

1）传统IT行业（华为、中兴、神州数码、联想、用友） vs 互联网行业（BAT、一线互联网公司） 

传统IT行业的项目管理，跟互联网行业的项目管理， 大体上来说，是类似的，但是因为行业的不同，决定了很多东西还是会有差别的 

2）互联网行业，没有架构师title，技术专家 -> 架构设计、团队管理、项目管理 

传统IT行业，就我所知，拆分是比较细的，可能是这样的，一个team，有专门的做团队管理的leader，负责团队人员招聘、绩效；团队里有专门的架构师，就负责架构设计；项目经理，就是负责对设计好的架构，进行项目全生命周期的一个管理和负责 

互联网行业，没有分的这么细的，PM、RD、QA 

PM负责设计产品 -> RD负责开发（后端RD，前端RD，数据RD） -> QA负责测试 

技术专家的职级，兼任了三个岗位，团队管理、架构设计、项目管理 -> 既要负责人员的招聘，打绩效，职级晋升评审；也要负责整体的技术规划，核心项目的架构设计；同时也要做重要的项目进行项目管理 

（4）站在架构师的角度来制定项目管理规范 

（5）作为一个架构师来完整管理和把控整个项目流程：模拟一个1+4的小team来进行项目管理 

你一个架构师，带了4个小弟，带着4个小弟一块儿来干活儿 

3、Spring Boot项目实战 

以前的技术框架的大路货，通用货，每个人都会的东西，在2010年左右，是SSH2，Struts2+Spring+Hibernate

后来可能在2013年左右，大路货变成了，SSM，Spring Web MVC + Spring + Mybatis

每个公司，每个工程师，都必须掌握的一些东西，就是用这套最基础的框架来开发项目的 

从去年开始兴起，2017年，Spring Boot，出现的原因是什么呢？每次要上手开发一个项目，都比较繁琐，自己要找一堆的框架版本如何兼容，在pom.xml里面配置依赖，接着对每个框架都要做xml配置文件的设置，mvc-servlet.xml、applicationContext.xml、mybatis-config.xml、web.xml、mapper.xml -> 框架整合完毕，可以开始开发了。为了要打包，还要引入maven打包的插件，配置好插件，让它可以打成一个有所有依赖的一个war包。本地测试，还要安装tomcat集成到eclipse，本地基于eclipse里的tomcat去部署和测试。 

大家也都发现了，启动上手做这个基于spring的项目，太麻烦了，很多东西要弄，搭建一个工程要半天时间 

Spring Boot项目，boot类似于一台电脑打开启动的意思，快速启动一个基于Spring Boot的项目 

上来就是放两个简单的maven依赖，然后什么都不用配置，Spring Boot的starter依赖，直接自动给你配置好Spring MVC + Spring + MyBatis，然后就可以写代码了，写好代码之后，直接就可以打包部署，如果在本地测试，甚至可以直接运行一个main类就可以跑起来测试。如果要上线部署，直接打jar包或者是war包，打好之后就可以部署了。 

传统的开发模式下，如果你要集成MQ、缓存、zookeeper、kafka之类的东西，都要做很多的事情 

但是基于Spring Boot，其实就是一个脚手架的意思，给你提供了一堆的starter依赖，比如你要集成一个redis，可能就是引入一个starter依赖，然后自动就给你配置好你需要的一些东西，然后上手就可以开始开发了 

在进行整个系统框架的搭建和整合的时候，基于Spring Boot可以大量减少工作，加速你的项目的启动 

预料的一点，在未来的1~2年内，大路货就变成了Spring Boot + Spring MVC + Spring + MyBatis 

基于目前最热最流行的Spring Boot技术来实战开发电商系统的v1.0版本 

（1）Spring Boot + Spring Web MVC + Spring Core + MyBatis

（2）MySQL + Tomcat

（3）Maven + Git 

4、23种设计模式 

透彻的掌握设计模式，能够灵活的运用在系统的设计中，保证系统的代码是非常优雅和高度可扩展的，是一个架构师必备的基本能力 

因为我见过的大量的烂代码，没有经过良好的分析和设计，就是胡乱写，胡乱实现需求，写出来的代码跟屎一样 -> 有些代码，写了1年之后，项目组里就没几个人能看懂了 -> 2年之后，基本就完全没人能看懂了 -> 最后只能推倒重做 

烂代码，要对代码的逻辑做一些改动，重构一些实现机制，我天，看着一团乱麻的代码，自己都不知道如何下手 -> 即使要下手，也要对代码进行大量的改动，改动完了之后自己心里都没底。做系统维护的，加一些功能，修改一些功能，修复一个bug，效率非常之低。因为看不懂代码，代码太乱了，不知道怎么改，不知道怎么下手。 

如果要写一手漂亮的好代码，设计模式的运用是至少的，可以将复杂的缠绕在一起的屎一样的代码，给转换成拆分的清晰、逻辑清爽、一眼就能看明白是怎么回事、改动的时候只要修改一点代码就可以了 

将23种设计模式在我们的项目中全部实战、融合和体现，包括以后的版本，大量应用设计模式，确保写出来的代码扩展性良好，不要写屎一样的代码 

你看市面上不少书和视频课程都是讲解设计模式的，但是有个问题，全部都是理论、demo案例来讲解的，你看完了以后，也很难将设计模式运用到你自己的项目里去 

所以说，我们这次用真实复杂的电商业务来讲解项目，好处就在于，业务足够复杂，可以支撑我们将几乎架构师的所有技术都融入进去 

5、Spring Boot源码剖析 

我这里的一个思路，大家每跟着我学会一个技术，对这个技术一定不能只是简单会用，而是说要深入研究和掌握底层的原理，深刻理解这门技术 

我最近给一些同学修改简历，包括我自己平时招人，招聘的时候，看简历，最怕的就是看到这种简历 

（1）熟练掌握spring mvc、spring、mybatis等框架的使用

（2）熟练掌握spring cloud、dubbo、spring boot等框架的使用

（3）熟练掌握redis、zookeeper、kafka、mongodb、elasticsearch的使用

（4）熟练掌握maven和git的使用

（5）熟练掌握mysql、nginx、linux的开发和使用 

薪资最多就是20k左右，不能再多了，这种人真的不行 

这种简历，占到了市面上90%以上的简历 

看到了我就头疼，很简单，看简历就知道你是什么水平了，没什么可以问的，基本上就是各种技术都会用，在项目里也许实际用过，但是也没什么挑战的一些项目 

如果说你工作了3~5年，你的简历长成这样，说明你这今年的技术积累绝对不够 

看看另外一份简历，一些BAT或者比较好的一些工程师的简历 

（1）深入理解spring mvc、spring、mybatis等技术，研究过底层源码，熟悉其架构设计，能够进行开源框架的二次开发

（2）深入理解spring cloud、dubbo、spring boot等技术，研究过底层源码，对分布式系统的架构设计有着深刻的理解和掌握

（3）深刻理解redis的底层原理以及内核源码，对于多级缓存架构、缓存预热、缓存穿透、缓存雪崩等各种场景都有一定的理解，并且在项目中对缓存架构有深入的事件经验 

这个人一看就是说，对技术有很强的追求，对各种技术有深入到源码的研究，对一些复杂的架构设计有实践经验，能做框架做二次开发，也能进行复杂的架构设计 

30k，什么的，都可以要，30k~35k还是比较容易的一件事情 

我期望的是，大家跟我学会的每个技术，都是深入的掌握的，掌握到了底层的源码层面，甚至可以二次开发，做各种复杂的大型架构的设计，做复杂的公司级的开源框架的二次开发，可以做复杂的公司级的基础中间件的架构设计和开发 

光是会用Spring Boot，是没有什么值得骄傲的，因为使用非常之简单，其实就是个脚手架，各种常用技术通过一堆starter依赖给你自动配置好，精简xml配置，基于注解来配置，降低项目启动成本，加速项目开发 

Spring Boot的核心在于其设计思想，在整合技术的时候，如何简化配置，提高开发效率，重点是其源码剖析，源码层面是如何做到这一点的，架构是什么，设计思想是什么，亮点是什么，我们可以借鉴和学习到什么 

6、整体思路梳理 

（1）完整贯穿和实施软件工程全流程，自己制定团队的软件工程规范

（2）完整把控整个项目全流程的项目管理

（3）在系统技术栈中，重点实践Spring Boot这门技术

（4）在系统设计中，重点实践23种设计模式的运用，如何写一手可扩展的漂亮代码

（5）最后深入剖析Spring Boot技术来结尾，加强自己的技术深度

（6）全程基于真实的电商项目v1.0业务需求来在项目实战中学习上面所有内容，项目实战驱动，保证最好的学习和吸收效果，同时将电商项目v1.0的业务需求全部开发出来，形成一个电商系统雏形

### 02_需求分析：弄明白面前的项目到底要干什么

讲课的时候，说的一些东西，笔记性的一些东西，放这儿 

正经要制定出来的需求分析的规范，放下面，下面我们是不会胡乱放一些东西的 

作为架构师，你拿到了一份产品经理给的需求文档之后，这个需求文档里，定义清楚了整体的一个需求，包含系统需要哪些功能模块，整体系统的核心业务流程是什么样子的，还有一些其他的特殊需求 

我们第一件事情，就是要对这份需求文档，进行需求分析 

我再说一遍，之前的第3个课程，《大型电商系统业务需求分析》课程，其实是产品经理干的，在公司里，不是我们架构师搞技术的人员去干的 

在互联网公司里，这个事情一定是产品经理干的；在传统的IT企业里，不太一定，可能是有专门的业务调研人员去干这个事情 

我们这里不是上来就开始进行需求分析了，而是说先去定下来需求分析的规范，怎么进行需求分析 

在规范里，我们是没有包含特定的项目相关的信息的，其实就是一份通用模板，包含了这个需求分析文档要有哪些部分，每个部分要放什么东西 

我们以前在几年以前，常用的都是rational rose，IBM搞的一个画图的产品，专门用来画UML各种图的 

很多公司会用一些国产的比较好的一些绘图的产品，processon，就是一个很棒的产品，我这边是推荐大家，在架构设计里，画图是非常重要的一个环节，实际上来说，你作为一个架构师，除了技术之外，其他需要掌握的一些软素质，包含了画图能力、写文档能力，等等 

所以说，我推荐是说，不要只是看着我在这里写文档，和画图，建议大家从这一讲开始，全部跟着我走一遍，包括这个各种规范文档的编写，你到了一个公司里，必须要有这个能力，如果你光是看着我写，那是不够的，你自己看完了视频之后，锻炼你的这个写文档的能力。画图是同理，建议大家可以去注册一个processon的商用账号，其实也不贵，一年可能就100多块钱。看我每画一张图，大家都跟着自己去processon上画一下。 

其实说到这儿，大家会不会觉得有点不明白，用例到底是什么？其实很简单，一个用例就是一个功能 

其实用例图怎么画呢？其实就是从我们之前写的那份需求文档里抽取出来的，在需求文档里系统流程中，执行的各种动词，一个动词基本就是这个系统要实现的一个功能，一个动词一般来说就对应着一个用例 

画这个用例图，其实就是要标明，这个系统他到底有哪些功能，这些功能是跟谁相关的 

需求分析，是基于需求文档来的（我们之前产出的那个需求文档），需求分析做完以后，我们应该非常清楚，系统的具体的功能有哪些，每个功能的具体业务流程是什么，系统在运转过程中需要的核心数据是什么（领域类）

01_功能结构图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0201.png)

 02_用例图模板

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0202.png)

 03_用例事件流的泳道图模板

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0203.png)

 04_领域类图模板

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0204.png)

### 03_概要设计：作为一个架构师对你的项目进行全局性的设计

在正经公司里，如果你是一个架构师的话，你带了一个团队在做项目，比如说我的风格的话 

一般来说，像这个需求分析文档，是我来写的， 是架构师来写的；然后像这个概要设计，同样是架构师来写的 

但是到了后面的这个详细设计里面，一般来说为了锻炼底下的一些比较不错的同学，或者说尽快提升底下同学的系统设计的能力，会将详细设计的工作下放给项目组的各个同学来进行设计，每个人认领几个系统或者是模块，根据概要设计文档，来完成详细设计，最终将各个子系统的详细设计文档汇集起来，就是一份完整的系统的详细设计文档 

之前我们主要是通过用例图来画清楚系统需要实现哪些功能，对每个用例还画了具体的泳道图，我们就知道每个用例（每个功能）具体的业务流程是什么 

再之前，我们在需求文档里，用类似泳道图的这个图形，去画出来了系统的整体的各个核心流程的一个图 

概要设计，我们这个课时就讲完了，大家可能会发现说，诶，怎么跟你们公司平时画的图不太一样，结构有出入 

我告诉大家，概要设计，详细设计，业界没有通用的固定的死板的这么一个东西 

但是大概有哪些东西，可能是差不多的，比如说有的公司，传统IT行业，概要设计 -> 实现类图 -> 包图，需求分析文档 -> 数据字典 

我是按照我这么多年在互联网行业里，做了很多个项目，我觉得比较合理，和我比较喜欢的一种方式，来讲解概要设计、详细设计，应该怎么做

05_时序图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0301.png)

06_组件图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0302.png)

07_配置图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0303.png)

08_逻辑架构图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0304.png)

### 04_概要设计评审：让其他架构师对你的架构鸡蛋里挑骨头

我们在完成了概要设计之后，一般会召开这个概要设计的评审。而且可能不只是评审一次，可能会先第一次评审，然后一堆人指出一堆问题，然后负责设计的架构师回去修改，修改完之后，二次评审，可能还是不行，继续回去修改，接着进行三次评审。1627098499 

反正就是说，每次评审，就是召开一个评审会议，架构师负责在评审会议上讲解自己整个设计方案，一般会邀请级别较高的人出席这个评审会议，来对技术架构进行严格的把关。给大家举个例子，比如我是一个部门的架构师，我的重要方案评审的时候，可能会找其他部门的架构师过来，帮忙评审。同时也会让项目组内的全体成员都出席，确保每个人都听明白了架构设计，有问题及时抛出，然后讨论。 

之所以要评审，是为了保证说，架构师设计出来的架构方案，是比较合理的，而且没有什么明显的缺陷 

这份规范，是约定一下，在评审的时候，负责评审的人，主要从哪些方面去挑剔和挑战负责架构设计的同学，尽量去找出来系统可能存在的漏洞 

我们在第一个版本中，会按照这个思路去站在评审人的角度去考量一遍我们现有的系统架构的一些问题，但是实际上解决这些问题，我们会放到后面的课程里去

### 05_详细设计：指导team里的同学思考各自负责的模块如何落地

概要设计已经完成，而且通过了评审 

（1）逻辑架构 -> 技术架构，已经确定ok了

（2）运行架构 -> 时序图，已经确定ok了，系统跑起来是什么样子的

（3）物理架构 -> 系统开发、测试和线上环境部署的 

团队内部每个人认领部分模块或者子系统，然后每个人自己做详细设计 

说一下，概要设计主要确定的是架构，详细设计主要确定的是如何去编码实现 

也就是说，一份良好的详细设计文档，写好之后，基本你看着文档，就是傻瓜式的将设计翻译为代码了 

实际上来说，你写代码的过程，就是一个傻瓜式的过程，因为你怎么写这个代码，在详细设计文档里基本都已经定义清楚了 

所以我这边强调一下，不光是架构师，一个好的高级工程师，就应该能够做一份非常好的详细设计 

最终落实到编码的时候，你可以发挥的空间就比较少了，发挥一点点，尽量把代码写的漂亮一些，注释，编码规范，代码格式 

如果后面我们落实到一些技术上的东西的话，编码的时候，实际上会用到一些新技术，当然也是不错的 

只可意会不可言传，之前有一个同学，拿到一个项目，不知道怎么做数据库的设计 

你就没有去做需求分析（用例图、每个用例的泳道图），概要设计（时序图、逻辑架构图），你都没有考虑清楚 

如果你把前面两个步骤做的很好，那么其实你就应该对系统整体的技术架构、业务架构、功能逻辑、业务流程，非常非常的清晰了 

然后就根据你对上面那些东西清晰而且透彻的理解，去考虑，你负责的子系统中的各个功能，如果要实现，需要哪些数据库表来承载数据，才能实现这些 

经验足够多的同学，会有一种多年经验积累和沉淀的作用，看到业务需求，能非常好的将其快速的转换为技术设计，资深工程师，架构师的价值，这也是那些培训机构刚培训出来的生瓜蛋子，对于这些同学来说，绝对是刚开始最多只能做到初中级的工程师，初中级，在北京，10k以下初级，10k~20k，中级，20k~30k，高级，30k~35k之间，算是资深，35k~50k之间，算是架构师了 

如果是那种经验不足的生瓜蛋子类的工程师而言，我见过很多人，技术没问题，j2ee的技术都很熟练了，但是写出来的代码很烂 

就是在详细设计，几乎从来不好好设计，或者不懂怎么设计，实现类图，面向对象的设计，要去实现业务功能，设计哪些类，每个类有哪些东西 

我举个反例，我之前带过本科刚毕业1年的小伙子，在我团队里面，看过他写的代码，实现类图的设计，设计的很烂，就是完全没有思考一个业务需求下，要拆分为哪些类，哪些对象，哪些接口，每个类负责哪些职责，类与类之间如何互相交互。 

可能一个较为复杂的功能，就设计了一两个类出来，每个类里就两三个方法，每个方法囤积了大量的代码 -> 垃圾代码 

因为面向对象做的太烂了，后面让人根本就看不懂代码，然后也没法维护代码 

维护，往代码里面加入各种新功能的时候，难以下手。。。。。。 

每个方法里大量的代码，没有注释，没有良好的划分不同逻辑的一块代码之间要有空行，代码全都堆积在一起 

像这种垃圾代码，那个小伙子，他的技术是没有问题的，j2ee那套东西，redis内核，好学，偏偏写出来一手垃圾代码 

基本功！！！很重要很重要，基本功，连面向对象设计都没掌握好，就胡乱去看那些redis内核分析之类的东西，本末倒置了，你做出来的都是垃圾

09_实现类模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0501.png)

10_活动图设计

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0502.png)

### 06_详细设计评审：作为架构师对自己team同学的设计方案进行审查

### 07_工程初始化：从0开始启动你的项目开发进行落地

1. 每个人本地的开发环境搭建

2. 资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请

3. 数据库初始化

4. 代码初始化和上传 

实际上在做各种不同的项目的时候，根据你用到的技术不同，可能你需要进行的工程初始化的步骤都是不一样的 

整个软件工程的流程，是环环相扣的，需求分析 -> 概要设计 -> 详细设计 -> 工程初始化

### 08_版本控制：项目的全流程与Git版本控制如何结合起来

版本控制规范是什么意思呢？

这个时候代码还不能开始写，为什么呢？你这个时候不是在瞎写么？每个人用一个分支？每个人用不同的分支？分支与分支之间什么时候集成？怎么集成？在各个环境中流转的时候，分支怎么切换？

版本控制规范

（1）Git工作流，为你的团队和你的项目选择一套合理的Git工作流：分支如何管理，如何合并，分支工作的流程
（2）在Git工作流之外的一些规范，比如commit的提交规范，每天提交一次？还是按照什么粒度提交一次？commit的时候，写comment的备注的规范是什么？

GitFlow工作流，大家会发现，严格要求版本稳定，一个大版本，一个大版本的往前走

比较适合系统从0到1的时候
11_Git工作流规范

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0801.png)

### 09_编码开发：基于业界顶尖的阿里Java开发规范进行编码

编码，可是要规范的啊 

如果编码这块随便瞎编写的话，那就很坑爹，很多人按照自己的风格来写代码，最后出来的这个代码很乱 

一个系统里，感觉不同的人写出来的代码差别很大 

比如有的人，把UserDAO；有的人，是写成UserDao 

还有的人，IUserService；有的人，就是UserService 

如果你没有一套统一的编码规范的话，会导致不同的人出来的这个代码看起来差别很大，增加以后的代码的维护成本 

别人要来读懂你的代码，要来维护和修改的话，会导致无所适从 

一般来说，正经的公司，对编码规范这块，需要两个东西，第一个东西，是说约定好编码按照什么样的一整套的规范来；第二个东西，是说后面你需要有一个机制来确保每个人都是按照这个规范来走的 

在以前很早的时候，编码规范是有的，然后靠哪个环节来控制编码规范呢？靠的是code review，代码审查，别人在你写好代码之后，来阅读你的代码，如果有发现没有按照编码规范来的情况，告诉你，让你来修改代码。这个方式有很大的弊端，首先就是靠人力一点一点去审查代码，看有没有按照标准来写代码，会耗费很大的人力成本。另外一个，靠人力来审查，很可能会漏掉一些问题，不一定能做到百分之百的准确。 

比较好的一件事情，到我们今天为止，正好，就是有个比较大的福音，阿里发布了自己的一个Java开发手册。就是比较标准和完善的一份Java开发手册，基本上都是比较核心的，和重要的一些规范。如果规范写得太多太细了，没有人能记得住的。编码规范，就是提取比较重要的一些规范，精简，让人可以记住，可以按照这个去做就ok了。 

我们这个课程里，就直接采用阿里巴巴的java开发规范手册就可以了 

阿里还有一点比较好，就是他们出版了对应这个java开发手册的一个静态代码扫描的插件，跟eclipse，IntelliJ IDEA整合起来 

我们就是需要熟悉一下阿里的java规范手册，写代码按照这个来；写完代码之后，用静态代码扫描插件，扫描一下我们的代码，它会按照它预定义的规则，去检查代码，如果有不符合标准的地方，然后按照插件给出的建议来修改即可 

我们基于这个蓝本去修改一下，简化一下，形成我们自己的一个word版本的一个文档

### 10_系统测试：基于金字塔测试模型对各种bug严防死守

1. 单元测试（白盒测试）

2. 冒烟测试

3. 静态代码扫描

4. 代码审查

5. 集成测试（联调测试，也可能是RD自己干，不是QA干）

6. 系统测试（QA去干，黑盒测试）

7. 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM） 

这一讲，我们来站在架构师的角度来制定一下公司里的各个项目，按照什么规范和流程来进行测试 

首先先给大家说一下基本的测试的流程，当然这个测试流程不是最最完整的，而且不同的领域的项目，测试流程也不是完全一样的

传统IT行业的java系统的测试，ERP、CRM系统 -> 互联网行业的app后端的高并发后台系统的测试 -> 大数据领域的海量数据计算的数据类java系统的测试 

测试的种类和步骤会不断丰富，越来越多。比如说，并发越来越高了以后，需要有吞吐量测试、性能测试；有了高可用架构以后，还要有可用性测试，故障演练；数据量很大，可能还会有数据准确性的测试 

最最经典和传统的测试模型 

金字塔形状的测试模型 

后面我们在讲解spring boot的时候，会给大家讲解，如何对Spring Boot + Spring MVC + Spring + MyBatis的框架组合来进行单元测试，而且会给大家演示如何使用Hamcrest框架进行断言中的逻辑判断，如何时候用Mockito框架来进行对象的mock模拟

12_测试金字塔模型

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\1001.png) 

### 11_系统上线：谨慎再谨慎地对项目射出临门一脚

### 12_线上运维：秉持用户第一的理念来运维线上的系统

### 13_开发流程：再次回头梳理完整的开发流程以及几个关键点

1、梳理完整流程 

（1）业务调研：产品经理搞明白需求是什么

（2）需求分析：我们去分析产品经理给的需求文档，梳理出系统要干嘛

（3）概要设计：作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构

（4）概要设计评审：找其他部门的架构师来帮忙评审一下我们的架构方案

（5）详细设计：指导团队里的各个同学，自己对自己负责的部分进行详细设计，数据库建模、接口设计、类设计、包设计、功能流程设计、单元测试设计、冒烟测试设计、日志设计

（6）详细设计评审：我们作为架构师要仔细去看一下各个同学的详细设计，确保没问题

（7）工程初始化：指派多个同学，完成所有的初始化的一些事情

（8）版本控制：明确如何对代码进行版本控制，工作流是什么

（9）编码开发：根据阿里的开发规范，写代码即可

（10）单元测试：自己写所有的单元测试，测试每一个类

（11）冒烟测试：自己对负责的系统跑起来，冒烟测一下核心功能

（12）静态代码扫描：确保自己的代码符合规范

（13）代码审查：由高级别的人去审查自己的代码

（14）集成测试：所有环节集成在一起，确保系统整体流程炮通

（15）系统测试：QA来严格测试每个功能

（16）验收测试：PM验收系统

（17）系统上线：按照严格的步骤去执行上线
（18）线上运维：按照标准化的流程去处理线上的bug 

2、几个关键点 

你作为架构师，很多事情都交给小弟去做了，有的时候你会不会感觉到有点虚虚的？小弟干出来的事儿靠谱不靠谱啊。。。 

（1）概要设计评审：虚心听取其他人的意见，尽量在设计的时候，确保最佳的系统架构方案

（2）详细设计评审：你要去仔细的看每个小弟的详细设计文档，看每个系统的步骤都没有什么问题，重要环节

（3）代码审查：一定要让你或者高工，仔细去看一下，具体的代码搞的怎么样，有没有什么问题，重要环节

（4）集成测试 -> 系统测试 -> 验收测试：一定要注意去检查测试的各个环节的报告，只要测试没问题，基本你的小弟干的活儿还是靠谱的，重要环节

（5）系统上线：仔细审查小弟写的上线文档步骤，派一个高工陪着一起上线，重要环节 

3、如何深入理解 

了解完了整套流程和规范，但是可能还不够深入 

在公司里，一般不可能说一套规范，来了一个新人，直接看规范就可以干活儿 

流程和规范需要找一个有经验的高工去讲解一遍，大家处于这个状态，基本都了解，但是没实际干过，心里没底 

在公司里，一般也是说，会找一个需求，让一个高工带着新人小弟，从头开始，全部走一遍，一遍，全都通了，流程和规范 

后面我带着大家用我们真实的电商系统项目，走一遍，大家就知道怎么回事儿了 

4、如何持续完善 

在任何一个公司里，你刚开始都是出一个流程和规范的初稿，v1.0 

实际上，接下来就要去落地实践这套规范，在实践的过程中，可能会不断的去完善这个流程和规范，细化，提供更多的模板 

我们在后面一遍做项目，一边如果发现有不完善的地方，细化的地方，细化和完善我们的流程和规范

### 14_项目管理计划：为你的项目落地制定周密的作战计划

项目管理计划：就是在完成所有的技术设计之后，我们已经知道要怎么做这个系统了。但是现在的问题在于说，按照什么样的节奏、步骤和进度去完成所有的开发、测试以及上线的工作呢？ 

在以前比较原始比较low的时代，没有项目管理的概念的时候，项目管理的概念在国外一直比较成熟，传入国内，开始也主要是一些传统IT行业会干这个事情，比如华为。但是在互联网中，一般都是几个人的小团队，小作坊式的单打独斗，去开发项目。没有很好的项目管理的计划。 

在概要设计+详细设计都搞定之后，会有一个步骤，叫做排期 

每个人给出自己的排期，所有人的排期合并在一起，组成项目的一个完整的排期。就是每个人对自己负责的那个部分，给出来每个环节/功能要做完，需要花费多少时间，需要从几号到几号去做。然后的话呢，项目的总负责人，大R，就会按照这份排期去跟进和管理项目组的开发，直到最后确保项目的上线。 

但是这种原始的方式有几个问题： 

（1）排期，比较粗糙，粒度都很大。就是说，排期是静态的，很多时候，这个排期没有组成一个动态的情况。开发任务之间可能是有相互的依赖关系。但是每个人自己在排期的时候可能没有考虑到。小A说我做的一个X1模块，排期是从5月23号到5月28号；小B说我做的一个X2模块，排期是从5月24号到5月26号；结果。。。其实小A的X1模块，最后要全部完成，可能是要依赖于小B的X2模块。科学合理的规划，其实会出现排期混乱的一个情况。 

（2）其实每天每个人在干嘛，干了多少事情，有没有延期，有没有出现什么问题，是不是工作任务太轻松了，leader是不知道的，完全不透明。项目的执行进度完全不透明。到每周的周会总结的时候，可能就有的人很轻松，说完成了，2天时间就完成了5天的工作；有的人可能就delay了，说我才完成了60%。一定是有一些同学是有一定经验的，相当部分的同学，都是带过团队，技术经理以上的级别。年轻有为型的，带了小team。 

（3）执行到一半儿的时候，因为第一步中的项目排期定的非常的不合理，不科学。这就可能会导致说，小A开发X1模块，开发到一半儿了，突然发现说，小B，需要你的X2模块，你搞定了没有。小B说没搞定啊，我这要5月26号才能搞定呢。。。。小A说，惨了，我只能delay了，X1模块就到了5月30号才搞完。各种加班，各种救火。 

（4）项目可能是有一些风险的，一开始你的项目计划里定的好好的。就是说，到6月2号的时候，dba会负责给我搭建好一整套的mysql主从架构的数据库，我就可以基于这套数据库去进行验收测试。结果。。。dba到了那个时候，dba技术太烂，导致搭建出来的mysql数据库有问题，你需要的是mysql 5.6的版本，dba瞎搞，给你搭建了mysql 5.7的版本。delay，你说怎么办呢？dba的责任，不能怪我。。。你是架构师，你是全局主导整个项目的一个总负责人，所有的责任都在你身上。项目做的好了，最大的功劳就是你的。项目做砸了，delay，所有的责任都是你的。老板才不管你这么多，总监，副总，你能力不行呗。 

（5）做到一半儿，突然PM产品经理，修改需求，需求变更，我在项目过程中最讨厌的，拥抱需求变更，拥抱变化，敏捷开发的模式，极限编程。忽略了一个问题，为什么要有这些变化呢？就我的经验而言，我就得如果一个PM很靠谱的话，是不应该出现这种情况的。如果出现胡乱的需求变化，主要责任人是PM，太不靠谱了。没有考虑的很周到，拍脑袋，也是很模糊的一个状态。有些需求变更可能是合理的，比如说公司的战略方向，市场变化相关的。拖出去打。RD和PM之间是有仇的，RD用刀子捅了PM。 

混沌时代，项目计划粗糙、项目的执行不透明、风险没人管、变更胡乱进行，都是各种问题，一把辛酸泪，踩过太多的坑了 

项目计划粗糙，制定那么粗糙的项目计划了，如何制定一份科学、合理、精细的一份项目计划 

制定下来一套初步的立刻可以落地执行和实施的项目管理的规范，按照这套规范去执行整个项目的管理 

肯定有同学会专门在传统IT行业里，会专门做这个项目管理，肯定会考取这个证书，专业的证书，学过完整的理论 

但是理论 -> 现实一定是需要融汇贯通的，取舍和变化的，整套复杂的理论硬是全部要在项目去实现 

从0到1的时候，初步建立起来一个非常实用的项目管理的规范，就以我的经验而言，互联网行业里，项目跟传统行业是不太一样的，哪怕只是掌握好了我们这个课程里讲解的这些项目管理的实用性的东西，其实对于大多数同学而言，带一个10人以内的小团队，做一些中小型的项目，都没问题了 

到了后面，我们的这个项目和团队会变得越来越大，这套规范逐渐的就会变得不是很适用，规范，细化，应用项目管理整套理论中更多的一些东西 

制定的规范，只是一套用于参考的规范，到不同的公司，不同的项目，不同的团队，一定要根据你的具体情况去改编和调整你的整套规范，适应你的具体情况。如果你直接照搬我的规范，可能是有问题的。你学会了孙子兵法，出去打仗，我就要完全100%按照孙子兵法说的这样，上战伐谋，我就不开张，先想办法去跟人家谈判。但是其实这个时候可能更好的方法式，连夜奔袭，直接突击敌营，击溃敌军。 

主要是给大家一个比较通用的一个规范和思路，让大家明白说，整体的流程是什么样子的？我们按照一种规范和实现方式，全流程做一遍这个项目。

13_网络图模板

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\1401.png)

14_甘特图模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\1402.png)

15_资源配置表模板

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\1403.png)

### 15_项目执行监控：严格把控项目每天的每一步进展

项目中可能有很多个人，很多种角色，可能项目组里有4个人，5个人，10个人，20人，30人，50人。100人的大团队协同作战。 

如果你只是定好了项目的管理计划，而没有做任何的项目执行的进度把控，那么其实那个计划，正常来说，就会流于形式和表面。设想一个场景，假设你把项目进度计划做的很棒，很好了，这份项目计划直接发下去。然后接下来你就不管了，你可以想象一下，项目会干成什么样子？两个问题，一定是人都是有惰性的，这个是人性，不是说一个人是好人，还是坏人，就是只要没有监督和管理，人一定是会或多或少有惰性的。哪怕是一个靠谱的人，在没有监管的情况下，惰性一旦发生，就可能会导致什么呢？ 

今天这哥儿们突然想说，哎呀今天的工作稍微缓一缓把，我最近失恋了，心情不佳，实在是不想干活儿。。。或者是，哎呀，最近这两天的工作，稍微慢一点吧，先稍作一点儿，平时3点就偷偷溜走了，让同事给代打个卡（瞎说的，在大型的互联网公司里，其实比较松散的，不同的人工位都在不同的地方），溜走了，去跟我的大学同学正好来北京出差，我跟他一起玩玩儿。 

我们这里这一讲，要说的就是项目执行的监控和把控 

如果不进行严格、科学以及良好的项目执行的监控，可能就会发生各种各样想不到的情况跟，到每周看一下进度的时候，各种delay，各种延期，各种没做完，找了一大堆的借口出来，死猪不怕开水烫的样子。项目就濒临崩溃。。。。 

不是这个人有惰性，这个人，他可能是能力不够，做事情的过程中，一定是会遇到这样那样的一些困难、挑战以及问题的，自己没法解决，然后你又没有及时关注，最后直接导致这个人的工作delay。长此以往，项目崩溃。。。。 

项目崩溃，本来预定的是6月5号上线，结果，6月12号，6月20号，7月1号。整整延期了1个月，一个10人的团队，每个人平均年薪24万。平均月薪2万。每个月公司的工资的成本就是20万。也就是说，项目胡乱管理，团队战斗力太差，项目每次延期一个月，给公司空耗20万的资金。 

我之前说的那个100个人团队，公司直接损失200万的资金。还要加上公司还要给你支付各种五险一金，300万。 

我先说一个前提，我个人认为，项目总负责人是直接决定了一个项目的成败的。项目leader每天啥都不干，就是问问进展，帮着协调和解决，开会。结果活儿都是下面的人干的，这个leader干什么呀，瞎搞。没出什么力。如果一个项目没有一个很好的项目leader，全权负责和把控这个项目的方方面面，那么这个项目很可能就会失控，因为哪怕这个leader只是起到每天去监控一下你的项目执行进度的作用，但是这个监控的行为是非常重要的。 

千军易得，一将难求 

在打仗的时候，古代的历史、兵书，将出了问题，这支军队就完蛋了 

段子，我在多年前，刚开始带项目的时候，青色，买了一些项目管理的书，去看，看到东西，积累项目管理的知识体系，但是跟实际你去带项目，差别还是很远的 

实际你带项目的过程中，一定会遇到这样那样的各种乱七八糟的问题，需要你灵活机变的去解决这些问题。我在这里有一个观点，你说考了一些项目管理的证书，大学生都没工作过，就去考一堆的证书，比如Oracle OCP、OCM，Cisco CCIE，CCNP，数据库专家，数据库大师，网络专家，网络工程师的，一些认证。 

反之，如果有人没有考这样的一些证书，但是他把那些证书背后需要学习的教材，自己买来看了一下，然后有多年的相关经验的积累，带了很多的项目，实际踩了很多的坑，那么这个人也许没有证书，但是这个人在这方面的能力和经验的积累，一定是更强的，实践是最宝贵的，实践出真知，有实践经验之后，就代表着这个人基本上可以把这个工作给干好 

带两个同学，一块儿去做一个项目。性格上都有问题，计划的时候，颗粒度太粗了；拉不下面子去每天监控每个人的执行进度；有些人还有脾气，反正当时定的是5天干完一个事儿，那我就5天之内干完这个事儿不就得了。你干嘛每天来东厂太监一样来监视我，硬逼着我每天必须干完什么事情。歪理，项目，是一个变动性很高的事情，做的过程中，可能会有各种各样的一些变化，每天卡着进度是不合理的。 

那个项目就失败了，原本预定是在8月底上线，结果一直拖拖拖拖到了10月底才上线，延期2个月，失败的项目管理的例子

### 16_项目风险管理：对项目中可能出现的问题做到未雨绸缪

### 17_项目变更管理：严格控制不靠谱PM提出的需求变更

### 18_技术调研：用一个新技术之前做到知己知彼

### 19_Spring Boot基础系列：从上帝角度看看如何学习这个技术

Spring Boot + Spring MVC + Spring + MyBatis + 设计模式 

Spring MVC + Spring + MyBatis，j2ee就业班培训机构，他们其实都已经做的非常好了，我们就不用去讲了 

Spring Boot，设计模式：快速学习 -> 技术储备 -> 模拟公司里的技术调研 -> 大面积的将这些技术运用到有真实复杂业务场景的项目中去 

普通人的角度，人类角度，Spring Boot，然后去开始想，先写hello world，再看看官网，再网上搜索一些博客，系列性的，系统跟着敲一遍，找找视频课程，跟着做个小型的demo级的小项目 -> spring boot 

1、不用Spring Boot的痛苦是什么？ 

（1）各种技术整合在一起，版本混乱，大量依赖自己去找，依赖冲突

（2）基于xml格式的配置文件，对各种技术框架进行大量的繁琐配置，mvc-servlet.xml，applicationContext.xml，mybatis-config.xml，web.xml

（3）web系统跑起来测一下，需要与tomcat等web容器整合起来才能测试

（4）单元测试的时候需要自己去选择和导入需要的各种测试组件的依赖，junit，hamcrest，mockito，很多组件

（5）部署打包的时候需要自己去配置打包插件

（6）部署应用上线之后，没法去对线上的应用，包括jvm堆栈等方方面面进行监控，没有方便的办法去看到这些东西 

传统的以spring为核心的web系统开发，从启动项目、开发、测试、部署以及监控，都很麻烦，有大量需要手工做的事情 

2、用了Spring Boot以后的好处是什么？ 

spring社区意识到了这些问题，开发人员一定是最讨厌繁琐的，希望的都是用技术提高工作效率。因此推出了spring boot框架，作为开发spring项目的一个脚手架，脚手架，类似于一个封装在各种技术之上的一个基础框架，基础模板。脚手架帮助我们快速整合需要使用的技术框架，快速开发、测试以及部署和监控，节约我们的成本。如果没有spring boot，很多公司，特别是一些大公司，会将spring mvc 、mbatis、spring这些框架再度根据自己公司的开发经验、规范和实际情况，再度封装，进一步简化每个新项目使用框架的一个成本 

Spring Boot是spring官方社区推出的，设计思想，架构思想，是更好的，更加优雅的 

（1）spring boot负责统一各个依赖的版本，保证各种技术的版本之间兼容，自动引入需要的各种依赖。spring boot 1.5.9，在这个版本基础之上，你引入的spring、mybatis、spring mvc、redis、zookeeper、kafka、mongodb，等等各种技术，在spring boot1.5.9这个大版本的基础之上，其实所有技术的版本都是互相兼容的，省去了我们自己去寻找版本整合，解决不兼容问题的一个过程 

（2）所有技术整合进来之后，不需要xml配置，spring boot全部是大量基于按照约定的自动配置，自动生成那些技术相关的一些bean，注入spring容器供使用，基于注解进行少量注释，基于application.properties，少量的配置即可 

（3）spring boot支持内嵌的web容器，上来直接启动一个main方法就可以启动一个内嵌的tomcat web容器+web程序，快速上手测试，http://localhost:8080/ 

（4）一键引入需要的所有单元测试组件依赖，所有测试组件的版本兼容，支持controller、service、dao各种测试 

（5）默认声明一个插件，自己给你把插件配置好了，支持打包成可以执行的jar包或者是war包 

（6）系统上线之后，默认支持大量的线上应用的监控metrics，可以看到线上应用的jvm堆栈，等等信息 

3、对于Spring Boot这种框架型技术该如何学习？ 

（1）spring core，那么多复杂的功能，你都学习了吗？spring mvc那么多复杂的功能，你都学习了吗？否，20%。 

（2）你在工作中都会用到spring core和spring mvc，这些框架100%的功能，你都使用了吗？否，20%。 

（3）在面试的时候，有面试官会揪着spring core和spring mvc的各种生僻冷门的功能、api/方法的细节，问你这个功能怎么回事，那个功能怎么回事吗？否，我面试从来不问任何一丁点的框架功能性的东西。 

（4）技术分成五种：框架性的技术，中间件的技术，架构，项目经验，底层技术。框架型的技术，28法则，20%的核心功能，就足够项目中的使用了。学了剩下80%的功能，几乎很少用到，而且功能性的东西，学习，几乎是零成本，你只要掌握了20%的功能，就已经学会了这个技术的基础了，如果你后面项目里需要80%的冷门功能，百度，官网，只要是个大脑正常的工程师，自己都可以搞定。 

功能的学习，是最简单 

空调，电视机，pc电脑，手机：学会用这些东西，当然要花点时间和成本咯，但是如果要了解这些东西是怎么制造出来， 专家 

spring boot，spring，spring mvc，mybatis：学会用，几乎是非常的简单，只要你学会了一点，后面如果你要学剩下的东西，都是易如反掌 

但是真正难的是什么？spring boot的源码，设计思想，架构原理，技术亮点；spring core，spring mvc，mybatis，源码层面的 

如果让你来手写一个类似于spring boot的框架， 你能写出来吗？ 

（5）重要的是，迅速掌握20%核心功能，务必熟练，然后就用这20%的核心功能，80%的项目，你都可以做了；接着对剩下百分之80的冷门功能，可以先看一看，项目不一定能用到，未来20%的特殊项目中有需要的时候，迅速通过百度+官网，找到80%的冷门功能中哪些是你需要使用的，快速学习一下，引入项目中来使用即可；最后有些冷门的东西，包括概念和功能，也许你一辈子都用不到。spring core那份官方文档里，可能有50%的东西，我工作10年+，项目，几乎从没用过。如果有些课程没讲到的冷门东西，你项目中真要使用，很简单，百度一下，或者看一下官网，这是工程师的必备能力，总不能饿永远靠着课程里教的东西在活着吧，学习能力很重要 

（6）对于框架型技术来说，更重要的，是看源码，掌握其底层的设计原理和架构思想，包括技术亮点，提升自己的内功修为。 

工作中用这个技术遇到报错，直接源码分析定位，不用借助他人，hold住全场；很厉害的，spring boot，spring ，mybatis，spring mvc，真正难的不是使用，难的是在工作中遇到了各种报错，看到了异常堆栈，傻眼了，没法处理。架构师，一条，hold住全场，你去大部分的公司，大公司，小公司，技术问题的方方面面，能hold住全场，任何问题出了你是公司的技术力量的制高点，最后一道防线，你一定能解决任何的问题。可以称之为技术专家，高级技术专家，资深技术专家，架构师。 

提升你的技术内功的修为，大量的借鉴开源框架源码中的设计思想、架构思想、核心技术，应用到自己的系统设计中；读更多的优秀的开源框架的源码，你的内功修为就越高，你在设计自己的系统的时候，系统架构设计的更好 

技术每隔几年就翻新一次，如果每次都是跟着学一些框架功能和使用，那就太low了，费力不讨好，如果不断研究源码，内功修为深厚，会发现大道相通，每次技术更新，你都能快速掌握新的技术。struts2+spring+hibernate -> spring mvc+spring+mybatis -> spring boot+spring mvc+spring+mybatis -> spring cloud+spring boot+spring mvc+spring+mybatis。每次出一个新技术，光是看一看功能，你就能猜测到背后的源码是怎么写的，站在这种内功修为的基础之上，你学习任何新技术，事半功倍，效率是普通的几倍。 

对技术你掌握到了源码层面，面试有强大优势和竞争力，这是程序员的硬功夫，立身之本，出去面试可以甩开99%的普通工程师几条街。学会用一个框架，只要不是傻子，都能学会，所以如果你工作很多年，仅仅只是会用一些技术框架，你觉得你的技术有什么竞争力可言？但是读懂大量的开源框架的源码，积累深厚的技术功底，这个是需要大量的时间去积累的，有一个老师能够带着你给你去讲解，90%的人靠自己读源码，不现实，功力不够，读不会，读不懂，最后没法读源码，能尝试读懂一点点源码，但是没法彻底吸收，融会贯通。源码读懂，吸收，融会贯通。核心竞争力，不是说普通人可以随随便便赶上你的了。 

（7）按照这个思路学习框架型技术的效果 

出去工作，20%的功能会用，没问题，上手开发一点问题都没有；出去面试，有源码兜底，强悍的竞争力 

4、我们的课程对spring boot框架型技术的学习思路 

（1）看一下网上别人的spring boot类技术课程，还有书籍，讲的大而全，spring boot的方方面面都有了。但是看了一遍，有用么？都是理论，根本不知道项目中怎么使用 

书籍：大而全，什么都有，专注于完整的功能讲解

视频课程：大而全，什么都有，专注于完整的功能的讲解 

如果这么去学习一门技术的话，如果我们这个课程跟他们一样，按照一样的思路去讲解spring boot技术，那我觉得我是失败的。因为我是不认可这种技术学习的思路的。你学到的就是一堆理论型的技术而已，你不知道在项目里应该怎么结合项目、业务需求、业务功能来使用，而且你光是学纯理论，过一段时间就忘了；如果你能在项目中大量的去实践这个技术，记忆和印象会非常的深刻 

不能对框架型的技术学习，不能这样子学，大而全的，一方面很多东西，如果不能立刻用到项目中去，你的掌握很薄弱，你不知道这些技术怎么结合项目来使用；如果没有办法将学到的技术，立即投入项目中去使用，你很快会忘记，记忆会很不深刻 

技术能力，其实都是围绕着我们的工作经历，项目经验，发展起来的。我做过这个东西，我学过这个东西。你的理解很深刻， 记忆很深刻，你实际知道这个东西是怎么在项目里用的。 

技术的学习，无论是什么，都务必要跟项目和实践结合起来，否则的就是纸上谈兵，很容易遗忘，出去找工作，面试 

（2）在每个阶段，针对这个阶段项目要做的事情，我们就学习这个框架需要使用的功能，过框架学习的时候，速度要快，别耗费太多精力在这里扣细节，框架学习的重点是快速学会后用到项目里去，大量开发业务需求，实践中来掌握 

spring boot，会被拆分为多个阶段去学习，我们会完全按照公司里的随着项目演进，不断加深学习一门技术和不断实践的一个思路，带着大家去走 

我们的项目是分成很多个阶段，阶段一，阶段一的技术挑战是比较小的，我们就去学习spring boot 20%的核心功能即可，我们快速几个小时学完以后，每个人都能上手开干，立即投入项目中，大量的去写业务功能，实践，加深你的印象 

当然，阶段一，重点会剖析spring boot框架的核心源码，才是我们真正要花费实践在spring boot上的，竞争力 

后面随着每个阶段的进展，比如我们的阶段二，要使用redis技术，然后我们就先学spring boot如何跟redis整合使用，立刻投入到项目中，大量跟项目整合来使用，印象会非常深刻，我们会同步剖析spring boot跟redis整合部分的源码 

（3）随着项目阶段不断前进，对于框架型技术的学习会逐步完善，而且每一块的学习，都会是快速过功能，然后迅速用到项目中去实践的思路 

（4）但是对核心框架的源码，必须100%要分析，因为这才是真正的重点和工程师的核心竞争力 

我们整个技术体系里，框架型技术，实际上不多，spring boot，spring cloud 

很多的技术，是中间件型的技术，redis、zookeeper、kafka。中间件型的技术，学习的思路就完全不一样了。非常非常重要的，务必是说把80%的核心功能都要掌握，然后尽可能在项目中将80%的核心功能都给实践了，同时尽量对重要的中间件，都要去剖析里面的源码。招聘需求的时候，深刻理解分布式的消息、缓存、存储、搜索，redis内核源码、zookeeper内核源码、kafka内核源码、elasticsearch内核源码。让大家不是仅仅只是学会用一个中间件技术，而是要从根本上的底层原理，去掌握分布式的缓存、分布式的协调、分布式的消息、分布式的搜索、分布式的存储。 

5、我们这个小阶段学什么 

阶段一，其实只要掌握spring boot 20%的核心功能，就足够了，立刻就开始动手开发，去做项目 

（1）Spring Boot快速入门

（2）Spring Boot与Spring MVC+Spring+MyBatis的整合使用以及RESTful接口的支持

（3）Spring Boot框架配置

（4）Spring Boot单元测试

（5）Spring Boot打印日志

（6）Spring Boot应用部署

（7）Spring Boot应用监控 

按照公司的规范，编写一份Spring Boot的技术调研文档 

上面这些东西就完全可以支持我们阶段一的项目开发了，其实我们就是要用spring boot整合spring mvc+spring+mybatis来进行基础的开发，对外提供restful接口，进行单元测试，打印日志，最终部署一个单块的web应用，然后线上可以进行监控，仅此而已，完全足够我们用了 

在开发完电商系统v1.0之后，我们来剖析一下spring boot使用到的这些部分的源代码，看源码，将从这里开始，同时还会讲解如何手写starter来支持任意技术与spring boot整合，比如公司自行研发的框架之类的东西 

5、我们这个小阶段不学什么以及未来阶段学什么 

（1）spring boot与thymeleaf、freemarker等模板技术的整合 

这个阶段暂时不学习 

纯后端放所有的java代码和前端模板页面，因为这个未来不是主流趋势了，主流趋势是前后端分离，我们后端工程师不再关注页面上的东西，纯碎关注后台架构，提供RESTful接口或者是rpc接口给前端工程师调用。大公司全部是这样，中小型公司未来主流也该是这样。如果有那种公司，还将前台页面包含在后端工程里，让java工程师写html模板，那赶紧走，这公司太没前途，技术太low。 

未来只有那种非常小的项目，前台后台都是一个人写的项目，大学生的毕业设计，适合采用jsp、thymleaf模板放java工程里，后端工程师一个人写了 

我们会提到一点，但是不会耗费大量精力去琢磨spring boot跟各种模板技术整合的细节 

到了后面，做高并发系统架构的时候，一定会涉及到大型电商系统的复杂的页面静态化架构，那个时候我们再来结合具体的架构和项目讲解与模板技术的整合 

（2）Spring Boot与Spring Data JPA的整合 

不学习 

JPA，Java Persistence API，java持久化API，ORM的概念，hibernate。就是不需要你写sql，直接你就是面向对象去操作和开发，从一个对象里面去get一个集合，此时hibernate会自动给发送sql查询数据。hibernate，性能很低，自动生成的sql都有问题。开发效率很高，很好维护，不需要写sql. 

ORM框架很好，但是比较适合传统IT行业，性能要求不高，开发速度要求很高。我最近这么多年的工作，已经很少见到有用hibernate的了。一般都是mybatis类的框架，支持写SQL，加上一些mybatis对sql的特殊功能的支持。java工程师精通写sql必须的，写sql不是java工程师的活儿，是dba的活儿，java工程师只要面向对象就可以了。 

暂时没看到需要学习这块的必要性 

（3）Spring Boot与中间件技术的整合 

mongodb、redis、elasticsearch、cache支持、分布式session支持、zookeeper、kafka 

暂时不学习 

spring boot整合mongodb，mongodb的核心概念以及CRUD的操作 

现在学习这个干什么呢？学完就忘了。等到后面项目进展到要用mongodb、redis、elasticsearch的时候，自然就会学习如何Spring Boot与这些技术整合在一起使用了，这都不是事儿，学完了立即投入项目中，剖析他的源码 

等项目进展到要搭建缓存架构的时候，自然会学习cache支持，项目做成分布式系统之后，要用到分布式session的时候，自然会学习分布式session的支持，引入zookeeper、kafka的时候，自然会学习如何整合 

（4）spring boot与jdbcTemplate的整合 

这种技术都没必要讲解了吧，包括jdbc的使用之类的，太原始了，spring boot为了大而全提供了这个支持，但是不意味着我们要讲解和使用，现在机会很少见到项目是用JdbcTemplate的 

（5）spring boot与websocket、webservice的整合 

这些其实都是spring boot提供的功能，同上，为了大而全，spring boot一定会提供大量的功能，但是我们不一定要使用。websocket是一个很不错的技术，常用于浏览器和服务端进行频繁大量的通信，就是浏览器需要主动跟服务端进行频繁的大量的交互，不断的刷新和更新数据。 

不是普通的那种系统开发要用的技术，常见的场景是：社交聊天、弹幕、网页游戏、股票基金实时价格、体育实况更新、视频会议、在线教育，等等。 

这个我们看后面课程具体的发展情况，如果有合适的场景，比如电商系统的聊天系统，让用户与客服沟通，可以使用websocket技术，等真正用到这个技术的时候，我们再来讲解 

而至于webservice，未来都是微服务的天下了，这类webservice，SOA，技术以后可能会逐步退出历史舞台 

（6）spring boot与安全技术的整合 

spring security，oauth2 

这个不会放这儿讲解，会放到后面专门的一大块安全性架构中去讲解，针对各种安全性需求，spring boot这块可以做什么 

（7）spring boot对定时调度的支持 

这个以后电商系统里一定会有定时调度的需求的，到时候再讲解 

其实你能在网上看到的一些书籍或者视频课程里的东西，我们的整套课程后面是一定都会包含的，只不过采取我的授课思路，逐步演进式的学习 

spring boot官方手册里的一些东西，随着我们系统的不断深入，如果要使用到一些东西，我都会带着大家不断的去学习使用的

### 20_Spring Boot基础系列：快速上手写一个demo体验一下

20%的核心功能，学会，有些同学，也许之前看过一些书，或者是看过一些视频课程，那么其实可能已经按照我说的那种大而全的方式先学了一遍，可能都会了，那就更好。建议大家说就当是复习，跟着我走一遍，其实就花几个小时的时间，带着大家快速学会这个技术。而且我认为，如果只是学习spring boot的功能的话，不光是学习20%的核心功能，你只要花点时间，把spring boot挑一本书，或者挑一个视频课程，整个看一遍，跟着走一遍，只要不是傻子，都能学会。但是我这里的重点，集中在做完项目之后的spring boot核心源码剖析那块，那是有技术难度和挑战的亮点。 

1、创建一个空的maven工程 

2、在pom.xml中引入spring boot的依赖 

```
<!-- 继承spring boot的父工程 -->
<!-- spring boot父工程直接约束了常用依赖的版本 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
<!-- 添加一个支持web应用的spring boot依赖 -->
<!-- spring boot会根据我们引入的依赖，判断出来我们要开发一个web工程 -->
<!-- 接着会对web工程需要的东西，比如tomcat服务器，自动进行配置 -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
<!-- 引入一个spring boot插件，可以支持我们打包程序 -->
<!-- 打包时是需要将所有依赖的第三方jar包都打进来的，spring boot这个插件可以支持 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build> 
```

3、编写代码 

```
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.stereotype.*;
import org.springframework.web.bind.annotation.*;
// @RestController会告诉spring boot，这是一个spring mvc的controller
// 同时@RestController默认就是支持将返回值直接给浏览器的，而不是去渲染视图
@RestController
// auto configuration，是spring boot最最重要和核心的功能之一
// spring boot的核心思想，就是不要去做太多的xml配置，全部基于约定的一些规则，自动完成一些配置
// auto configuration，就会根据我们引入的一些依赖，比如引入spring-boot-starter-web，就会根据我们要开发web程序的特点，自动完成tomcat服务器等相关的web配置
@EnableAutoConfiguration
public class HelloWorldApplication {
    // @RequestMapping，就是做http请求的路由
    @RequestMapping("/hello")
    public String sayHello() {
        return "hello world";
    }
    public static void main(String[] args) throws Exception {
        SpringApplication.run(HelloWorldApplication.class, args);
    }
}
```

4、直接运行spring boot应用 

直接在eclipse中执行main方法，就可以启动spring boot应用 

访问浏览器：http://localhost:8080/hello，可以看到浏览器下显示： 

hello world 

5、将spring boot应用打包成可以直接执行的jar包 

因为我们之前使用了spring-boot-maven-plugin插件，所以可以直接打包，就会包含依赖的所有第三方jar包，成为一个可以执行的jar包 

mvn pakcage 

然后执行这个jar包：java -jar target\springboot-demo-1.0.0.jar 

就会启动spring boot应用，访问浏览器可以看到响应结果

### 21_Spring Boot基础系列：入门demo中的基础知识的快速梳理 

一、demo程序中的知识说明 

1、spring-boot-starter-parent的作用 

（1）默认的编译级别是JDK 1.6

（2）指定了UTF-8为source coding

（3）有一个<dependencyManagement>声明，对spring boot可以集成的大部分流行第三方依赖，都指定了对应的可以互相兼容的版本

（4）开启了资源过滤器，支持对应资源文件中占位符的替换

（5）指定了多个插件：exec、surefire、git commit id、shade，用来支持运行、测试、版本控制、打包 

2、不直接继承spring-boot-starter-parent 

如果要继承自己的parent工程，而不是直接继承spring-boot-starter-parent，那么可以考虑使用import方式，将spring-boot-start-parent中的dependency management引入进来。但是这样的话，就没法用到plugin management了 

```
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.5.9.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement> 
```

3、自己指定JDK版本 

```
<properties>
    <java.version>1.8</java.version>
</properties> 
```

4、使用spring boot的打包插件 

spring-boot-starter-parent指定了pluginManagement，配置好了一系列的插件，其中一个就是用于打成可执行jar包的shade插件。如果我们要使用的话，需要自己手动声明这个插件，然后通过mvn pakcage命令就可以将工程打包成可以执行的jar包了。 

```
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build> 
```

5、spring-boot-starter-* 

spring-boot提供了一些列的starter类依赖，跟流行的常用项目进行整合，比如mybatis、redis、mongodb、elasticsearch，等等。我们只要声明对应的spring-boot-starter-*，就可以直接使用对应版本的依赖，多个依赖的版本都是兼容的。可能就是通过application.properties，注解，少量的配置，就可以快速整合进来一个技术开始使用 

6、基于spring boot进行开发需要遵守的约定规则 

一般建议基于spring boot来开发的时候，按照spring boot约定的规则来设置我们的包结构、代码布局，比如下面这样，这样spring boot在按照约定搜索各种注解的时候，一般不会出现什么问题

```
com
 +- zhss
     +- springboot
         +- Application.java
         |
         +- domain
         |   +- User.java
         +- dao
         |   +- UserDAO.java
         |
         +- service
         |   +- UserService.java
         |
         +- web
             +- UserController.java 
```

用于启动的类一般会按照下面这样来写 

```
package com.zhss.springboot-demo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
} 
```

7、Configuration类 

spring boot的一个核心思想，就是尽量消除掉各种复杂的xml配置文件，所以一般建议如果要进行一些配置，可以采用Configuration类，在Java类中做一些配置 

而且通常比较好的实践是，就将用来放main方法的Application类，作为Configuration类，所以一般会给Application类加@Configuration注解 

如果不想将所有的配置都放在Application类中，也可以使用@Import注解将其他的Configuration类引入进来，或者是依靠@ComponentScan注解自动扫描其他的Configuration类 

即使一定要使用一个xml配置文件，建议是用@ImportResource来导入一个xml配置文件 

8、Auto Configuration 

（1）什么是Auto Configuration 

Auto Configuration是spring boot中非常核心的一个功能，因为spring boot的一个核心思想，就是尽可能减少我们要配置的东西，尽量才有约定规则自动完成一些配置。这个Auto Configuration功能，就会根据我们引入的依赖，来推测我们做什么事情，然后自动给我们完成需要的一些配置。举个例子，如果依赖了HSQLDB，那么spring boot会基于HSQLDB自动配置和创建一个内存数据库。 

（2）如何启用Auto Configuration 

我们给@Configuration类，增加了@EnableAutoConfiguration注解之后，就会开启Auto Configuration功能，而且一般推荐使用使用@EnableAutoConfiguration开启Auto Configuration功能 

9、与Spring核心框架进行整合使用 

spring boot可以无缝与spring框架进行整合使用，一般就是在Application类上加@ComponentScan注解，启用自动扫描所有的spring bean，同时搭配好@Autowired注解来进行自动装配。只要按照上面的那个约定，将Application类放在最顶层的包结构中，那么使用了@ComponentScan之后，就可以自动扫描和搜索到所有的spring bean，包括了：@Component、@Contorller、@Service、@Repository 

10、@SpringBootApplication 

大多数的spring boot项目，都会在main类上标注：@Configuration、@EnableAutoConfiguration、@ComponantScan，因为这个实在是太过于常见了，所以spring boot提供了一个@SpringBootApplication注解，这个注解就相当于是上面3个注解的综合。所以实际上在开发的时候，一般就会在main类上加一个@SpringBootApplication注解 

11、启动spring boot程序 

spring boot的另外一个核心思想，就是尽量简化各种应用的开发。 

比如最常见的web应用程序，如果使用传统的方式来开发，需要安装和配置tomcat/jetty服务器，然后还需要将web程序打包后放入tomcat中才可以运行。或者是需要将eclipse等ide工具配置支持tomcat，才能在eclipse中直接启动web程序。 

而在spring boot中，直接基于了内置的tomcat/jetty容器，可以在写好代码之后，一键启动web程序，然后就可以在浏览器中访问了。对于本地开发、测试以及debug个调试，都是非常的方便的 

（1）在IDE中启动spring boot程序 

直接运行main方法即可，默认会绑定在8080端口上 

（2）在命令行执行jar包来启动spring boot程序 

使用mvn package将应用程序打成一个可以执行的jar包之后，就可以在命令行使用jar -jar命令来启动了，scp命令，自行百度，拷贝到线上的服务器

```
$ java -jar target/myproject-0.0.1-SNAPSHOT.jar 
```

同样在启动spring boot应用程序时可以传递一些参数 

```
$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8082,suspend=n \
       -jar target/springboot-demo-1.0.0.jar 
```

（3）在命令行直接启动spring boot程序 

也可以使用spring-boot插件的run goal来直接在命令行基于代码启动spring boot程序，几乎很少用 

```
$ mvn spring-boot:run 
```

二、devtools工具 

12、devtools工具介绍 

spring boot为了贯彻简化开发过程的原则，提供了一个devtools工具，基于这个工具，可以在开发的各个环节，尽可能地简化工作 

```
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies> 
```

如果我们启动一个打好包的spring boot应用程序，这个应用程序会被认为是生产应用，那么此时是不会让devtools生效的。而且一般推荐将optional设置为true，这样如果我们的项目被别人依赖，devtools是不会传递过去的 

13、让系统在代码变化的时候自动重启（常见于本地开发和调试） 

如果我们的应用程序使用了devtools，此时如果在IDE中直接启动，则会认为是开发调试过程。则此时如果classpath中的任何一个文件变化了，就会自动重启应用程序。在IDE中启动程序的时候，这个功能时很有用的，因为我们启动了一个web程序之后，会随时调试和修改代码，代码修改之后，不需要手动重启，web程序自己就重启了 

但是上面介绍中也说了，打成一个jar包，java -jar启动一个jar包，对于执行jar包的情况下，spring boot会认为这是生产环境，则不会启用devtools的任何功能，包括这个自动重启功能 

devtools使用了两个classloader来加载类，一个是base classloader来加载第三方依赖的类；一个是restart classloader来加载我们自己编写的文件。如果我们自己编写的文件改动了，则此时会重新创建一个restart classloader来重新加载我们的类，这个速度是很快的，因为base classloader是始终保持的，不需要重新加载第三方依赖的类 

如果要排除掉某些资源文件的变动不要自动重启，那么可以进行如下的配置，application.properties 

```
spring.devtools.restart.exclude=static/**,public/** 
```

如果要彻底禁用自动重启功能，需要做如下配置，application.properties 

```
spring.devtools.restart.enabled=false 
```

14、将本地修改的代码同步到远程服务器上部署的应用 

devtools也可以用来管理远程机器部署的系统，如果要启用远程系统管理支持，需要进行如下配置，下面的配置可以确保说打包后的程序是包含devtools的。但是要记住的一点是，使用devtools管理远程部署的系统，是比较危险的，尤其在生产环境中，一般强烈建议不要基于devtools来管理 

你在eclipse里面修改代码，直接就可以将修改后的代码，热同步到远程服务器上启动的spring boot应用中去。绝对绝对不要用于生产环境。如果你要用于测试环境，假设你要修复bug，速度要快一些，可以用这个功能，直接将本地修复好bug的代码同步到测试服务器上的spring boot应用中去。 

Git工作流，集成测试，develop在本地复现代码，commit提交，push到远程gitlab上的分支上去跟别人的代码做集成，接着再次部署这个develop分支的代码到咱们的测试服务器上去。也不支持去用这个功能 

```
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>
</dependencies>
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludeDevtools>false</excludeDevtools>
            </configuration>
        </plugin>
    </plugins>
</build> 
```

然后还需要设置一个参数 

```
spring.devtools.remote.secret=123456 
```

做了上面的配置之后，如果我们将这个程序打包后，在我们的某台机器上启动，此时会基于devtools暴露出来一个可以连接的端口，如果我们设置了上面的那个参数之后，这个远程服务器上的服务组件，就会自动启用 

然后我们需要在本地手动运行一个客户端组件，一般就是在IDE中启动即可，在IDE中需要使用run configurations，对我们的应用程序，使用org.springframework.boot.devtools.RemoteSpringApplication，作为main class。同时将http://localhost:8080/作为启动参数传递过去 

此时连接上以后，一个好处就是，如果在本地写代码，会直接将更新后的代码文件传输到远程机器上然后自动进行重启 

这个功能其实怎么说呢，一般是不建议使用的，因为较为鸡肋 

三、SpringApplication高阶功能介绍 

15、SpringApplication介绍 

通常我们开发spring boot应用程序，非常重要的一个地方，就是在Application类的main方法中，使用SpringApplication类来启动应用程序 

```
package com.zhss.springboot;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Import;
import com.zhss.springboot.config.DruidDBConfig;
@SpringBootApplication
@Import(DruidDBConfig.class)  
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args); 
    }
    
} 
```

16、启动失败的处理 

如果启动失败了，那么失败的异常会交给spring boot预先注册好的某个FailureAnalyzer来处理，这个FailureAnalyzer就会打印出完整的失败原因以及解决的办法，比如说，如果启动要使用的8080端口被占用了，会显示下面的内容： 

```
***************************
APPLICATION FAILED TO START
***************************
Description:
Embedded servlet container failed to start. Port 8080 was already in use.
Action:
Identify and stop the process that's listening on port 8080 or configure this application to listen on another port. 
```

spring boot内置了多个FailureAnalyzer，分别用于处理不同的启动失败问题 

此外，我们还可以在启动应用程序的时候，打开debug开关，这样，即使没有一个FailureAnalyzer可以处理启动失败，也会打印出完整的auto configuration信息，供我们参考，比如下面这样 

```
$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug 
```

17、传递应用启动参数 

如果要在系统中其他组件处要获取传递给应用的启动参数，可以用下面的方式来实现。给组件注入一个ApplicationArguments bean，在里面可以获取到所有的参数 

```
import org.springframework.boot.*
import org.springframework.beans.factory.annotation.*
import org.springframework.stereotype.*
@Component
public class MyBean {
    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List<String> files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }
} 
```

18、ApplicationRunner / CommandLineRunner 

如果要在SpringApplication.run()开始运行，但是完成应用启动之前，同时并行运行某些代码，比如一些系统初始化的工作，那么可以用ApplicationRunner / CommandLineRunner，两者唯一的区别，就是ApplicationRunner会传递进来ApplicationArguments，CommandLineRunner会传递进来数组 

```
import org.springframework.boot.*
import org.springframework.stereotype.*
@Component
public class MyBean implements CommandLineRunner {
    public void run(String... args) {
        // Do something...
    }
}
```

### 22_Spring Boot基础系列：4大核心开发框架的整合案例实战

相对比较完整的案例，这个案例一旦做完了，其实你基本就掌握了spring boot在web系统中的常见的开发功能了，很多系统直接就可以用了 

大家做过很多业务系统的话，其实一些开发框架的整合以及使用，是最最基础的，是一个初级工程师的必备能力\ 

spring boot + spring mvc + spring + mybatis：4个框架如何整合起来的 

1、Spring Boot + Spring Core 

Spring Boot默认原生就是支持Spring Core的，只要在main类上加了@ComponantScan，就会自动去扫描各种spring bean，同时基于@Autowired可以完成自动装配 

2、Spring Boot + Spring MVC + Spring Core 

如果要在Spring Boot中使用Spring MVC，就意味着你肯定是要开发web应用了，那么就在pom.xml中声明对spring-boot-starter-web的依赖，可以让spring boot自动配置好内置tomcat容器，同时支持spring mvc接收http请求 

接着可以在包目录中创建你的Controller，对Controller而言，一般会使用@RestController注解，因为现在大多数都是前后端彻底分离的架构，很少再有Controller接收请求之后再去渲染视图的了，只要提供RESTful接口即可 

Controller可以基于@Autowired来装配后面的@Service业务逻辑组件 

3、Spring Boot + Spring MVC + Spring Core + MyBatis 

对于常规的j2ee应用来说，一般都是轻量级的Spring MVC + Spring Core + MyBatis框架架构来进行开发，Spring MVC负责MVC层，Spring Core负责业务逻辑层，MyBatis负责ORM层，那么就需要将MyBatis整合到Spring Boot中来使用 

网上有各种乱七八糟的spring boot和mybatis整合的文章，但是都不太标准和靠谱，标准的整合方式，就是基于mybatis提供的mybatis-spring-boot-starter，基于近乎0配置的方式，完成spring boot和mybatis的整合 

spring boot 1.5以上的版本，对应的是mybatis-spring-boot-starter的1.3版本 

mybatis-spring-boot-starter的工作原理如下 

（1）自动发现一个注册好的DataSource：applicationContext.xml手动配置，不用了 -> @Configuration作用替代掉以前的xml配置文件

（2）自动创建一个SqlSessionFactory，并且将DataSource传入SqlSessionFactory中

（3）自动基于SqlSessionFactory创建一个SqlSessionTemplate

（4）扫描所有的Mapper，将SqlSessionTemplate注入其中，然后将Mapper注册到Spring容器上下文中 

4、Spring Boot + Spring MVC + Spring Core + MyBatis + Druid整合案例 

4.1 在pom.xml中引入需要的依赖 

```
<!-- 引入mybatis-spring-boot-starter依赖，用于mybatis与spring boot整合 -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.3.1</version>
</dependency>
<!-- 引入mysql驱动依赖 -->
<dependency>  
    <groupId>mysql</groupId>  
    <artifactId>mysql-connector-java</artifactId>  
    <scope>runtime</scope>  
</dependency>
<!-- 引入spring-boot-starter-data-jpa依赖 -->
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-jpa</artifactId>  
</dependency>
<!-- 引入阿里的druid连接池依赖 -->
<dependency>  
    <groupId>com.alibaba</groupId>  
    <artifactId>druid</artifactId>  
    <version>1.1.6</version>  
</dependency> 
```

4.2 在application.properties配置文件中配置druid连接池 

```
# 驱动配置信息
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource  
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/oa?useUnicode=true&characterEncoding=utf-8  
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driverClassName=com.mysql.jdbc.Driver
   
# 连接池的配置信息  
# 连接池初始大小
spring.datasource.initialSize=5  
# 连接池最小空闲连接数量
spring.datasource.minIdle=5  
# 连接池最大活跃连接数量
spring.datasource.maxActive=20  
spring.datasource.maxWait=60000  
spring.datasource.timeBetweenEvictionRunsMillis=60000  
spring.datasource.minEvictableIdleTimeMillis=300000  
spring.datasource.validationQuery=SELECT 1 FROM DUAL  
spring.datasource.testWhileIdle=true  
spring.datasource.testOnBorrow=false  
spring.datasource.testOnReturn=false  
spring.datasource.poolPreparedStatements=true  
spring.datasource.maxPoolPreparedStatementPerConnectionSize=20  
spring.datasource.filters=stat,wall,log4j  
spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000  
```

4.3 编写Druid连接池配置管理类 

```
// 使用@Configuration标注，表示这是一个配置管理类
@Configuration  
public class DruidDBConfig {  
   
    // 因为spring boot是默认开启了资源过滤的
    // 所以这里的配置，都会自动从application.properties配置文件中加载出来，设置到这个@Configuration类中
    @Value("${spring.datasource.url}")  
    private String dbUrl;  
    @Value("${spring.datasource.username}")  
    private String username;  
    @Value("${spring.datasource.password}")  
    private String password;  
    @Value("${spring.datasource.driverClassName}")  
    private String driverClassName;  
    @Value("${spring.datasource.initialSize}")  
    private int initialSize;  
    @Value("${spring.datasource.minIdle}")  
    private int minIdle;  
    @Value("${spring.datasource.maxActive}")  
    private int maxActive;  
    @Value("${spring.datasource.maxWait}")  
    private int maxWait;  
    @Value("${spring.datasource.timeBetweenEvictionRunsMillis}")  
    private int timeBetweenEvictionRunsMillis;  
    @Value("${spring.datasource.minEvictableIdleTimeMillis}")  
    private int minEvictableIdleTimeMillis;  
    @Value("${spring.datasource.validationQuery}")  
    private String validationQuery;  
    @Value("${spring.datasource.testWhileIdle}")  
    private boolean testWhileIdle;  
    @Value("${spring.datasource.testOnBorrow}")  
    private boolean testOnBorrow;  
    @Value("${spring.datasource.testOnReturn}")  
    private boolean testOnReturn;  
    @Value("${spring.datasource.poolPreparedStatements}")  
    private boolean poolPreparedStatements;  
    @Value("${spring.datasource.maxPoolPreparedStatementPerConnectionSize}")  
    private int maxPoolPreparedStatementPerConnectionSize;  
    @Value("${spring.datasource.filters}")  
    private String filters;  
    @Value("{spring.datasource.connectionProperties}")  
    private String connectionProperties;  
      
    // 在这个配置类中，直接基于配置信息，创建出了一个bean
    // 这个bean就是一个DataSource
    // 这个DataSource bean就会被纳入spring容器的管理范围之内
    @Bean     
    @Primary  
    public DataSource dataSource(){  
        // 这里就是用外部加载进来的配置信息，创建出来一个Druid连接池
        DruidDataSource datasource = new DruidDataSource();  
          
        datasource.setUrl(this.dbUrl);  
        datasource.setUsername(username);  
        datasource.setPassword(password);  
        datasource.setDriverClassName(driverClassName);  
          
        //configuration  
        datasource.setInitialSize(initialSize);  
        datasource.setMinIdle(minIdle);  
        datasource.setMaxActive(maxActive);  
        datasource.setMaxWait(maxWait);          
        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);  
        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);  
        datasource.setValidationQuery(validationQuery);  
        datasource.setTestWhileIdle(testWhileIdle);  
        datasource.setTestOnBorrow(testOnBorrow);  
        datasource.setTestOnReturn(testOnReturn);  
        datasource.setPoolPreparedStatements(poolPreparedStatements);  
        datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);  
        try {  
            datasource.setFilters(filters);  
        } catch (SQLException e) {  
            e.printStackTrace();
        }  
        datasource.setConnectionProperties(connectionProperties);  
          
        return datasource;  
    }
    
} 
```

编写这个类之后，还需要在Application类中导入这个配置管理类 

```
@SpringBootApplication
// 使用@Import就可以将其他的配置管理类导入进来
@Import(DruidDBConfig.class)  
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args); 
    }
    
} 
```

4.4 编写Domain类 

在com.zhss.springboot.domain包下，创建一个Employee类，作为用于测试的领域模型 

```
public class User {
    
    private Long id;
    private String name;
    private Integer age;
    
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    
} 
```

4.5 编写Mapper类

```
@Mapper
public interface UserMapper {
    @Select("SELECT * FROM user")
    List<User> listUsers();
    
    @Select("SELECT * FROM user WHERE user_id = #{userId}")
    User getUserById(@Param("userId") Long userId);
    
    @Insert("INSERT INTO user(name, age) VALUES(#{name}, #{age})")
    void saveUser(User user);
    
    @Update("UPDATE user SET name=#{name}, age=#{age} WHERE user_id=#{userId}")
    void updateUser(User user);
    
    @Delete("DELETE FROM user WHERE user_id=#{userId}")
    void removeUser(@Param("userId") Long userId);
    
} 
```

```
public interface UserDAO {
    List<User> listUsers();
    
    User getUserById(Long userId);
    void saveUser(User user);
    
    void updateUser(User user);
    
    void removeUser(Long userId);
    
} 
```

```
@Repository
public class UserDAOImpl implements UserDao {
    @Autowired
    private UserMapper userMapper;
    
    public List<User> listUsers() {
        return userMapper.listUsers();
    }
    
    public User getUserById(Long userId) {
        return userMapper.getUserById();
    }
    public void saveUser(User user) {
        userMapper.saveUser(user);
    }
    
    public void updateUser(User user) {
        userMapper.updateUser(user);
    }
    
    public void removeUser(Long userId) {
        userMapper.removeUser(userId);
    }
    
} 
```

4.6 编写Service类 

在com.zhss.springboot.service包下，创建一个EmployeeService接口

在com.zhss.springboot.service.impl包下，创建一个EmployeeServiceImpl实现类 

```
public interface UserService {
    List<User> listUsers();
    
    User getUserById(Long userId);
    void saveUser(User user);
    
    void updateUser(User user);
    
    void removeUser(Long userId);
    
}
```

```
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDAO userDAO;
    
    public List<User> listUsers() {
        return userDAO.listUsers();
    }
    
    public User getUserById(Long userId) {
        return userDAO.getUserById();
    }
    public void saveUser(User user) {
        userDAO.saveUser(user);
    }
    
    public void updateUser(User user) {
        userDAO.updateUser(user);
    }
    
    public void removeUser(Long userId) {
        userDAO.removeUser(userId);
    }
    
} 
```

4.7 编写controller类 

```
@RestController 
// 这里直接在类级别给一个/user的映射，就是代表用户管理的请求都会到这里来
@RequestMapping(value="/user")     
public class UserController { 
 
    @Autowired
    private UserService userService;
 
    // GET请求代表着是查询数据
    @RequestMapping(value="/", method=RequestMethod.GET) 
    public List<User> listUsers() { 
        return userService.listUsers();
    } 
     
    // GET请求+{id}代表的是查询某个用户
    @RequestMapping(value="/{userId}", method=RequestMethod.GET) 
    public User getUser(@PathVariable("userId") Long userId) { 
        return userService.getUserById(userId);
    } 
    
    // POST请求代表着是新增数据
    @RequestMapping(value="/", method=RequestMethod.POST) 
    public String saveUser(User user) { 
        userService.saveUser(user); 
        return "success"; 
    } 
     
    // PUT请求代表的是更新
    @RequestMapping(value="/{userId}", method=RequestMethod.PUT) 
    public String updateUser(@PathVariable("userId") Long userId, User user) {
        user.setUserId(userId);
        userService.updateUser(user);
        return "success"; 
    } 
     
    // DELETE请求代表的是删除
    @RequestMapping(value="/{userId}", method=RequestMethod.DELETE) 
    public String deleteUser(@PathVariable("userId") Long userId) { 
        userService.removeUser(user);
        return "success"; 
    } 
 
} 
```

4.8 启动程序，然后浏览器访问：http://localhost:8080/employee/1 

此时会在浏览器中看到，将id=1的员工信息查询了出来，显示到了浏览器中 

curl命令的使用，通过curl命令，可以替代浏览器去进行RESTful接口的一个测试，git命令行里面，就可以直接使用curl命令 

```
curl -XPOST URL -d "param1=value1&param2=value2"
curl -XGET URL
curl -XDELETE URL
curl -XPUT URL
curl -XPUT URL -H 'Content-Type:application/json' -d'
{
    "param1":"value1",
    "param2":"value2"
}
' 
```

介绍一下，我平时常用的吧，chrome postman插件，chrome浏览器，postman插件 

其实在spring boot做restful接口的时候，PUT请求和DELETE请求是有问题的，因为spring mvc对RESTful接口的支持会有一点问题 

所以在做开发的时候，一般对于PUT，POST，请求，他们的请求参数，都不是用表单直接提交的，一般要求是用ajax走content-type是application/json的类型，通过json类型发送请求参数过来

 

![IMG_256](file:///C:/Users/zy199005/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg) 

4.9 梳理一下此时的几个框架整合的思路 

（1）系统启动的时候，首先会去扫描DruidDBConfig类，这就可以将外部的druid连接池配置加载进来，同时初始化出来一个druid连接池的DataSource bean 

（2）mybatis-spring-boot-starter接着开始干活儿，发现了一个DataSource bean，就会将其注入SqlSessionFactory，再创建SqlSessionTemplate，接着扫描Mapper接口，将SqlSessionTemplate注入每个Mapper，然后将Mapper放入spring容器中来管理 

（3）spring boot的@ComponantScan注解开始干活儿，自动扫描所有的bean，依次初始化实例以及注入依赖，EmployeeServiceImpl（将EmployeeMapper注入其中），EmployeeCongtroller（将EmployeeServiceImpl注入其中） 

（4）此时浏览器发送请求，会先由controlller处理，接着调用service，再调用mapper。mapper底层会基于druid连接池访问到数据库，进行数据操作 

至此，最常规的几个框架整合和使用，就完成了 

5、mybatis-spring-boot-starter的高级使用 

5.1 如果要实现mybatis的完整功能 

mybatis的各种高阶功能，原来都是在xml mapper文件中完成的，但是现在都是倾向于无xml化，全部基于java类和注解来完成 

那么就直接在mapper接口中，基于mybatis的注解来实现mybatis的所有功能即可 

5.2 如果要对mybatis进行配置 

mybatis之前都是有一个mybatis-config.xml之类的文件，可以在里面对mybatis本身进行配置的，比如二级缓存之类的，但是在这里，都是在spring boot的application.properties文件中进行配置了。具体要设置什么参数，可以关注一下mybatis的参数配置信息 

```
mybatis.type-aliases-package=com.example.domain.model
mybatis.type-handlers-package=com.example.typehandler
mybatis.configuration.map-underscore-to-camel-case=true
mybatis.configuration.default-fetch-size=100
mybatis.configuration.default-statement-timeout=30 
```

6、目前为止发现的spring boot几大特点总结 

（1）对常用的依赖进行统一的版本约束，让各依赖的版本都可以兼容，通过spring-boot-starter-parent中的dependencyManagement实现 

（2）简化配置，内置web容器、Auto Configuration、内置打包插件，都是让你写了代码就能立即运行起来 

比如mybatis-spring-boot-starter，直接自己按照约定，找到一个数据源就可以完成实现所有的事情，不需要再进行繁琐的xml配置 

比如spring-boot-starter-web，也是按照约定，直接完成默认的web程序相关的配置，比如内置web容器的接口、spring mvc的配置，等等 

最后发现，整合常用的框架，除了在外部文件里，配置了Druid数据库连接池的一些东西，其他框架几乎没有配置，全部都是基于默认的约定完成 

内置的打包插件可以让我们不用做任何配置，直接就完成一个fat jar的打包，可以执行的jar包了就是 

然后内置的web容器，直接java -jar就可以启动web容器，并且运行web程序，接着就可以本地调试和测试了 

（3）一句话，spring boot，核心目的就是要简化我们的系统开发 

简化再简化，开发非常简单，尽量不要配置，基于约定，记住，这是核心思想 

同时为了简化系统开发整个流程中的方方面面，后面spring boot还提供了其他很多的东西，到后面我们会再讲解

### 23_Spring Boot基础系列：Spring Boot开发常用内容梳理与练习

一、web mvc开发的基础知识 

1、spring-boot-starter-web介绍 

spring boot崇尚的就是尽可能减少手动配置，尽量基于约定规则来完成所有的配置，同时尽量基于注解来完成配置。只要在依赖中引入spring-boot-starter-web，其实spring boot就会基于自己的Auto Configuration功能，完成web服务器和spring mvc的自动配置，然后我们上手就可以开发web程序，直接运行main类就可以启动内置的web服务器了。这能让我们快速启动web程序的开发、调试和验证。 

2、Spring MVC介绍 

spring mvc是一个mvc层的框架，可以接受http请求，将请求转发路由到对应的类方法中来处理，接着将响应映射到视图文件，或者直接返回给浏览器，常见的spring mvc的controller如下所示： 

```
@RestController
@RequestMapping(value="/users")
public class MyRestController {
    @RequestMapping(value="/{user}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long user) {
        // ...
    }
    @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
    List<Customer> getUserCustomers(@PathVariable Long user) {
        // ...
    }
    @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
    public User deleteUser(@PathVariable Long user) {
        // ...
    }
} 
```

3、spring boot为spring mvc做的auto configuration 

（1）自动注册了ContentNegotiatingViewResolver和BeanNameViewResolver两个bean

（2）支持处理静态资源

（3）自动注册了Converter、GenericConverter、Formatter几个bean

（4）支持HttpMessageConverters

（5）自动注册了MessageCodesResolver

（6）静态index.html支持

（7）自定义Favicon图标支持

（8）自动使用了ConfigurableWebBindingInitializer bean 

上面这一大坨是什么东东？其实我们都不用多管，因为很多东西很少会用到，只要知道这个auto configuration，会自动给我们完成一些spring mvc的配置，不需要我们手动去搞一个mvc-servlet.xml配置 

但是接下来我们也会挑选一些东西重点讲一下，spring boot为spring mvc的方便使用，做了哪些事情 

4、RESTful风格的接口 

（1）在接口中增加api字样表明这是一个api接口、 

http://localhost:8080/api 

（2）需要在接口中增加版本标识 

http://localhost:8080/api/v1.0 

（3）按照一定风格写清楚标识的资源 

http://localhost:8080/api/v1.0/system/employee 

这里表示的就是系统管理模块中的员工管理 

（4）RESTful中的HTTP method 

POST：代表的是新增

PUT：代表的是修改

GET：代表的是查询

PATCH：代表的是更新部分属性

DELETE：代表的是删除

HEAD：获取头信息，要查找的信息在响应头中

OPTIONS：获取URI支持的方法，在响应头中会有Allow，包含了支持的方法 

新增员工：POST http://localhost:8080/api/v1.0/system/employee

修改员工：PUT http://localhost:8080/api/v1.0/system/employee/1

查询员工：GET http://localhost:8080/api/v1.0/system/employee/1

查询所有员工：GET http://localhost:8080/api/v1.0/system/employee

删除员工：DELETE http://localhost:8080/api/v1.0/system/employee/1 

（5）RESTful中的HTTP status 

200，成功

400，错误的请求，比如请求参数匹配错误

404，没找到这个资源

405，使用的HTTP method不被允许

500，服务器内部错误 

5、spring boot支持RESTful接口 

只要依赖了spring-boot-starter-web，就自动支持RESTful接口 

RESTful接口的开发 

```
// 支持RESTful接口的controller直接用@RestController即可
// 现在都是前后端彻底分离了，因此后端一般就是使用RestController就足够了
// 我们就对外暴露接口
@RestController
// 这里就是表明了是/api接口，版本是/v1，/employee表明这是员工管理模块
@RequestMapping("/api/v1/employee")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    // 这里用了@GetMapping，就代表只能接受GET请求
    // {employeeId}表明用通配符匹配传递过来的员工ID
    @GetMapping("/{employeeId}")
    public Employee findById(@PathVariable("employeeId") Long employeeId) {
        return employeeService.findById(employeeId);
    }
    
    // 这里用了@PostMapping，表明仅仅接受POST请求
    @PostMapping
    public Long add(Employee employee) {
        return employeeService.add(employee);
    }
    
    // 这里用了@DeleteMapping，表明仅仅接受DELETE请求
    @DeleteMapping("/{employeeId}")
    public Boolean delete(@VariablePath("employeeId") Long employeeId) {
        return employeeService.delete(employeeId);
    }
    
} 
```

测试的时候，使用curl命令： 

```
curl -XGET 'http://localhost:8080/api/v1/employee/1'
curl -XPOST 'http://localhost:8080/api/v1/employee' -H 'Content-Type:application/json' -d'
{
    "name": "张三",
    "age": 30
}
'
curl -XDELETE 'http://localhost:8080/api/v1/employee/1' 
```

chrome的postman，如果要传递参数的话，通常建议都是前端走ajax调用，用json格式+Content-Type=application/json，来传递对应的一些参数

通过Json格式来走输入和输出，是业界的通用的规范，包括我们系统开发也都是走json的。那就是用类似于dubbu走rpc调用。 

6、系统中调用RESTful接口 

spring boot提供了一个RestTemplate来辅助发起REST请求，底层通过HttpURLConnection来发送HTTP小覅西，使用Jackson来进行JSON序列化 

这个我就给大家提一句，不想带着大家来做了，因为在实际的开发过程中，一般不会用这个东西。后面要去讲解spring cloud微服务架构，spring cloud已经把这个事情给干了。如果你是一套走微服务的架构，http来走restful接口，那就直接用spring cloud就可以了。 

唯一的可能，就是别人开发了一个提供http接口的一个应用，需要你的系统去对他进行调用。那么可能需要使用到这个RestTemplate。我带着大家简单的来做一个例子，如果大家后面真的遇到了这样的这个情况，我觉得太简单了，网上查一查用法，留给你们的作业。 

```
@Controller
@RequestMapping("/test")
public class TestController {
    
    @Autowired
    RestTemplateBuilder restTemplateBuilder;
    
    @GetMapping("/user/{id}")
    public User testGetUserById(@PathVariable("id") Long id) {
        RestTemplate client = restTemplateBuilder.build();
        String uri = "http://localhost:8080/api/v1.0/user/{id}";  
        return client.getForObject(uri, User.class, id);
    }
    
} 
```

RestTemplate还有其他的一些用法 

```
// 传递参数
client.getForObject(uri, Order.class, map);
// 获取HTTP头信息
ResponseEntity<Order> responseEntity = client.getForEntity(uri, Order.class, orderId);
Order order = responseEntity.getBody();
HttpHeaders headers = responseEntity.getHeaders();
// 发送post请求
client.postForObject(uri, order, String.class);
// 查询一组订单
Integer offset = 1;
HttpEntity body = null;
ParameterizedTypeReference<List<Order>> typeRef = new ParameterizedTypeReference<List<Order>>(){};
ResponseEntity<List<Order>> rs = client.exchange(uri, HttpMethod.GET, body, typeRef, offset);
List<Order> orders = rs.getBody(); 
```

7、@RestController注解 

RESTful风格的Controller中，直接用这个注解即可，对每个方法的返回值默认采用@ResponseBody的方式来处理 

不会去找某个视图资源文件来渲染后发回浏览器，因为@RestController就代表了这是一个负责提供RESTful接口的Controller 

8、@RequestMapping注解 

（1）一般在Controller类级别加一个@RequestMapping注解，代表对一类资源的映射

（2）在Controller中每个方法级别加一个@RequestMapping，支持某一类请求 

9、@PathVariable注解 

```
// 这个功能在RESTful接口设计中很常见
// 就是在请求中附带一个id或者别的什么参数，代表了对一个资源的标识和定位
// 然后在方法入参中使用@PathVariable注解配置请求中参数和方法入参的映射关系
@RequestMapping(value = "/{userId}", method = HttpMethod.GET)
public User getUserById(@PathVariable("userId") Long userId) {
} 
```

10、@XMapping系列注解 

如果是做REStful风格的Controller，其实一般就更加简化，使用@GetMapping，@PutMapping，@PostMapping，@DeleteMapping。来代表了增删改查等一些操作和请求即可。 

```
@GetMapping("/{userId}")
public User getUserById(@PathVariable("userId") Long userId) {
}
@PostMapping("/")
public String saveUser(User user) {
}
@PutMapping("/{userId}")
public String updateUser(@PathVariable("userId") Long userId, 
    @ModelAttribute User user) {
    
}
@DeleteMapping("/{userId}")
public String removeUser(@PathVariable("userId") Long userId) {
    
} 
```

11、ModelAndView 

这个其实一般用于传统的MVC模式中，就是Controller接收请求，调用Service获取结果后，再将结果封装到ModelAndView中去，同时在里面指明请求要转发到哪个视图资源文件上去。接着JSP、FreeMarker、Thymeleaf等模板引擎技术，可以从ModelAndView中提取之前封装进去的数据，然后将数据渲染到网页上去 

但是在现在的大趋势下，这种技术已经很少使用了，除非是一些一个人开发的极其极其小的小项目，才会用MVC模式，否则正经公司里的生产级项目，全部都是彻底的前后端分离了，我们是不care网页模板的，仅仅提供后端RESTful或者rpc风格的接口，提供数据即可 

```
@GetMapping("/{userId}")
public ModelAndView getUserById(@PathVariable("userId") Long userId, ModelAndView mav) {
    User user = userSerivce.getUserById(userId);
    mav.addObject("user", user);
    mav.setViewName("/userInfo.jsp");
    return mav;
} 
```

12、将请求参数映射到方法入参 

使用@RequestParam可以将某个请求参数，映射到方法入参上 

```
// 假设浏览器发送过来了一个user_status=1的请求参数
// 可以将其映射到方法入参userStatus上去
@GetMapping("/{userId}")
public User getUserById(@PathVariable("userId") Long userId, 
                        @RequestParam("user_status") Integer userStatus) {
    
} 
```

13、@ResponseBody 

就是将方法的返回值直接用json等格式返回到浏览器，一般我们现在都直接用@RestController了，自带这个功能 

二、web开发中对请求参数的校验 

14、Spring Boot对请求校验的支持 

Spring Boot支持JSR-303验证框架，默认实现是Hibernate Validator，只要在Java Bean上放一些校验注解，就可以实现校验支持 

常用的校验注解包括下面这些： 

（1）空检查：@Null，@NotNull，@NotBlank，@NotEmpty

（2）长度检查：@Size(min=20, max=50)，@Length

（3）数值检查：@Min，@Max，@Range(min=1, max=99)

（4）其他检查：@Email，@Pattern 

而且这个校验是支持group的概念的，对于不同的group生效的校验不一样。这个很有用，因为对于增删改查等不同的操作，需要执行的校验本来就是不一样的 

15、基本的校验案例 

```
public class User {
    
    public interface Update{}
    public interface Add{}
    
    // 这就是一个典型的group分组
    // 更新操作的时候，要求userId必须不为空
    // 新增操作的时候，要求userId必须为空
    @NotNull(groups = {Update.class})
    @Null(groups = {Add.class})
    private Long userId;
    @Size(min=3, max=20)
    private String name;
    @Range(min=1, max=120)
    private Integer age;
    
} 
```

```
// 这里就声明了要激活Add group对应的校验注解
// 那么就会校验user的userId不能为空
@PostMapping("/")
public String saveUser(@Validated({User.Add.class}) User user, 
                      BindingResult result) {
    if(result.hasErrors()) {
        List<ObjectError> errors = result.getAllErrors();
        FieldError error = (FieldError)errors.get(0);
        System.out.println(error.getObjectName() + "," 
                           + error.getField() + "," 
                           + error.getDefaultMessage());
        return "error";
    }
    return "success";
} 
```

16、自定义校验注解 

```
public class AgeValidator implements ConstraintValidator<Age, Integer> {
    private Age age;
    private Integer max;
    
    public void initialize(Age age) {
        this.age = age;
        this.max = age.max();
    }
    
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        return value < max;
    }
    
} 
```

```
@Constraint(validatedBy = {AgeValidator.class})
@Documented
@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicty.RUNTIME)
public @interface Age {
    
    String message() default "年龄是非法的，不能超过{max}岁";
    int max() default 100;
    Class<?>[] groups default {};
    Class<? extends Payload>[] payload() default {};
    
} 
```

三、spring boot+mvc中常用的一些全局配置 

17、WebMvcConfigurer 

```
@Configuration
public class MvcConfigurer implements WebMvcConfigurer {
    
    // 拦截器
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new UserLoginInterceptor()).addPathPatterns("/user/**");
    }
    
    // 跨域访问配置
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/user/**")
            .allowedOrigins("http://www.zhss.com")
            .allowedMethods("POST", "GET")
    }
    
    // 格式化
    public void addFormatters(FormatterRegistry registry) {
        registry.addFormatter(new DateFormatter("yyyy-MM-dd HH:mm:ss"));
    }
    
    // URI到视图的映射
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/addUserUI").setViewName("/addUser.jsp");
    }
    
} 
```

```
public class UserLoginInterceptor implements HandlerInterceptor {
    
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, Object handler) 
                             throws Exception {
        
    }
    
    public void postHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler, 
                           ModelAndView moodelAndView)
                           throws Exception {
    
    }
    
    public void afterCompletion(HttpServletRequest request, 
                                HttpServletResponse response, 
                                Object handler, 
                                Exception ex)
                                throws Exception {
    
    }
    
} 
```

18、spring监听器的使用 

```
public class MyApplicationStartedEventListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
    }
    
} 
```

```
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class); 
        app.addListeners(new MyApplicationStartedEventListener());
        app.run(args);
    }
} 
```

19、全局异常处理 

Controller中抛出的异常全部交给/error来处理，Spring Boot是有一个默认实现的，但是也可以我们自己覆盖掉 

```
@ControllerAdvice
class GlobalErrorHandler {
    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public ErrorInfo<String> defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
        ErrorInfo<String> r = new ErrorInfo<String>();  
        r.setMessage(e.getMessage());
        r.setCode(ErrorInfo.ERROR);
        r.setData("自定义的全局异常处理");
        r.setUrl(req.getRequestURL().toString());
        return r;
    }
}
public class ErrorInfo<T> {
    public static final Integer OK = 0;
    public static final Integer ERROR = 100;
    private Integer code;
    private String message;
    private String url;
    private T data;
    
    public Integer getCode() {
        return code;
    }
    public void setCode(Integer code) {
        this.code = code;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    public String getUrl() {
        return url;
    }
    public void setUrl(String url) {
        this.url = url;
    }
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }
    
} 
```

四、spring boot跟其他技术整合的一些要点 

20、spring boot与模板的整合 

spring boot的静态资源支持规范如下所示： 

（1）/static：静态资源，js，css，图片之类的。这里放一张图片，然后访问http://localhost:8080/a.jpg，就会自动去/static下面找图片

（2）/templates：放置模板文件，支持thymeleaf，freemarker，jsp，velocity等。但是spring boot不建议使用jsp，同时velocity很多年不更新了。因此现在主流建议是thymeleaf或者是freemarker 

当然，这个就不多说了，因为如果你做了一个项目，是前后端耦合在一起的，那赶紧走，因为真的就太low了，这种一定是小项目，而且绝对不是未来的趋势 

加入依赖 

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency> 
```

编写controller 

```
@Controller
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/{userId}")
    public String getUserById(@PathVariable("userId") Long userId, ModelAndView modelAndView) {
        User user = userService.getUserById(userId);
        modelAndView.addObject("user", user);
        modelAndView.setViewName("userInfo.html");
        return modelAndView;
    }
    
} 
```

编写thymeleaf模板页面 

```
<!DOCTYPE html>
<html>
    <head lang="en">
    <meta charset="UTF-8" />
    <title>用户信息页面</title>
</head>
<body>
    用户ID：<p th:text="${user.userId}" ></p>
    用户名：<p th:text="${user.username}" ></p>
    用户年龄：<p th:text="${user.age}" ></p>
</body>
</html> 
```

21、spring boot与mybatis的整合要点 

```
@Insert("INSERT INTO user(name, age) VALUES(#{name}, #{age})")
@Options(useGeneratedKeys = true, keyProperty = "user.userId")
void saveUser(User user);
@Update("UPDATE user SET name=#{name}, age=#{age} WHERE user_id=#{userId}")
void updateUser(User user);
@Delete("DELETE FROM user WHERE user_id=#{userId}")
void removeUser(@Param("userId") Long userId);
@Select("SELECT FROM user WHERE user_id=#{userId}")
@Results({
    @Result(property = "userId", column = "user_id", id = true),
    @Result(property = "name", column = "name"),
    @Result(property = "age", column = "age")
})
User getUserById(@Param("userId") Long userId); 
```

22、spring boot对事务的支持

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency> 
```

```
@Transactional
public void updateUser(User user) {
} 
```

关于事务，有很多更加高级的东西，包括事务的隔离级别，事务的传播，不在这里深入，而是放在后面的MySQL高阶深入环节，要配合mysql事务的透彻剖析和讲解，再在这里来实践使用即可

### 24_Spring Boot基础系列：为应用系统进行相关的配置

1、Spring Boot的基础配置 

在application.properties中即可完成spring boot的配置 

（1）监听端口配置 

默认的监听端口是8080，但是可以用如下三种方式来修改监听的端口 

在application.properties中：server.port=9090

启动系统的时候：java -jar target\springboot-demo-1.0.0.jar --server.port=9090

启动系统的时候：java -Dserver.port=9090 -jar target\springboot-demo-1.0.0.jar 

1.2 web上下文配置 

默认的web上下文是：/，可以通过属性来修改web上下文 

server.context-path=/springboot-demo 

1.3 使用其他web服务器 

默认的web服务器是用的内嵌的tomcat，可以使用jetty或者是undertow 

比如使用jetty作为web服务器 

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>     
```

但是一般来说，都是用tomcat作为web容器即可，较为重要的配置参数如下 

```
# 打开tomcat访问日志
server.tomcat.accesslog.enabled=true
# 访问日志所在的目录
server.tomcat.accesslog.directory=logs
# 允许HTTP请求缓存到请求队列的最大个数，默认是不限制的
server.tomcat.accept-count=
# 最大连接数，默认是不限制的，如果连接数达到了上限，那么剩下的连接就会保存到请求缓存队列里，也就是上面参数指定的个数
server.tomcat.max-connections=
# 最大工作线程数
server.tomcat.max-threads=
# HTTP POST内容最大长度，默认不限制
server.tomcat.max-http-post-size=
```

2、spring组件加载外部配置文件 

在实际开发中，将核心配置放在外部配置文件，是很重要的。因为通常我们都是对不同的环境使用一套完全不同的配置，但是保证我们的代码必须是相同的。 

比如我们有一个类，其中要从外部配置文件中注入一个name属性 

```
import org.springframework.stereotype.*
import org.springframework.beans.factory.annotation.*
// 无论用什么spring组件都可以被注入外部配置
@Component
public class MyBean {
    // 用@Value注解就可以将外部配置注入到类中来
    // 对配置项的名称用${}形式来表达
    @Value("${name}")
    private String name;
    // ...
} 
```

然后通常，我们会在src/main/resources中，放置一个application.properties，其中可以给name属性一个值。也可以在命令行中传递这个参数值来替代：java -jar app.jar --name="Spring"。 

而且spring boot还提供了一个随机属性值生成器，供我们使用，可以对某个属性是用的随机生成的一个值： 

```
my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]} 
```

当然，也可以用application.yml来替代application.properties，用yaml格式来编写配置文件，但是这两种方式都可以，一般没必要搞的那么复杂，用application.properties也就可以了 

3、spring boot多环境支持 

spring boot支持使用@Profile注解来标志，在哪个环境profile下，可以激活使用某个@Configuration类 

```
@Configuration
@Profile("production")
public class ProductionConfiguration {
    // ...
} 
```

接着可以在启动的时候，命令行中，使用如下参数来指定某个环境profile：--spring.profiles.active=dev,hsqldb 

但是实际上如果基于spring boot的profile支持来做，一般是没法完全满足我们的期望的，所以多环境profile支持，通常还是基于彻底的maven profile来使用，不同的profile直接对应不同的文件夹，然后mvn pakcage打包的时候，指定对应的profile来打包，将对应环境的配置文件，全部放到src/main/resources下面去 

这种方式是最彻底的，而且足够灵活 

4、系统读取应用的配置 

（1）Environment类 

spring boot提供了一个Environment类，可以读取applicaiton.properties、命令行参数、系统参数、操作系统环境变量，等等，各种参数和配置。可以通过spring bean注入的方式获取到这个Environment，很多时候，可能你并不想直接使用@Value将某些参数读取到系统里面来，但是你可以注入一个Environment，从这个里面去获取需要的一些参数 

```
@Configuration
public class EnvironmentConfig {
    @Autowired
    private Environment env;
    
    public int getServerPort() {
        return env.getProperty("server.port", Integer.class);
    }
    
} 
```

（2）@Value 

也可以通过@Value直接将外部的配置参数注入到配置管理类中 

这块可以参考我们之前写的那个DruidDbConfig类，就是基于@Value将外部的druid配置参数注入进来，然后基于配置参数初始化了一个Druid连接池bean 

（3）@ConfigurationProperties 

如果有一组相关联的配置属性，比如说下面这样的： 

```
server.port=9090
server.context-path=/springboot-demo 
```

都是server打头的，那么可以一次性将一组配置属性读取到一个配置管理类中

```
@ConfigurationProperties("server")
@Configuration
public class ServerConfig {
    
    private int port;
    private String contextPath;
    
    // port和contextPath的getter和setter方法
    
} 
```

可以使用这个@ConfigurationProperties来重构dDruidDbConfig类 

5、spring boot的自动装配 

4.1 @Configuration和@Bean 

spring boot的核心思想，就是用@Configuration来标注一个类，从外部配置文件中，基于@Value或者是@ConfigurationProperties来加载各种配置信息进来，然后基于这些配置信息，实例化对应的bean 

比如Druid连接池就是一个经典的例子

### 25_Spring Boot基础系列：基于已有案例实战练习单元测试技术 

我们正好基于之前快速写好的一个所谓“用户管理”的模块，完整的模块，我们来做所有代码组件的一个单元测试 

（1）JUnit

（2）Mockito做测试替身，隔离各个代码组件

（3）Hamcrest去做复杂的断言

（4）spring test等框架去在spring boot、spring等框架的环境下，去进行相关的测试 

1、JUnit的介绍 

JUnit的使用非常容易上手，测试类放在src/main/test下，然后类名一般用Test结尾 

通常来说，一个测试类对应一个系统类，类中的每个方法，用于测试一个方法，方法一般以test开头，每个方法用@Test标注 

如果有测试开始前要执行的操作，用@Before标注一个方法来执行；如果有测试结束之后要执行的操作，用@After标注一个方法来执行，一般会将多个测试方法中的初始化和资源清理代码放在这些方法中 

每次运行一个方法，都会创建一个类的实例，将各个测试方法互相之间隔离开来，避免互相影响，导致测试失败 

在每个测试方法中，最后都会用Assert类来进行断言，判断测试是否通过，就是看一下测试得到的结果，是不是我们期望的，如果不是会报错，表示测试不通过 

JUnit还有一个Suite的概念，一次性运行多个测试用例，算是一个测试套件，比如下面这样子

```
@RunWith(Suite.class)
@SuiteClasses({TestSuite1.class, TestSuite2.class})
public class TestSuitMain {
} 
```

我们一般都是，写好一些代码组件，然后就针对这些代码组件，去立即写对应的单元测试，单元测试是一个类一个类的执行 

到了最后，你都要集成测试，mvn test，将所有的单元测试全部跑一遍 

2、spring-boot-starter-test 

spring boot对单元测试提供了很好的支持，只要依赖spring-boot-starter-test即可，这个依赖会自动导入单元测试需要的所有依赖，包括了JUnit、AssertJ、Hamcrest以及其他的一些包，而且这个spring-boot-starter-test一般是设置为test scope即可 

具体来说，spring-boot-starter-test导入之后，会包含下面这些东西： 

（1）JUnit：最经典的单元测试框架

（2）Spring Test、Spring Boot Test：是spring和spring boot环境下，对测试的一个支持

（3）AssertJ：是用来进行断言的

（4）Hamcrest：是用来进行复杂断言，复杂的表达式

（5）Mockito：测试替身的模拟

（6）JSONassert：都是对json数据进行操作的

（7）JsonPath 

3、测试spring boot应用程序 

3.1 spring boot单元测试脚手架 

```
// @RunWith的意思，是不要使用默认方式进行单元测试，而是使用指定的类来提供单元测试
// 所有的spring测试都是找SpringRunner.class
@RunWith(SpringRunner.class)
// 这个是spring boot提供的，会一直找到一个Application类，只要包含了@SpringBootApplication的就算，然后会先启动这个类，来给单元测试提供环境
@SpringBootTest
public class EmployeeServiceTest {
    
    // 这里就可以从启动的spring上下文中，将EmployeeService注入到这里来，供我们进行测试
    @Autowired
    private EmployeeService employeeService;
    
    @Test
    public void testFindById() {
        
    }
    
} 
```

3.2 测试service组件 

要考虑的地方有3点： 

（1）测试之前自动构造好数据，测试结束之后自动回滚数据构造

（2）将service依赖的service进行模拟打桩进来

（3）可能需要在数据库中构造好数据 

spring boot会默认在单元测试结束之后，进行数据库事务回滚；spring boot会集成mockito框架来模拟依赖service进行打桩；spring boot有一个@Sql注解，可疑在测试开始前执行SQL语句初始化数据 

```
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.*;
@RunWith(SpringRunner.class)
@SpringBootTest
@Transactional
@Rollback(true)
public class EmployeeServiceTest {
    
    @Autowired
    private EmployeeService employeeService;
    
    // 这里是基于Mockito框架模拟出来了一个EmployeeMapper
    // 可能我们到这里为止，只想要测试EmployeeService，而EmployeeService依赖了EmployeeMapper，那么我们就需要自己模拟一个EmployeeMapper出来
    // 这里定义的@MockBean，会模拟生成一个EmployeeMapper，放入spring容器中去，然后被EmployeeService给引用到
    @MockBean
    private EmployeeMapper employeeMapper;
        
    @Test
    public void testService() {
        int employeeId = 1;
        
        Employee employee = new Employee();
        employee.setId(1);
        employee.setName("张三");
        employee.setAge(20);
        
        // 这行代码是对employeeMapper的findById方法进行模拟
        // 无论给这个方法传入什么参数
        // 都会返回一个Employee对象，这个是我们预先定义好的employee对象
        given(this.employeeMapper.findById(anyLong()))
                .willReturn(employee);
        
        Employee resultEmployee = employeeService.findById(employeeId);
        
        assertEquals(employee, resultEmployee);
    }
    
} 
```

3.3 测试Controller 

```
@RunWith(SpringRunner.class)
// 这个代表是Mvc测试，可以传入要测试的Controller类
@WebMvcTest(EmployeeController.class)
public class EmployeeControllerTest {
    
    // 这个是专门用来测试mvc的类，可以模拟发起http请求
    @Autowired
    private MockMvc mvc;
    // 这里是模拟以一个service组件
    @MockBean
    private EmployeeService employeeService;
    
    @Test
    public void testMvc() throws Exception {
        int employeeId = 1;
        
        // 这里是模拟service组件的行为
        Employee employee = new Employee();
        employee.setId(1);
        employee.setName("张三");
        employee.setAge(20);
        
        given(this.employeeService.findById(employeeId)).willReturn(employee);
        
        // 这里是模拟发起一个http请求
        mvc.perform(get("/employee/{id}", employeeId))
                .andExpect(model().attribute("id", 1))
                .andExpect(model().attribute("name", "张三"))
                .andExpect(model().attribute("age", 20));
    }
    
} 
```

3.4 mvc请求模拟 

模拟GET请求：mvc.perform(get("/employee/{id}", 1))

模拟POST请求：mvc.perform(post("/employee/{id}", 1))

模拟文件上传：mvc.perform(multipart("/upload").file("file", "文件内容".getBytes("UTF-8")))

模拟表单请求：mvc.perform(post("/employee").param("name", "张三").param("age", 20))

模拟session：mvc.perform(get("/employee").sessionAttr(name, value))

模拟cookiei：mvc.perform(get("/employee").cookie(new Cookie(name ,value)))

模拟HTTP body内容，比如json：mvc.perform(get("/employee").content(json))

模拟设置HTTP header： 

mvc.perform(get("/employee/{id}"), employeeId)

​    .contentType("application/x-www-form-urlencoded")

​    .accept("application/json")

​    .header(header, value) 

3.5 比较mvc请求返回结果 

mvc.perform(get("/employee"))

​    .andExpect(status().isOk()) // 响应是否为200状态码

​    .andExpect(content().contentType(MediaType.APPLICATION_JSON)) // 返回的content type是不是application/json

​    .andExpect(jsonPath("$.name").value("张三")) // 返回内容本身检查 

mvc.perform(post("/employee"))

​    .andExpect(model().attribute("name", "张三"))

​    .andExpect(model().attributeExists("name")) 

4、Mockito使用 

假设我们有一个接口，需要来模拟这个接口的实现类对象 

```
public interface EmployeeService {
    
    public Employee findById(Long id);
    public boolean add(Employee employee);
    
} 
```

```
import static org.mockito.Mockito.*;
@RunWith(MockitoJUnitRunner.class)
public class EmployeeServiceTest {
    
    @Test
    public void test() {
        // 模拟出来一个实现了EmployeeService接口的对象
        EmployeeService employeeService = mock(EmployeeService.class);
        // 这个对象的findById()方法无论传入什么参数，都是返回预定义的一个对象
        when(employeeService.findById(anyLong())).thenReturn(employee);
        // 尝试调用
        Employee resultEmployee = employeeServicie.findById(1);
        // 比较结果
        assertEquals(employee, resultEmployee);
    }
    
} 
```

一般是不建议在单元测试中使用any类方法的，而是用eq(1)之类的，传入指定的值，而且用了eq()的意义就是，如果传递的不是这个值，就报错 

还可以检查一个接口被调用的次数 

```
when(employeeService.findById(eq(1))).thenReturn(employee);
Employee resultEmployee = employeeService.findById(1);
assertEquals(employee, resultEmployee);
// 这里就是检查employeeService的findById(1)调用是否为2次
verify(employeeService ,times(2)).findById(eq(1));     
```

此外，还可以检查多个接口被调用的顺序 

```
EmployeeService employeeService = mock(EmployeeService.class);
when(employeeService.findById(eq(1))).thenReturn(employee);
when(employeeService.add(eq(employee))).thenResult(true);
boolean addResult = employeeService.add(employee);
Employee resultEmployee = employeeService.findById(1);
// 这里就是在验证，是否按照下面的顺序完成的调用
InOrder inOrder = inOrder(employeeService);
inOrder.verify(employeeService).add(employee);
inOrder.verify(employeeService).findById(1);
```

还可以模拟抛出异常 

```
EmployeeService employeeService = mock(EmployeeService.class);
when(employeeService.findById(lt(0))).thenThrow(new IllegalArgumentException("employeeId不能小于0"))    
Employee reseultEmployee = employeeService.findById(-1);     
```

5、DAO层单元测试 

5.1 @Sql 

可以使用@Sql先构造好需要的数据 

```
@RunWith(SpringRunner.class)
@SpringBootTest
@Transactional
@Rollback(true)
public class EmployeeMapperTest {
    
    @Autowired
    private EmployeeMapper employeeMapper;
    
    @Test
    // 这个@Sql注解，就会在我们执行测试之前，先执行sql语句，初始化数据
    @Sql({"employee.sql"})
    public void testAddEmployee() {
        Employee employee = new Employee();
        employee.setName("李四");
        employee.setAge(30);
        
        Long employeeId = employeeService.add(employee);
        employee.setId(employeeId);
        assertTrue(employeeId > 0);
        
        // 接着需要从数据库中查询数据来比较
        Employee resultEmployee = employeeMapper.findById(1);
        assertEquals(employee, resultEmployee);
    }    
} 
```

6、assertThat和Hamcrest 

单元测试结构

@Before

@Test

@After

·断言

assertEquals

assertTrue / assertFalse

assertNull / assertNotNull

assertSame / assertNotSame

assertArrayEquals

assertThat

测试异常

@Test(expected = NullPointException.class)

主动失败

fail

JUnit + Hamcrest

assertThat(str.indexOf("hello"), is(not(-1)))

assertThat(str.contains("hello"), equals(true))

assertThat(str, containsString("hello"))

is、not

equalTo / sameInstance、nullValue / notNullValue、instanceOf

hasProperty

hasEntry、hasKey、hasValue、hasItem / hasItems、hasItemInArray、in

greaterThan、greaterThanOrEqualTo、lessThan、lessThanOrEqualTo

containsString、endsWith、startsWith

JUnit + Mockito

when().thenReturn()

### 26_Spring Boot基础系列：快速梳理一下日志打印的相关知识

d2、日志的配置 

2.1 日志打印 

默认情况下，spring boot使用apache commons logging作为日志接口，但是使用logback作为日志框架实现，所以打印日志的代码一般是下面这样的： 

```
public class HelloworldController {
    
    private Log log = LogFactory.getLog(HelloworldController.class);
    
} 
```

2.2 日志格式 

打印出来的日志大致是这样的：

```
2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] 
```

日志的格式如下： 

（1）日期和时间

（2）日志级别：ERROR，WARN，INFO，DEBUG，TRACE

（3）进程ID

（4）---，这是个分隔符

（5）线程名称

（6）日志内容 

2.3 日志级别 

默认是INFO以上的日志才会打印，可以在application.properties中配置一下 

```
# 配置打印日志的默认最小级别
logging.level.root=info
# 配置org包下打印日志的最小级别是WARN
# org包下的一般都是第三方的组件，不需要打印info级别的日志
logging.level.org=warn
# 自己包下的日志，从debug级别就开始打印
logging.level.com.zhss=debug 
```

2.4 日志文件 

同时默认仅仅在控制台打印日志，如果要打印日志到文件，需要进行配置 

```
# 这是相对路径，放在应用的目录下
logging.file=my.log
# 当然一般其实是将日志文件放在指定的某个日志目录中的
# 这就会在/var/logs/com.zhss.springboot.demo目录下生成一个spring.log日志文件
logging.path=/var/logs/com.zhss.springboot.demo 
```

当日志达到10MB的时候，就会重新生成一个日志文件，避免单个日志文件过大 

2.5 自定义日志格式 

可以对控制台和文件两个地方的日志分别定义格式

```
logging.pattern.console=%level %date{HH:mm:ss} %logger{20}.%M %L :%m%n
logging.pattern.file=%level %date{ISO8601} [%thread] %logger{2000}.%M %L :%m%n 
```

- %level，日志级别
- %date，日期时间，HH:mm:ss是输出时分秒，ISO8601是标准日期输出，yyyy-MM-dd HH:mm:ss.SSS
- %logger，输出Logger的名字，包名+类名，{n}限制了输出的长度，如果太长的话，会尽可能压缩包名和类名，但是建议一般保持的长一些
- %thread，线程名称
- %M，日志打印的方法名
- %L，打印日志所在的行，性能消耗较大
- %m，日志消息
- %n，换行 

spring boot虽然支持多种日志框架，比如log4j2，java util logging等，但是一般建议就使用默认的logback即可，可以在src/main/resources目录下放一个logback-spring.xml来对logback进行更加细致的配置 

1、日志的格式 

默认情况下，spring boot是用logback来记录日志的 

```
2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] 
```

日志的格式如下： 

（1）日期和时间

（2）日志级别：ERROR，WARN，INFO，DEBUG，TRACE

（3）进程ID

（4）---，这是个分隔符

（5）线程名称

（6）日志内容 

2、控制台日志输出 

默认情况下，日志会输出到控制台，ERROR、WARN、INFO三个级别的日志会输出 

可以在启动应用程序的时候，使用--debug打开调试模式，此时会选择性的输出如web服务器、hibernate、spring boot更多的一些日志，但是不意味着会输出DEBUG级别的日志 

3、日志文件输出 

默认情况下，spring boot是只会将日志输出到控制台的，是不会将日志输出到文件中的。如果我们需要将日志输出到文件中，需要在application.properties文件中，配置一个属性，logging.file 

默认情况下，日志文件每达到10MB的时候，就会更换一个新的文件 

4、日志系统的配置文件 

默认情况下，spring boot会使用logback作为日志框架，但是如果我们在依赖中引入比如log4j、java util loggins，那么spring boot会使用别的日志框架 

logback的配置文件是：logback-spring.xml

log4j的配置文件是：log4j2-spring.xml

java util logging的配置文件是：logging.properties

### 27_Spring Boot基础系列：如何将系统部署到线上服务器 

1、以jar方式来部署 

如果要以jar方式来部署spring boot应用，只需要加入下面的插件即可 

```
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <executable>true</executable>
            </configuration>
        </plugin>
    </plugins>
</build> 
```

接着只要执行：mvn package，即可完成打包，这是一个fatjar包，包含了所有依赖，可以执行的一个jar包 

接着可以将jar包通过scp命令上传到服务器上 

执行jar包启动系统：java -jar target\springboot-demo-1.0.0.jar 

2、以war包方式来部署 

一般来说，实际去部署的时候，都不会是以jar包方式部署的，因为那是用的spring boot内嵌的tomcat服务器来部署的，一般还是以war包方式，部署到线上已有的tomcat容器中的 

此时要做的第一件事情，就是将spring boot应用的pom.xml中的packaging从jar修改为war 

咱们阶段一，先用spring boot内嵌容器去部署的方式，上线，因为一开始假设的是这个系统几乎就没什么用人，所以哪怕是默认的配置，其实支撑少量的请求，都是没什么问题的 

但是到了阶段二，就是已经开始有一定的访问量了，那么那个时候开始，我们就会正经使用tomcat去部署，而且会深入的学习tomcat，内核 

```
<groupId>com.zhss.springboot</groupId>
<artifactId>springboot-demo</artifactId>
<packaging>war</packaging> 
```

接着需要将spring boot内嵌的tomcat修改为provided范围 

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
    <scope>provided</scope>
</dependency> 
```

接着要再次修改Application类 

```
// 这里必须继承SpringBootServletInitializer基类
@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    
    // 这里必须实现一个configure方法
    @Override
    protected SpringAppliciationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }
    
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
    
} 
```

然后再次使用mvn package打包，就是一个war包 

然后将war包放到tomcat的webapps目录中，启动tomcat，即可完成系统的部署 

3、多环境部署 

可以在src/main/resources目录下，放多个application-{profile}.properties文件 

然后在启动的时候，使用java -jar -Dspring.profiles.active=prod target\springboot-demo-1.0.0.jar来指定要激活哪个环境的profile 

在实际的项目中，你永远无法保证说，你多环境下，就是一个properties就可以了，我告诉大家一点，很多大公司里，自己研发的设施，是要求你不同的环境必须放不同的一个文件，让他们去读取的，跟spring boot是不兼容的。META-INF/conf.properties 

我们用的是maven profile，我们在不同profile的路径下，放一个application.properites，以及也许需要放置的其他的一些配置文件，为了以防万一 

也可以在tomcat的catalina.sh中，编辑系统属性来激活对应的profile，比如JAVA_OPTS="-Dspring.profiles.active=prod" 

还可以使用@Profile来标准@Configuration，来决定不同的环境下，可以让不同的类生效 

但是实际项目中，还是建议使用maven的profile支持多环境吧，更加灵活。毕竟，spring boot的多环境支持，仅仅能支持多个application.properties，那如果还有别的配置文件呢？？

### 28_Spring Boot基础系列：对线上部署好的应用系统进行监控 

咱们的这个阶段一，要讲解的Spirng Boot功能的最后一讲，网上一些博客，网上一些书，网上一些视频课程，spring boot，讲了很多的东西，为啥咱们这儿没讲呢？我在spring boot第一讲的时候，站在“上帝视角”剖析过问题了。后面肯定spring boot还有很多东西是要讲的，但是我不打算按照网上那种传统和常规的做法去讲。spring boot跟其他的技术还不太一样，他的重点，不是他自己本身提供什么功能，他的重点，是跟N多种技术整合在一起来使用。 

还有一些非常冷门的东西，JPA+hibernate+spring boot去整合，spring boot+webservice整合，不太想去讲 

我之前花了几个小时给大家讲的那些东西，你作为一个基础性的框架，平时做项目，做开发，做基本的业务的增删改查，都够了 

在pom.xml中引入依赖： 

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency> 
```

此时打包工程，通过java -jar方式启动工程 

访问下面的地址，可以看到应用的健康情况： 

```
http://localhost:8080/springboot-demo/health 
```

```
// 查看系统的基本健康信息：系统是否正常，磁盘空间，数据库
http://localhost:8080/springboot-demo/health
// 查看最近的一些http请求
http://localhost:8080/springboot-demo/trace
// 在线查看日志
http://localhost:8080/springboot-demo/logfile
// 在线查看线程栈信息
http://localhost:8080/springboot-demo/dump
// 在线查看内存快照
http://localhost:8080/springboot-demo/heapdump
// 查看系统的性能指标：内存占用、垃圾回收次数
http://localhost:8080/springboot-demo/metrics
// 查看系统的一些额外信息
http://localhost:8080/springboot-demo/info
// 在线查看日志配置
http://localhost:8080/springboot-demo/loggers
// 查看URL映射
http://localhost:8080/springboot-demo/mappings
// 查看所有的spring bean
http://localhost:8080/springboot-demo/beans
// 查看环境变量
http://localhost:8080/springboot-demo/env
// 查看configpropss环境变量
http://localhost:8080/springboot-demo/configprops
// 查看auto config的一些信息
http://localhost:8080/springboot-demo/autoconfig 
```

自定义监控指标：有些东西，我可以按照网上视频，大而全的方式去讲，浪费时间，意义不大 

简单看看就行了，真正系统上线初期，监控不监控，都无所谓，根本就没什么业务量，而且也不是我们这个阶段的重点 

到了后面业务量上来，非常专业的系统监控的，分布式的系统监控

### 29_大白话讲设计模式之迭代器模式：封装你的集合迭代逻辑 

（1）大白话讲设计模式：先用大白话，纯纯的大白话，非常的接地气，不能有任何一丁点高深莫测的感觉。快速领会各个模式的一个要领，每个模式长什么样子？如果不用这个模式会有什么问题？如果用了这个模式会有什么好处？一般在企业开发中这个模式是怎么用的？ 

（2）在电商系统里，将我们讲解的所有这些设计模式，全部在真实复杂的电商业务中去深入的使用，结合业务来设计这个模式如何运用到业务中，让我们基于设计模式开发出高内聚、低耦合、高度可扩展、维护成本低、逻辑清晰、易读易懂的代码 

（3）如果你未来要将设计模式转换成你自己的本领，在你做项目的时候，可以随心所欲的使用设计模式，必须得依靠咱们的第二点，你只有在一个真实的复杂业务系统中，实践过设计模式的运用，体会到这个东西是怎么玩儿的，这么玩儿以后好处是什么。设计模式才能转化为你自己的东西，然后以后你在自己开发的时候，可以随心所欲的使用设计模式 

（4）如果你出去面试，人家考察你设计模式，此时，如果你干背设计模式的理论、定义、举个例子，这个是肯定不行的，你有没有设计模式运用和实践的功底，是否透彻理解了，是否融会贯通。你要结合你自己做过的复杂业务系统，给人家先讲一讲业务，然后说一下，如果不用模式来设计这个业务的代码实现，可能会导致代码成一坨屎，但是你当时合理的运用了设计模式，将代码设计的结构如何优良，可扩展性如何的好，维护性如何的好。 

（5）设计模式，网上有很多的视频，还有很多的书，大话设计模式。。。但是他们都有一个问题，就是你学习的过程中，哪怕是给你举个例子，说这个模式是怎么怎么用的，但是那都是一些demo级的例子。就我所知，正儿八经的设计模式在纯复杂业务系统的项目中，综合性的设计模式项目实战，我一个都没看到。综合运用设计模式来开发了一个自动代码生成框架，但是那个有一个问题，模式的运用很多地方是生搬硬涛，不自然，业务，但是对于大部分同学来说，平时经历的还是那种有一定复杂度业务的系统。 

iterator模式 

需求：给大家举个例子，现在假设，有一个教室类，里面包含了一堆学生，我现在要遍历教室里的学生，怎么来玩儿 

```
public interface Aggregate {
    
    public abstract Iterator iterator();
    
} 
```

```
public interface Iterator {
    
    public abstract boolean hasNext();
    public abstract Object next();
    
} 
```

```
public class Student {
    
    private String name;
    
    public Book(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
} 
```

```
public class Classroom implements Aggregate {
    
    private Student[] students;
    private int last = 0;
    
    public Classroom(int size) {
        this.students = new Student[size];
    }
    
    public Student getStudent(int index) {
        return students[index];
    }
    
    public void addStudent(Student student) {
        this.students[last] = student;
        last++;
    }
    
    public int getLength() {
        return last;
    }
    
    public Iterator iterator() {
        return new ClassroomIterator(this);
    }
    
} 
```

```
public class ClassroomIterator implements Iterator {
    
    private Classroom classroom;
    private int index;
    
    public ClassroomIterator(Classroom classroom) {
        this.classroom = classroom;
        this.index = 0;
    }
    
    public boolean hasNext() {
        if(index < classroom.getLength()) {
            return true;
        } else {
            return false;
        }
    }
    
    public Object next() {
        Student student = classroom.getStudent(index);
        index++;
        return student;
    }
    
} 
```

面向Iterator接口编程，无论底层的数据结构和迭代算法如何变化，调用者都不用修改代码 

高内聚，低耦合，漂亮 

其实一般很少自己写这个iterator模式的，一般都是在集合编程中使用，尤其是如果要对集合元素遍历过程中做插入删除操作，那就用iterator，这个我们会在本次项目阶段一来实践，体验JDK已经封装好的iterator模式，加深印象，如果要对某个类中的集合进行遍历，由那个集合类返回一个iterator回来，我们统一面向iterator迭代器接口来编程遍历，提高系统整体的可维护性，可扩展性 

如果自己写iterator模式，一般是研发底层的框架，比如提供某个数据给外部遍历，那么可以使用iterator模式自己封装迭代器，以后阶段如果有机会，我们也会去实践

### 30_大白话讲设计模式之适配器模式：适配老版本接口和第三方接口

adapter模式 

场景介绍：

（1）假设我们做了一个第一版的一个系统，这个系统里有一个接口和一个实现类

（2）接着我们开始做第二版的系统，这个系统我们定义了一个新的接口，和新的实现类

（3）但是我们同时在第二版的系统中，也要使用第一版系统中定义的那个老接口和老实现类 

```
public class Adaptee {
    
    public void specificRequest() {
        System.out.println("老的方法实现");
    }
    
}
public interface Target {
    
    void request();
    
}
public class Adapter implements Target {
    
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.spcificRequest();
    }    
}
```

我们手头有有一套系统v1.0版本的老代码，现在要在这个基础之上构建v1.0的新代码。然后有了一个新的接口，需要让别人面向新接口开发，此时就只能开发适配器，适配v1.0版本的类，但是实现的是v2.0的接口，别人调用v2.0的接口，内部却是基于v1.0的老类实现的功能 

在实际企业开发中的使用场景 

这个模式一般是在系统不断升级的过程中使用，对已经写好的老的类，写一套适配器来适配老类，但是提供新的接口，这个我们在后面系统升级的时候，可以去实践。在项目阶段二的时候，会去实践的，真的有版本升级的时候，才可以完美的去演示这个模式的使用效果。 

还有一种情况，是对于已有的第三方类库，比如redis的客户端，或者是elasticsearch的客户端，他们提供了一套API，但是我们这里的要求是需要面向我们这里的DAO接口来进行编程，此时可以写一个适配器，将比如redis客户端的接口适配到我们的接口，这个我们会在本次课程来实践。 

比如我们的DAO接口，要求的接口风格都是：save、update、remove、list、get，这些方法风格 

DAORedisImpl，redis客户端，get、set、mset、mget，一套接口；适配器，DAORedisImpl就是一个适配器，这个适配器实现的是我们的DAO接口，在我们的save、update、remove等方法中，去调用redis客户端的get、set、mset、mget等方法。 

这个东西，我们会从项目阶段二开始，大量的使用，我们就会开始有很多的外部依赖，不只是mysql，mybatis的mapper去做，不太好实践。项目阶段一我们暂时可能就不实践，项目阶段二，大量的实践。

### 31_大白话讲设计模式之模板方法模式：抽取通用代码逻辑到父类 

template method模式 

场景：

（1）我们有多种优惠策略

（2）不同的优惠策略在计算的价格的时候，有一些通用的基础逻辑

（3）每种优惠策略还有一些是自己特殊的价格计算的逻辑 

```
public abstract class AbstractClass {
    
    public void templateMethod() {
        System.out.println("处理优惠打折相关的基础通用逻辑");
        // 但是对于优惠打折具体的处理逻辑，交给不同的折扣类型子类自己去实现
        method1();
        method2();
        method3();
    }
    
    public abstract void method1();
    public abstract void method2();
    public abstract void method3();
    
}
public ConcreteClass extends AbstractClass {
    
    public void method1() {
        System.our.println("实现优惠打折的部分逻辑");
    }
    
    public void method2() {
        System.our.println("实现优惠打折的部分逻辑");
    }
    
    public void method3() {
        System.our.println("实现优惠打折的部分逻辑");
    }    
} 
```

这个模式一定要多用用，尤其是对于有多种不同实现的一些场景，比如说，不同的折扣类型，不同的优惠券类型，不同的商品类型，那肯定涉及到不同的处理逻辑。但是可以将他们共同的基础逻辑抽取到父类中，然后将要子类实现的逻辑留空，交给子类去实现。 

这种场景应该是很常见的， 我们从这个阶段开始，后面每个阶段，只要遇到类似场景，就会去使用这种设计模式 

应该是最高频使用的设计模式，高频到了，我们都不用再这里举个什么例子了，因为在任何一个系统中，一定会出现说，多个类中都有相同的代码，此时就可以使用模板方法设计模式，将多个类中通用的逻辑抽取到一个父类中去

### 32_大白话讲设计模式之简单工厂模式：是个人都会的设计模式 

factory模式 

讲一个我平时面试的一个段子，我一般面试设计模式是必问，会不会写出屎一样的代码 

100个人，90个人，90%比例，会告诉你，他说，我就会工厂模式和单例模式，真是一个笑话，身为一个工作几年的程序员来说 

```
public interface Product {
    
    void operation();
    
}
public class ProductImpl implements Product {
    
    public void operation() {
        System.out.println("简单的接口实现");
    }
    
}
public class Factory {
    
    public static Product createProduct() {
        return new ProductImpl();
    }
    
}
public class Client {
    
    public static void main(String[] args) {
        Product product = Factory.createProduct();
        product.operation();
    }    
} 
```

工厂模式的核心思想，其实就是不要自己在代码里手动new一个实现类对象出来，因为那样的话，调用方就不是面向接口编程了，你还得自己去care实现了。 

我们设想一下，假设有N个client都new了一个ProductImpl出来，结果，到了后面某一天，你要把ProductImpl换成ProductNewImpl了，完全换一套实现逻辑，这个时候就完蛋了。你需要在N个client里，都修改new ProductImpl()这个方法，简直是一场灾难啊。尤其如果调用你的类的是别人呢？别人还得来care这个事情？ 

所以一般都是用工厂的思想来提供所有实现类实例，然后调用方面向接口来编程即可，接口不变，调用方代码不用变 

而在真正的企业开发中，现在我们都很少自己做工厂实现了，因为有spring，spring的容器其实本质上就是个大工厂的概念，这个工厂里什么对象都有，你需要什么，自己去找spring要就好了，非常方便。所以我们队工厂模式的体验，就在这个阶段，通过spring的容器使用来给大家实践。 

spring会基于xml或者是注解，根据一些配置，去创建出来所有我们需要的这个类的实例，此时spring就相当于是个工厂 

@Service

public class UserServiceImpl implemens UserService { 

} 

public class UserController {  

@Autowired

private UserService userService;

} 

我们在项目中，大量的用spring ioc这块功能，其实本身就是在实践工厂模式 

如果一定要自己做工厂实现，那么一般就是在封装底层框架或者中间件客户端的时候，可能需要自己用到工厂模式 

在电商项目中，我们另外初步定的是，会跟构造器模式结合起来给大家演示如何使用，还有一些别的模式，结合业务去给大家演示，自己做工厂模式怎么去做

### 33_大白话讲设计模式之工厂方法模式：稍微复杂一点的工厂模式

factory method模式：模板方法模式+简单工厂模式，简单工厂模式稍微复杂一点的变种 

场景：

（1）我们现在要生产的产品有多种

（2）每种产品的生产过程，都有一些是共同的逻辑，但是也有一些是特殊的逻辑

（3）现在要生产出来各种产品

```
public interface Product {
    
    void method();
    
}
public class ConcreteProduct implements Product {
    
    public void method() {
        System.out.println("特殊产品的自己方法");
    }
    
}
public abstract class Creator {
    
    public Product create() {
        System.out.println("生产一个产品的通用基础逻辑");
        return factoryMethod();
    }
    
    public abstract Product factoryMethod();
    
}
public class ConcreteCreator extends Creator {
    
    public Product factoryMethod() {
        System.out.println("生产自己特有产品的特殊逻辑");
        return new ConcreteProduct();
    }
    
} 
```

说实话，这种设计模式算是较为复杂一点的了，适用的是比较复杂的场景了 

一般就是在有复杂工厂生产场景的情况下，比如就是需要多种工厂生产不同的产品，但是产品都是类似的，同时不同的工厂有一定的相同逻辑，那么就用这种模式 

平时在项目中使用相对频率较低，但是在阶段一中，我们会找一个合适的case来为大家演示如何使用这种设计模式，初步定的是会跟命令模式结合起来使用

### 34_大白话讲设计模式之抽象工厂模式：最复杂的工厂模式变种

abstract factory模式 -> 简单工厂模式的变种 -> 最复杂的一个变种 

场景：

（1）就是我们现在要生产的不是一个一个产品，而一个一个的产品组合

（2）比如说我们有产品ABC，现在第一种产品组合是A+B，第二种产品组合是B+C，第三种产品组合是A+Cs

（3）就是要对工厂模式进行进一步的增强 

```
public interface ProductA {
    
    void operate();
    
}
public interface ProductB {
    
    void operate();
    
}
public class ProductAImpl1 implements ProductA {
    
    public void operate() {
        System.out.println("产品A的实现1的功能执行");
    }
    
}
public class ProudctBImpl1 implements ProductB {
    
    public void operate() {
        System.out.println("产品B的实现1的功能执行");
    }
    
}
public class ProductAImpl2 implements ProductA {
    
    public void operate() {
        System.out.println("产品A的实现2的功能执行");
    }
    
}
public class ProudctBImpl2 implements ProductB {
    
    public void operate() {
        System.out.println("产品B的实现2的功能执行");
    }
    
}
public interface AbstractFactory {
    
    ProductA createProductA();
    ProudctB createProudctB();
    
}
public class FactoryImpl1 implements AbstractFactory {
    
    public ProductA createProductA() {
        return new ProductAImpl1();
    }
    
    public ProductB createProductB() {
        return new ProductBImpl1();
    }
    
}
public class FactoryImpl2 implements AbstractFactory {
    
    public ProductA createProductA() {
        return new ProductAImpl2();
    }
    
    public ProductB createProductB() {
        return new ProductBImpl2();
    }
    
} 
```

这种模式就更复杂了，在实际开发场景中，更加少见了。因为其核心思想是，如果需要一个工厂，这个工厂可以生产出相关联的一批产品，然后不同的工厂实现，会生产出一批不同的产品组合。这个，大家只能在这里理解一下这种思想，我们在阶段一的项目实际的系统设计中，跟策略模式结合起来，电商业务，给大家找一个合适的场景来，在业务中实践一下。

### 35_大白话讲设计模式之单例模式：一个类就只有一个实例

singleton模式 

单例模式，在系统里，你要判断一下，如果有一些类，只需要一个实例对象就可以了，那就给那个类做成单例的模式 

实际上，我应该说，单例模式也是一个是个人就会的设计模式，因为我在面试的时候，单例模式，工厂模式。单例模式和工厂模式。太简单了。 

常见的场景 

（1）比如说，你自定义了一个框架，自定义了一份xml格式的一个配置文件，你要读取这个配置文件，这个配置文件中的数据，读取到类中，这个类的实例，只要保存一份就可以。那么此时可以使用单例模式，将这个类做成他的实例只能有一个，在这个实例中保存了配置文件中的数据

（2）类似于我们之前给大家讲解的那个工厂模式，有些工厂是需要实例化对象的，要基于实例化对象，来实现继承、接口、实现等功能，工厂实例可以做成单例的，就可以了

（3）你自己去判断，如果是一个类的实例只需要保持一份，那就做成单例 

```
// 饿汉模式
public class Singleton {
   
    private static final Singleton instance = new Singleton();
    
    private Singleton() {
    
    }
    
    public static Singleton getInstance() {
        return instance;
    }
    
}
public class Singleton {
    
    private static Singleton instance;
    
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Sinngleton.class) {
                if(instance == null) {
                    Singleton.instance = new Singleton();
                }
            }
        }
        return instance;
    }
    
}
public class Singleton {
    
    private Singleton() {
    
    }
    
    private static class LazyHolder {
        
        private static final Singleton singleton = new Singleton();
        
    }
    
    public static Singleton getInstance() {
        return LazyHolder.singleton;
    }
    
} 
```

最简单的一种类了，就是如果一个类就只需要一次，那么就使用这个类了 

但是使用单例模式有一个要求，不允许这个类的逻辑过于复杂，一般就是持有某份配置文件的配置，或者是别的一些数据 

因为如果别的很多类用了这个类，是没法打桩注入的，很麻烦 

所以只能是简单的情况下，用单例模式，就是持有一份数据，但是这份数据全局就只要一份，比如说一些配置数据，就用单例模式，或者是类似redis的客户端实例，或者是类似elasticsearch的客户端实例 

在咱们项目中，对一些工厂的实例，结合工厂模式来做，可以做成单例的

### 36_大白话讲设计模式之外观模式：将多个内部模块调用封装在一个类中 

facade模式 

场景 

1、假设我们现在有两个子系统

2、子系统A，有多个内部模块，模块A、模块B和模块C

3、子系统B，现在有一个功能，需要同时依赖3个模块来实现一个功能 

```
public interface ModuleA {
    
    void operate();
    
}
public class ModuleAImpl implements ModuleA {
    
    public void operate() {
        System.out.println("实现模块A的功能");
    }    
    
}
public interface ModuleB {
    
    void operate();
    
}
public class ModuleBImpl implements ModuleB {
    
    public void operate() {
        System.out.println("实现模块B的功能");
    }    
    
}
public interface ModuleC {
    
    void operate();
    
}
public class ModuleCImpl implements ModuleC {
    
    public void operate() {
        System.out.println("实现模块C的功能");
    }    
    
}
public class SystemAFacade {
    
    public static void operate() {
        ModuleA moduleA = new ModuleAImpl();
        moduleA.operate();
        
        ModuleB moduleB = new ModuleBImpl();
        moduleB.operate();
        
        ModuleC moduleC = new ModuleCImpl();
        moduleC.operate();
    }
    
}
public class SystemB {
    
    public static void main(String[] args) {
        SystemA.operate();
    }  
} 
```

外观模式其实很简单，就是说，假设我们有一个系统A吧，自己内部有多个代码组件，每个代码组件都可以实现一些功能。此时如果别的系统B要调用系统A实现某个功能，此时一种方法是，系统B调用系统A的多个代码组件的方法，最终实现一个功能。另外一个选择，就是系统A里提供一个Facade类，系统B不需要care系统A内部有多少个代码组件，直接调用系统A的一个facade类的一个方法即可。 

就是说，大家可以想象一下，比如说service就是一个经典的门面模式 

如果一个子系统里有多个DAO组件，然后如果别的子系统要实现一段业务逻辑，需要使用这个子系统的多个DAO组件，那就会导致别的子系统代码会很乱，需要care这个子系统很多DAO组件的实现。但是这个组件可以基于多个DAO组件封装出来一个service接口，然后别的系统就针对一个service接口开发即可。这个service不就是一个典型的门面吗？ 

这个模式在我们的电商系统里可以大量使用，就是用facade包装每个子系统内部的大量代码组件，对外暴露统一简单的接口

### 37_大白话讲设计模式之构造器模式：封装复杂对象的构造逻辑

builder模式 

场景

（1）构造一个复杂的对象，很多的属性，有些属性构造的时候需要做一些校验，格式转换 

```
public interface Builder {
    
    void field1(String value);
    void field2(String value);
    
}
public class Product {
    
    private String field1;
    private String field2;
    
}
public class ConcreteBuilder implements Builder {
    
    private Product product = new Product();
    
    private ConcreteBuilder() {
    
    }
    
    public static Builder build() {
        return ConcreteBuilder();
    }
    
    public Product create() {
        return product;
    }
    
    public Builder field1(String value) {
        product.setField1(value);
        return this;
    }
    
    public Builder field2(String value) {
        product.setField2(value);
        return this;
    }
    
}
public class BuilderFactory {
    
    public static Builder build() {
        return new ConcreteBuilder();
    }
    
}
public class Client {
    
    public static void main(String[] args) {
        Builder builder = BuilderFactory.build();
        Product product = builder.field1("属性1").field2("属性2").create();
        System.out.println(product);
    }    
} 
```

构造器是一种非常棒，非常实用，非常常用的设计模式，大家务必要掌握好 

常见于在构建一个复杂的对象，或者是构建一个复杂的表达式的时候，在开源框架中有大量广泛的运用 

给大家举个例子，Mockito框架中，when().thenReturn()之类的，其实就是构造器模式的一种，通过多个连续的方法完成一个模拟对象的构建；还有就是spring test框架汇总，MvcMock对象，也是通过thenExpected()等多个连续的方法，完成一个mvc测试对象的构建，这块我们首先在后面spring boot源码剖析的时候，会带着大家来阅读这些源码，掌握实践。同时在阶段一的电商系统设计中，我们对于一些复杂对象的构建，给大家举个例子，比如说销售出库单的构建，如此复杂的对象，采用构造器模式是非常合适的 

用构造器模式的最大好处是啥？复杂对象的构建过程太复杂了，里面可能包含一些业务逻辑，比如值检查，格式转换之类的。如果每个客户端都自己手动去完成构建的话，那么大量的冗余代码是一个；另外一个，如果我们要改变对象的构建过程的实现，可以就在构造器中一个地方修改即可，对于调用方完全透明；最后，如果我们要完全替换掉以前的builder实现的话，那么完全可以在工厂里替换一个实现，还跟简单工厂模式结合起来使用了

### 38_大白话讲设计模式之原型模式：自己实现自己的对象拷贝逻辑 

prototype模式 

场景，如果一个对象，我们希望拷贝一个这个对象，就是弄出来这个类的另外一个实例，实例的属性跟之前的实例是一模一样的 

我们要用原型模式，以某一个对象为原型，然后对这个对象进行拷贝，得到拷贝后的另外一个对象 

```
public interface Prototype {
    
    Prototype clone();
    
}
public class ConcretePrototype implements Prototype {
    
    private String field1;
    private String field2;
    
    public Prototype clone() {
        Prototype prototype = new ConcretePrototype();
        prototype.setField1(field1);
        prototype.setField2(field2);
        return prototype;
    }
    
} 
```

原型模式，顾名思义，其实说白了，就是让一个对象可以自己拷贝自己，对象把自己当成一个原型，然后提供一个方法出去，外部要一个对象的克隆和拷贝，直接就copy一份就可以了，但是这里要记住深拷贝和浅拷贝的区别 

因为一个对象可能还持有别的对象的引用，浅拷贝就是不管引用的其他对象了；深拷贝就是将引用的对象也一起拷贝一份；一般原型模式都是要支持深拷贝的 

而且其实一般实现原型模式的时候，直接是通过覆盖Object类的clone()方法即可，在里面实现自己的拷贝逻辑就可以了 

使用原型模式比较好的一点，就是如果别人要拷贝你的对象，不需要调用方自己实现拷贝逻辑，将拷贝逻辑放在对象自己身体里就可以了，对外面调用都是透明的 

这个模式其实在我们的电商系统中，完全有场景可以使用，大家想象一下，比如我们的这个订单、发货单、销售出库单、财务结算单，这些单子之间，可能就是有大量的属性是要互相拷贝的。我们手上有一个订单之后，想将订单中的数据拷贝到一个发货单中，将发货单中的属性拷贝到一个销售出库单中，再将销售出库单中的属性拷贝到财务结算单中。 

这种大量的属性拷贝的业务场景，我们就可以对原型模式进行改造，我们可以实现一个适合自己系统的通用的对象属性拷贝工具类，然后对那些需要互相之间支持属性拷贝的类，我们可以重写其clone()方法，这个我们后面再讲解，发货单的clone()方法，调用之后，克隆出来的是一个销售出库单

### 39_大白话讲设计模式之中介者模式：让互相调用的模块之间解耦合

mediator模式 

场景

（1）三个模块

（2）模块1调用模块2和模块3；模块2要调用模块1和模块3；模块3要调用模块1和模块2 

```
public interface Mediator {
    
    void changed(Colleague colleague);
    
}
public class ConcreteMediator implements Mediator {
    
    private ColleagueA colleagueA;
    private ColleagueB colleagueB;
    
    public void changed(Colleague colleague) {
        
    }
    
}
public abstract class Colleague {
    
    private Mediator mediator;
    
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
    
    public Mediator getMediator() {
        return mediator;
    }
    
}
public class ColleagueA extends Colleague {
    
    public ColleagueA(Mediator mediator) {
        super(mediator);
    }
    
    public void operate() {
        getMediator().changed(this);
    }
        
}
public class ColleagueB extends Colleague {
    
    public ColleagueA(Mediator mediator) {
        super(mediator);
    }
    
    public void operate() {
        getMediator().changed(this);
    }        
} 
```

这个模式，担心的就是系统中各个子系统之前互相之间调用，乱成一团。所以就将系统之间互相调用的逻辑给放到一个所谓的中介者里面去。每个系统如果要通知别的系统干个什么事儿，直接就是调用中介者，中介者负责去调用别的系统。 

我们来思考一下这个本质，其实说白了，这个模式就是要让各个系统之间彻底解耦，不要互相强耦合在一起，互相调用过多，调用关系过于混乱。互相调用的时候通过一个中间的组件来解耦。 

在实际的企业开发中，不是这么玩儿的，很少有见到说封装一个所谓的中介者，去让各个模块之间解耦，思考这个模式的本质，让各个模块之间解耦合 

最最常见的一个方式，就是系统与系统之间，不是走直接的接口调用，而是基于MQ来解耦。录入过模块A要调用模块B和模块C，模块A发送一条消息到MQ里面去，模块B和模块C去消费这条消息，读到消息之后，知道模块A要调用自己，所以就执行对应的逻辑即可。常见于系统与系统之间的调用，可以基于MQ消息，异步执行的方式来调用，不需要同步调用和执行。 

大家想一下，这不就是典型的各个子系统用MQ来解耦么，有些操作，互相直接不是直接调用，消息发送到MQ，通过MQ来解耦。我们在电商系统里也完全有这种场景，到后面我们设计系统的时候给大家分析。我们可以封装一个基于内存队列的异步解耦中介者组件，然后让系统间有些可以异步的操作通过中介者来执行，降低互相调用的复杂度。 

模块A将消息发送到一个内存队列中去，其他的模块去内存队列中消费自己感兴趣的消息，来执行对应的操作，用队列替代了中介者，让各个模块之间解耦合，rabbitmq去做

### 40_大白话讲设计模式之代理模式：本地接口代理远程接口的调用 

proxy模式 

```
public interface Subject {
    
    void request();
    
}
public class ConcreteSubject implements Subject {
    
    public void request() {
        System.out.println("执行功能");
    }
    
}
public class Proxy implements Subject {
    
    private Subject subject;
    
    public Proxy(Subject subject) {
        this.subject = subject;
    }
    
    public void request() {
        subject.request();
    }    
} 
```

代理模式实在是太常见太常见了，2个场景： 

（1）懒加载：hibernate、mybatis，都可以实现懒加载，这个大家应该都知道了，其实也是基于动态代理思想实现的，对刚查询出来的对象做一个代理。然后去调用getX()方法的时候，再实际执行sql查询出来关联的数据。 

public interface Classroom {  

  List<Student> getStudents(); 

} 

public class ConcreteClassroom implements Classroom { 

  private List<Student> students; 

  public List<Student> getStudents() {

​    return student;

  }    

} 

public class ProxyClassroom implements Classroom { 

  private ConcreteClassroom classroom; 

  public List<Student> getStudents() {

​    // 先查询一下缓存，内存缓存中是否有students数据

​    // 如果没有的话，那就发送SQL从数据库中查询出来，然后放到缓存中去

​    // 接着返回students数据

​    classroom.setStudents(students);

​    return classroom.getStudents();

  } 

} 

通过hibernate/mybatis，查询出来这个classroom的时候，是没有级联将students数据从数据库里查出来的。接下来，如果你要从classroom中获取students集合来使用的时候，你会去调用getStudents()。懒加载的原理，其实就是基于代理模式去做的，刚从数据库中查询出来的是classroom的一个代理对象 

现在在互联网公司里，不提倡说利用这种ORM的方式去开发数据库的操作，就是不要推荐在类中放置其他类的引用，就是面向对象的层级在组织数据了 

（2）远程调用：比如thrift等rpc调用包，都是在本地做一个远程服务的本地代理接口，然后对本地代理接口来调用，然后代理对象发送网络请求调用远程服务的接口 

系统要调用另外的一个系统的接口，要走网络请求，远程调用，http接口；rpc，系统在本地就是调用一个代理类的接口，代理类在接口的代理实现中，是会发送网络请求跟远程的系统通信，调用对方的接口 

public class Proxy implements Interface {  

  public void request() {

​    // 发送网络请求到远程系统，去调用对方的接口

  } 

} 

spring cloud，dubbo，分布式系统的架构，分布式系统之间互相的调用，其实就是大量的用了代理模式，代理接口，代理了远程系统的接口 

我们这里的代理模式实践，会基于调用外部接口的方式来，比如支付和物流，都要调用第三方公司的接口，那么完全可以做一个代理类，我们自己的系统针对代理类来操作，代理类代理了对外部接口的访问，非常合适的场景

### 41_大白话讲设计模式之观察者模式：监听目标对象的状态改变

observer模式 

场景

（1）比如我们有一个目标对象，一旦这个目标对象的状态改变了，然后的话就去通知相关的对象，我的状态改变了，数据也变化了 

```
public class Subject extends Observable {
    
    private String message;
    
    public String getMessage() {
        return message;
    }
    
    public void changed() {
        this.setChanged();
        this.notifyObservers(message); // 推模式
        // this.notifyObservers(); // 拉模式
    }
    
}
public class ConcreteObserver implements Observer {
    
    public void update(Observerable observable, Object object) {
        System.out.println(object); // 获取推模式推送过来的数据
        // System.out.println(((Subject)observable).getMessage()); // 拉模式情况下自己去拿数据
    }   
} 
```

前端开发，js脚本，要对界面上的各种视图组件，表格点击事件，按钮点击，添加监听器，一旦某种事件发生，就会执行监听器中的方法 

观察者模式还是非常常用的，不过说实话，常见于基于zookeeper进行分布式系统之间的协调工作，比如分布式锁的注册以及监听是否释放。还有就是两个系统之间如果做了异步的处理，那么如果A系统发送异步请求给了B系统，但是要得到B系统的一个状态改变的消息，可以采用观察者模式。 

基于zookeeper去做分布式锁 

（1）系统A尝试获取zookeeper上的一个锁，获取到了

（2）系统B尝试获取zookeeper上的一个锁，被系统A给锁了，没有获取到锁，此时系统B在zookeeper上可以注册一个监听器（观察者）

（3）系统A一旦将锁给释放了，zookeeper感受到锁被释放了，就会立即通知系统B注册的那个监听器

（4）系统B就立即被通知到了，系统A释放了锁，系统B可以重新尝试在zookeeper上加锁 

我们的电商系统里，也是有这种场景的，如果两个系统之间走了异步请求，那么可以基于上面那种观察者模式现在一个进程内实现监听，以后拆分微服务分布式架构了，可以改成基于zookeeper来做分布式协调。 

系统A发送了一条消息到内存队列，系统B获取了消息开始执行操作

但是系统A需要知道系统B的一个执行的结果如何，此时怎么办？

系统A需要注册一个观察者到系统B上去，系统B执行完了之后，将执行的结果，反过来通知给系统

我们就可以基于观察者模式去做

### 42_大白话讲设计模式之命令模式：给其他模块下达命令

command模式 

```
public interface Command {
    
    void execute();
    
}
public class CommandA implements Command {
    
    public void execute() {
        System.out.println("命令A的逻辑");
    }
    
}
public class CommandB implements Command {
    
    public void execute() {
        System.out.println("命令B的逻辑");
    }
    
}
public class Invoker {
    
    private Command command;
    
    public Invoker(Command command) {
        this.command = command;
    }
    
    public void execute() {
        cmmand.execute();
    }    
} 
```

命令模式是很常用的，一般就是说，你可能会执行一些操作，这些操作都实现一个接口，但是有不同的命令实现，然后命令的执行类就是同一个，你需要执行哪个命令就封装那个命令后发送给执行类即可 

我之前在龙果的电商缓存架构课程里，就用了这个命令模式，读请求和写请求，封装成command，然后发送给一个异步处理线程，他不管是什么命令，执行即可，逻辑都封装在命令的内部了 

其实命令模式非常适合跟工厂方法模式结合起来使用，就是使用多个工厂来制造出不同的命令类来，将命令的构造放在工厂方法中

### 43_大白话讲设计模式之组合模式：对层级数据递归调用执行操作

composite模式 

场景：

（1）父部门->子部门->子部门

（2）我们要对部门树，删除一个父部门以及其下所有的子部门 

```
public abstract class Component {
    
    public abstract void operate();
    
    public void addChild(Component child) {
        
    }
    
    public void removeChild(Component child) {
    
    }
    
    public Component getChildren(int index) {
    
    }
    
}
public class Composite extends Component {
    
    private List<Component> children = new ArrayList<Component>();
    
    public void addChild(Component child) {
        children.add(child);
    }
    
    public abstract void removeChild(Component child) {
        children.remove(child);
    }
    
    public Component getChild(int index) {
        children.get(index);
    }
    
    public void operate() {
        for(Component component : children) {
            component.operate();
        }
    }
    
}
public class Leaf extends Component {
    
    public void operate() {
        System.out.println("执行具体功能");
    }    
} 
```

组合模式非常适用于有较多父子层级关系的那种场景，比如部门树的递归删除，或者是文件树的递归删除之类的场景。这个还是比较好模拟的，我们会在电商系统的权限那块给大家演示，比如删除一个父权限，就要级联递归删除所有的子权限，这个时候可以对组合模式做一点变种，自动从根权限开始，递归查询所有层级的子权限，然后一直到叶子节点的权限，从叶子节点开始删除

### 44_大白话讲设计模式之策略模式：替换掉屎一样的if else语句

strategy模式 

场景

（1）我们可以根据不同的参数来选择一种我们想要执行的优惠计价方式 

```
public interface Strategy {
    
    void execute();
    
}
public class StrategyA implements Strategy {
    
    public void execute() {
        System.out.println("策略A的功能逻辑");
    }
    
}
public class StrategyB implements Strategy {
    
    public void execute() {
        System.out.println("策略B的功能逻辑");
    }
    
}
public class StrategyC implements Strategy {
    
    public void execute() {
        System.out.println("策略C的功能逻辑");
    }
    
}
public class Context {
    
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void execute() {
        strategy.execute();
    }    
} 
```

策略模式，将会成为最最高频使用的一种设计模式，他的常见应用场景，就是替换掉那一大坨复杂难懂的if else if else。对于那种过于复杂的选择判断逻辑，完全可以将选择哪种策略的过程放到工厂里去。工厂，可以是简单工厂，也可以是工厂方法，也可以是抽象工厂。 

我们这里打算用抽象工厂模式，跟策略模式结合起来，大家可以想象一下复杂的场景，一个复杂的业务逻辑里面，每个if else判断之后，要跟一堆复杂的业务逻辑，我们可以将不同的业务逻辑抽取成不同的策略，然后一个具体的工厂实现，可以创建出一个策略组合来。 

到时候会结合电商的业务来设计 

策略模式跟命令模式的区别？看起来一样的，但是用处不一样。命令是可以发送出去，然后可以经过一些队列的流转，比如先把命令发送到MQ，接着再处理。策略是说选择了一组策略，立即就要执行的，不会经过其他别的什么处理。而且策略逻辑基本就是用在复杂的if else代码中的 

命令模式，可以用在更多别的场景中 

思想是不一样的，也许实现上，接口、实现类、工厂来做的，适合的场景是不一样的

### 45_大白话讲设计模式之状态模式：封装数据的状态流转逻辑

state模式 

场景

（1）销售出库单，状态需要从新建、待审批、已审批、已完成，四个状态之间流转，流转到每个状态的时候，都需要执行那个状态对应的一个逻辑 

```
public interface State {
    
    void handle(String parameter);
    
}
public class StateA implements State {
    
    public void handle(String parameter) {
        System.out.println("状态A的处理逻辑");
    }
    
}
public class StateB implements State {
    
    public void handle(String parameter) {
        System.out.println("状态B的处理逻辑");
    }
    
}
public class Context {
    
    private State state;
    
    public void setState(State state) {
        this.state = state;
    }
    
    public void request(String parameter1, String parameter2) {
        state.handle(parameter1);
        if(parameter2.equals("B")) {
            this.state = new StateB();
        }
    }    
} 
```

其实状态模式，就是维护多种不同的状态，每种状态下可以去执行一些特殊的逻辑。然后由一个Context类负责根据请求参数调用，来维护这些状态之间的切换，形成一个状态机的概念。 

状态模式里，非常重要的一点就是将状态之间流转的逻辑，封装在Context类里面。本来可能需要调用方自己维护复杂的状态流转逻辑，流转到不同的状态之后，执行状态对应的代码逻辑。 

这个状态模式，在电商系统中有天然的运用场景，我们的系统中很多数据都有大量的状态变更的逻辑，我们可以将状态变更的逻辑用状态模式来实现，将状态流转封装在一个地方，每次状态变更就通知那个组件，让状态流转，同时执行状态对应的代码逻辑

### 46_大白话讲设计模式之备忘录模式：将中间数据暂存之后再恢复 

memento模式 

场景 

（1）类，计算出来一份中间数据

（2）这个类，之后需要基于这份中间数据再执行另外两次操作，每次操作都要基于这份中间数据去执行

（3）第一次基于中间数据操作过后，会对中间数据做出修改

（4）要求是第二次再执行操作的时候，需要基于未修改之前的中间数据来执行 

```
public interface Memento {
    
}
public class Originator {
    
    private String state;
    
    public void prepare() {
        this.state = "中间数据";
    }
    
    public void executeA() {
        System.out.println("基于中间数据【" + state +"】进行了A方法的执行");
        state += "，A方法的结果数据";
    }
    
    public void executeB() {
        System.out.println("基于中间数据【" + state +"】进行了A方法的执行");
        state += "，A方法的结果数据";
    }
    
    public Memento createMemento() {
        return new MementoImpl(state);
    }
    
    public void setMemento(Memento memento) {
        MementoImpl mementoImpl = (MementoImpl)memento;
        this.state = mementoImpl.getState();
    }
    
    private static class MementoImpl implements Memento {
        
        private String state;
        
        public MementoIMpl(String state) {
            this.state = state;
        }
        
        public String getState() {
            return state;
        }
        
    }
    
}
public class Caretaker {
    
    private Memento memento;
    
    public void saveMemento(Memento memento) {
        this.memento = memento;
    }
    
    public Memento retriveMemento() {
        return this.memento;
    }
    
}
public class Client {
    
    public static void main(String[] args) {
        Originator originator = new Originator();
        
        // 准备好了中间数据
        originator.prepare();
        // 将中间数据保存到备忘录中去
        Memento memento = originator.createMemento();
        // 将备忘录保存到备忘录管理器中去
        Caretaker caretaker = new Caretaker();
        caretaker.saveMemento(memento);
        // 基于中间数据执行了A方法，但是此时中间数据已经改变了
        originator.executeA();
        // 从备忘录管理器中获取备忘录
        memento = caretaker.retrieveMemento();
        // 将备忘录中保存好的中间数据重新设置到原发器中去，就将中间数据恢复成了之前备忘的状态
        originator.setMemento(memento);
        // 接着再次执行方法B
        originator.executeB();
    }    
} 
```

备忘录模式看起来有点复杂，其实不复杂，说白了，就是一个类一开始生产了一些数据，这些数据可能会被改变，但是需要将这些中间数据保存起来，给后面不同的操作使用这些中间数据 

所以备忘录，顾名思义，就是用备忘录来保存中间数据，后面随时可以获取备忘录里的数据并且恢复这些数据 

复杂业务场景，和真实项目的好处，业务足够复杂，才能支撑我们将各种各样的技术运用到项目实践中，纯真实复杂业务项目的驱动，大量的技术，还是理论，demo练习，学完，达不到架构师的水平，demo 

广告系统，N个子系统，某一个子系统跟下游的子系统之间是基于MQ去通信的。但是此时要考虑说MQ如果挂了怎么办，写消息到MQ的子系统，一旦发现MQ挂了，将数据写入磁盘，暂存。后面MQ恢复了，再从磁盘里恢复这个数据。 

这个模式其实使用场景很少见，属于冷门模式，我这边打算是跟命令模式结合起来，做电商系统里面不同子系统之间进程内通过阻塞队列异步通信的一个场景。因为既然是阻塞队列，就要考虑到也许队列会填满，此时整个系统可能就会卡住，所以需要做一个防御措施，就是写入阻塞队列的时候如果满了，就将数据通过备忘录模式持久化到磁盘上去，然后到了后面阻塞队列空闲出来的时候，再通过备忘录管理器，从磁盘上恢复备忘录里的数据回来

### 47_大白话讲设计模式之享元模式：简单的jvm内存对象池缓存

flyweight模式 

场景

（1）我们现在要缓存一些数据，比如说权限，根据权限的ID作为key，权限数据自己本身是value

（2）但是我们不需要使用太复杂的ehcache框架之类的去使用，特别特别的简单的

（3）我们就想基于自己的Map去实现一套东西 

```
public interface Flyweight {
    
    void operate();
    
}
public class ConcreteFlyweight implements Flyweight {
    
    public void operate(String state) {
        
    }
    
}
public class FlyweightFactory {
    
    private Map<String, Flyweight> map = 
        new HashMap<String, Flyweight>();
    
    public Flyweight getFlyweight(String key) {
        Flyweight flyweight = map.get(key);
        
        if(flyweight == null) {
            flyweight = new ConcreteFlyweight();
            map.put(key, flyweight);
        }
        
        return flyweight;
    }    
} 
```

享元模式，从最基本的角度来说，其实就是维护固定数量的对象实例，不同的对象实例，只有一个，然后保存在内部的一个map中。可以算是跟单例模式的一个扩展和结合吧。 

这边我可以给大家说一个享元模式的常见使用场景，其实就是jvm内缓存实现，如果我们不想引入ehcache之类缓存框架，就想简单一点，通过自己实现的一个map来缓存对应的一些数据，比如说每个权限的数据，或者每个员工的数据，在内存里自己维护一个缓存工厂，就是基于享元模式的思想来实现的。 

这块我们在电商系统里，可以在权限那块，做一个简单的冷数据jvm缓存方案呢，来给大家实践。

### 48_大白话讲设计模式之装饰器模式：对目标类的功能进行增强

decorator模式 

场景 

（1）假设我们手头已经有了一个类，可以执行一些功能

（2）但是我们还是希望对这个类的功能做一些增强，此时怎么办呢？基于已有的类的功能基础之上，再增强一些功能，可以做装饰 

```
public interface Component {
    
    void operate();
    
}
public class ConcreteComponent implements Component {
    
    public void operate() {
        System.out.println("组件的功能");
    }
    
}
public class Decorator implements Component {
    
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operate() {
        System.out.println("实现某些动态加强功能");
        component.operate();
        System.out.println("实现某些动态加强功能");
    }    
} 
```

装饰器模式有一些非常经典的实现 

（1）比如java的io体系，可以一层包装一层，一层包装一层，外面的一层，都会对立面的一层进行功能的增强。

（2）还有就是spring的aop，aop这块可以基于动态代理的理念，装饰我们的目标对象，然后加入事务控制，日志打印之类的功能。 

```
public interface UserService {
    
    void save(User user);
    
}
@Transactional
public class UserServiceImpl implements UserService {
    
    public void save(User user) {
        // 执行插数据库的操作
    }
    
}
// spring aop
public class UserServiceImplProxy implements UserSerivce {
    
    private UserSerivce userService;
    
    public void save(User user) {
        // 执行操作之前打开事务
        connection.startTransaction();
        // 执行目标的功能
        userService.save(user);
        // 执行完之后提交事务
        connection.commitTransaction();
    }    
} 
```

我们本次会在电商业务设计的时候，结合具体业务，来考虑如何运用这个模式

### 49_大白话讲设计模式之责任链模式：动态组装不同的复杂业务流程

chain of responsibility模式 

场景： 

（1）现在在某一个地方的业务流程，要执行功能1、功能2、功能3

（2）现在在另外一个地方的业务流程，是要先执行功能3，然后执行功能1和功能2 

```
public abstract class Handler {
    
    protected Handler successor;
    
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
    
    public abstract void handleRequest();
    
}
public class ConcreteHandler1 extends Handler {
    
    public void handleRequest() {
        System.out.println("ConcreteHandler1实现代码")
        this.successor.handleRequest();
    }
    
}
public class ConcreteHandler2 extends Handler {
    
    public void handleRequest() {
        System.out.println("ConcreteHandler2实现代码")
        this.successor.handleRequest();
    }
    
}
public class Client {
    
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        handler1.setSuccessoro(handler2);
        handler1.handleRequest();
    }    
} 
```

责任链模式，那也是经常会使用到的，对于那种复杂的业务流程，一种方案是采取面向对象的设计，将不同的业务逻辑封装到不同的类里去，然后通通过方法中的调用来控制业务流向；另外一种就是采用责任链模式，将业务逻辑封装到不同的handler里面去，形成链条式调用。 

什么时候用责任链模式呢？很简单，就是如果你需要动态组装一个业务流程出来，流程中的每个handler业务逻辑需要复用，那就用责任链模式。 

这块在电商系统设计的时候，会结合业务场景来实践

### 50_大白话讲设计模式之桥接模式：两个代码组件之间面向接口桥接调用 

bridge模式 

```
public interface Implementor {
    
    void operate();
    
}
public class ImplementorA implements Implementor {
    
    public void operate() {
        System.out.println("具体的实现");
    }
    
}
public abstract class Abstraction {
    
    protected Implementor implementor;
    
    public Abstraction(Implementor implementor) {
        this.implementor = implementor;
    }
    
    public abstract void operate();
    
}
public class RefinedAbstraction extends Abstraction {
    
    public RefinedAbstraction(Implementor implementor) {
        super(implementor);
    }
    
    public void operate() {
        implementor.operate();
    }    
} 
```

所谓的桥接，就是搭建一个桥，让两个组件之间互相调用，可以通过桥来执行。因为有了桥，两个代码组件无论怎么修改，都互相没有影响。这个桥，实际上就是一个接口。所以说，java中，无处不桥接，只要你是面向接口编程，基本就是在桥接。 

```
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserDAO userDAO;
    
}
public class UserController {
    
    @Autowired
    private UserService userService;    
}
```

### 51_大白话讲设计模式之访问者模式：动态的给目标对象增加新功能

visitor模式 

场景 

（1）组合模式，我们现在想象一下，我们之前做的是说递归删除部门自己本身

（2）但是我们现在要对他改造一下，将组合模式和访问者模式结合起来，就是说，我们可以让那颗树执行我们想要他做的任何事情 

```
public interface Visitor {
    
    void visit(Element element);
    
}
public abstract class Element {
    
    public abstract void accept(Visitor visitor);
    
}
public class ConcreteElement extends Element {
    
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    
}
public class ConcreteVisitor implements Visitor {
    
    public void visit(Element element) {
        
    }   
} 
```

访问者模式，是对目标对象，动态的执行某个功能，而不对目标对象有任何的改动 

长什么样？如果不这么做有什么不好？这么做了有什么好处？ -> 大白话，没有任何理论的东西在里面，就是纯大白话，简单的代码，把模式的精髓给大家展现出来 

如果真正要透彻的掌握，深刻的理解，自己以后可以用到自己的业务系统里去， 设计出来那种可扩展、可维护、结构清晰、优雅的代码，还需要实践，电商系统里重点去实践一下 

软件工程、项目管理、设计模式，是架构师的基本功，spring boot比较流行，大路货，spring boot源码 

制定系统的开发流程和规范，制定项目管理流程和规范，按照那套流程和规范去实际把控和完成整个项目，设计模式都是必用，代码质量 

23种设计模式里，只有一种我这里没讲，解释器模式，真的太冷门了，几乎很少用 

实际开始做项目了，结合我们的电商系统的需求文档 -> 需求评审 -> 需求分析 -> 概要设计 -> 详细设计 -> 工程初始化 -> 项目管理 -> 开发 -> 单元测试 -> 冒烟测试 -> 静态代码扫描 -> code review -> 集成测试 -> 系统测试 -> 验收测试 -> 系统上线 -> 线上运维  

重点在业务里实践软件工程和项目管理，设计模式 -> spring boot源码分析 -> 交付出来真实的电商系统v1.0内测版

### 52_需求评审：看看权限中心的需求有没有什么模糊的地方

从这一讲开始，就正经进入咱们的这个电商项目的实际项目流程中1627098499 

（1）需求评审：开个会，PM在上面大讲特讲，唾沫横飞，讲自己的产品需求文档，作为技术负责人，在底下听着，一边听一边发问，如果有不靠谱的需求，申请砍掉，不做，或者是让它重新考虑一下思路，或者是有些模糊的没有细化的地方，让它补充完整，细化

（2）需求分析：架构师，需求分析，从系统层面去分析一下，基于上面的需求文档，我们的这个系统大体要做成什么个样子

（3）概要设计：架构师，整体的设计一下，系统整体的技术架构

（4）概要设计评审：一般来说，找其他team的高P（技术专家以上的人，类阿里P7以上的人）过来，帮我们评审一下，或者是团队里其他的高P

（5）详细设计：team里负责干活儿的每个小弟，认领几个系统，每个人对自己的系统或者模块去进行细化的设计，要求照着文档可以写代码

（6）详细设计评审：架构师，负责对每个小弟的详细设计文档进行评审，看他们设计的有没有问题

（7）项目管理：计划的制定、执行监控、风险管理、变更管理

（8）工程初始化：把所有的代码、工程、git、数据库、各个开发环境、接口定义，搞定，让大家可以上手开始写代码

（9）编码开发：按照git工作流，每个人拉个自己的分支，上手开始搞

（10）单元测试：边开发边单元测试，每次写好一个代码组件，或者是一个模块之后，就写对应的单元测试

（11）静态代码扫描：编码+单测都搞完了，用工具扫描一遍自己的代码，如果有什么问题再改改，单元测试再跑一遍，确保没问题

（12）冒烟测试：静态代码扫描完了以后，冒烟，本地自己跑起来，冒烟走一遍流程，确保自己负责的系统或者模块没什么问题

（13）代码审查：自己的feature提交pull request到develop分支，让高P，初级工程师（校招生，P5）找带他们的中级工程师（工作过1年的P5），或者是高级工程师（P6），给他们看看代码；P5或者P6，找其他同级别的同事，给他们看一下代码，当然也可以找架构师，P7以及上的人，给他们看一下代码

（14）集成测试：大家的代码纷纷合并到develop分支，开始订会议室，进入一个小黑屋里，由QA开始按照它设计好的集成测试用例，开始测，发现一个问题，干掉，干掉，小黑屋里面待几天，确保整套系统可以跑通

（15）系统测试：QA，用自己设计好的非常细致的功能测试的用例，达到集成测试用例的几倍之多，不同的输入参数，不同的操作步骤，异常的情况，看看系统能否正常工作。QA每次测试完一轮，发一份bug list，每个RD自己认领bug，修复，几轮过后，三轮。四轮。功能都ready了。

（16）验收测试：部署staging环境，PM来验收，PM准备一份自己的测试用例，跟QA的测试用例有很多重合的。验收一遍，确认ok。

（17）系统上线：按照规范和流程上线

（18）系统运维：线上bug的处理 

电商项目v1.0版本，内测版本，任何一个公司，做任何一个产品，v1.0版本，一定都是内测版本，不对外开放的，仅仅供自己内部人员，加上邀请的少量的用户，比如就100个用户，来内测，来尝试使用以下，看整体感觉怎么样。在内测的同时，就会开始启动v1.1，v1.2，v1.3，v1.4，v1.5 -> 快速的迭代需求，直到需求功能，可以初步商用，可以cover住用户的需求。此时可能到了v1.8.5版本，此时对方开放。 

需求评审，我们一块儿一块儿的来看，每块需求，我们作为技术负责人的角度，仔细去审查，看需求是否有不靠谱的地方，赶紧让PM修改需求。 

在需求评审的时候，你基本上要确保说，这个需求脑子里都知道，技术上实现，应该怎么来做 

我带着大家来做需求评审，直接展现出的是我真正在需求评审的时候，作为架构师而言，你整个思考的一个过程 

假设，之前需求文档是我自己写的，我自己不是专业的产品经理，假设我自己之前就是扮演了一个不靠谱的产品经理的角色，我自己又是一个架构师的角色，我来抨击我自己写的产品需求文档

### 53_需求评审：考虑清楚如何对商品数据进行管理

简单回归了一下电商购物的黄金链路 

（1）权限中心

（2）商品中心

### 54_需求评审：看看采购流程有没有什么问题

### 55_需求评审：看看购物流程中的前台商品浏览有没有什么问题

### 56_需求评审：看看购物流程中的下单支付有没有什么问题

### 57_需求评审：看看购物流程中的销售出库有没有什么问题

### 58_需求评审：看看退货流程有没有什么问题

### 59_需求评审：看看促销中心的需求有没有什么问题

### 60_需求评审：看看会员中心的需求有没有什么问题

### 61_需求评审：看看评论中心的需求有没有什么问题

### 62_码云的使用以及文档的在线编辑和管理

### 63_需求分析文档：完成功能结构图以及系统功能描述的编写

#### 1.引言 

##### 1.1 编写目的 

需求分析文档用于对电商系统v1.0的需求文档进行分析，然后站在架构师的角度，去梳理清楚整个系统的功能组成以及业务流程。主要关注的点还是在业务层面，暂时不会考虑过多的技术。但是也还是会从技术层面去进行一些考量。 

##### 1.2 面向对象 

该文档编写出来以后，面向的主要是技术团队的同学，包括架构师、高级工程师、初中级工程师。 

##### 1.3 参考文档 

1、《电商系统v1.0产品需求文档》，具体参加项目附件 

#### 2.概述 

##### 2.1 开发意图 

该电商系统完成开发之后主要针对下面的3个场景： 

1、可以对商品的采购和仓储进行管理，让公司可以采购商品到对应的仓库中去<br/>

2、可以对所有的商品、会员、订单、支付、评论、促销等各种电商网站的核心功能进行管理<br/>

3、可以让电商网站的用户来网站中浏览和购买商品<br/>

##### 2.2 功能结构图 

[电商系统v1.0功能结构图]() 

##### 2.3 功能简介 

###### 2.3.1 权限中心 

主要是对电商系统的使用权限进行控制的，可以给每个电商公司的工作人员分配一个账号，接着给每个账号分配一个角色，每个角色可以分配一些权限。每个权限就代表了一个菜单、一个按钮、一个URL，控制公司里不同部门不同岗位的工作人员只能使用电商系统中一部分的功能，跟他的岗位相关的这些功能。 

2.3.1.1 权限管理 

对电商系统里的权限数据进行维护和管理 

2.3.1.2 角色管理 

对电商系统里的角色数据进行维护和管理 

2.3.1.3 账号管理 

对电商系统里的账号数据进行维护和管理 

2.3.1.4 权限控制 

对电商系统里的左侧菜单栏的展示，以及每个后台界面中的按钮的显示，URL请求访问，进行权限的控制 

###### 2.3.2 商品中心 

主要就是负责对电商网站中的商品数据进行相关的维护和管理，有了商品数据之后，我们才可以执行后台仓库的商品采购，包括将商品数据提供出去给前台的页面展示，让用户来浏览商品和查看。 

2.3.2.1 属性管理 

可以管理商品的属性数据 

2.3.2.2 类目管理 

可以管理商品的类目数据 

2.3.2.3 品牌管理 

可以管理商品的品牌数据 

2.3.2.4 商品管理 

可以管理商品的商品本身的数据 

###### 2.3.3 采购中心 

负责维护供应商的数据，还有就是负责维护采购单的数据，可以创建采购单将我们需要的商品采购入库 

2.3.3.1 供应商管理 

主要就是维护和管理供应商的数据和绩效 

2.3.3.2 采购单管理 

主要是可以进行采购开单，开单之后就可以发送采购单给供应商来采购商品到我们的仓库中去 

###### 2.3.4 WMS 

负责仓库管理，包括了仓库的基础数据的管理（仓库信息和货位信息），采购入库、销售出库、退货入库、仓库库存的管理 

2.3.4.1 仓库信息管理 

负责管理仓库的相关数据 

2.3.4.2 货位信息管理 

负责管理仓库中的货位相关的数据 

2.3.4.3 采购入库单管理 

采购开单之后，会同步采购入库单到这里来，在接收到供应商的发货之后，需要去维护采购入库单 

2.3.4.4 销售出库单管理 

用户下订单支付之后，就会同步一个销售出库单过来，在接收到这个单子之后，需要去将订单中的商品进行出库发货 

2.3.4.5 退货入库单管理 

用户申请退货，并且寄还商品到客服中心之后，会启动退货入库的流程 

2.3.4.6 仓库库存管理 

对仓库中的每个商品的库存，以及每个货位中每个商品的库存，进行管理 

###### 2.3.5 会员中心 

2.3.5.1 会员注册 

支持用户基于手机号直接进行注册 

2.3.5.2 会员登录 

支持基于之前注册的账号来登录，或者是基于微信等第三方方式来登录 

2.3.5.3 会员个人信息 

可以查看和设置会员的个人信息 

2.3.5.4 会员等级管理 

可以根据会员在网站中的不同操作，完成会员成长值的增减，同时完成维护会员的等级，完成维护会员成长值变更的明细 

2.3.5.5 会员积分管理 

可以根据会员在网站中的不同操作，完成会员积分的增减，同时完成维护会员的积分增加明细 

###### 2.3.6 商品展示 

2.3.6.1 商品搜索 

可以在网站的首页对商品执行搜索操作 

2.3.6.2 品类导航 

可以在网站的首页对品类进行导航 

2.3.6.3 商品列表页 

搜索商品，或者是品类导航，都会进入商品列表页 

2.3.6.4 商品详情页 

对商品列表页中的每个商品，都可以进入一个商品详情页 

###### 2.3.7 购物车 

2.3.7.1 加入购物车 

在商品详情页，可以点击加入购物车的按钮，将商品加入购物车中 

2.3.7.2 查看购物车 

查看购物车中的商品情况，可以选择一些商品去下订单 

2.3.7.3 购物车结算 

在购物车中选择了一些商品之后，就可以点击购物车结算按钮，进入订单确认页面 

###### 2.3.8 订单中心 

2.3.8.1 生成订单 

在订单确认页中完成订单确认之后，可以提交订单 

2.3.8.2 订单列表 

用户可以在订单列表页中查看自己的订单 

2.3.8.3 订单详情 

用户在订单列表页中选择某个订单，可以查看订单的详细信息 

2.3.8.4 取消订单 

用户可以选择手动取消某个未付款的订单，同时也可以由系统在24小时之后启动取消这个未付款的订单 

2.3.8.5 订单支付 

用户可以选择为这个订单支付对应的金额 

2.3.8.6 更新订单状态 

在对应的一些操作发生的时候，会来更新订单的状态 

2.3.8.7 查看物流进度 

用户在付款之后，可以查看物流的进度 

2.3.8.8 确认收货 

用户在收到货品之后，可以手动点击确认收货，也可以等待7天之后由系统自动确认收货 

2.3.8.9 申请退货 

用户在收到商品之后，如果不满意可以申请退货 

2.3.8.10 价格计算 

在订单的确认页面中，会根据订单的总金额，每个商品使用的促销活动，对订单使用的优惠券，运费，去计算出来订单最后的一个总金额 

###### 2.3.9 支付中心 

2.3.9.1 对接第三方支付 

在用户支付订单的时候，可以对接微信/支付宝来支付 

2.3.9.2 支付交易流水管理 

每次用户支付的时候，都需要去插入一笔交易流水，可以让后台管理人员查看交易的流水 

###### 2.3.10 物流中心 

2.3.10.1 运费模板管理 

每个商品都会关联一个运费模板 

2.3.10.2 运费计算 

在用户购买商品的时候，会根据这个运费模板去计算运费 

2.3.10.3 获取物流单 

在用户支付之后，调度中心调度发货的时候，会对这个订单跟物流中心通信，要求跟第三方物流商系统通信，申请一个物流单号 

2.3.10.4 物流追踪 

用户支付之后，可以查看物流的进度 

###### 2.3.11 评论中心 

2.3.11.1 发表评论 

用户购买商品之后，可以手动发表评论，也可以由系统在30天之后自动发表评论 

2.3.11.2 评论管理 

管理员可以在后台对评论进行一个审核和管理 

2.3.11.3 评论前台展示 

在商品详情页中，会展示所有的评论 

###### 2.3.12 促销中心 

2.3.12.1 促销活动管理 

可以管理电商网站中的促销活动的数据 

2.3.12.2 优惠券管理 

可以管理电商网站中的优惠券的数据 

###### 2.3.13 客服中心 

2.3.13.1 退货工单管理 

在用户申请退货的时候，由客服去管理对应的退货工单 

###### 2.3.14 财务中心 

2.3.14.1 采购结算单管理 

在采购入库完成之后，会有一个采购结算单，可以管理这块东西 

2.3.14.2 供应商结算管理 

在采购结算单完成审核之后，会周期性的给供应商打款结算 

2.3.14.3 物流公司打款管理 

在销售的时候，完成销售出库了，需要给物流公司打款 

2.3.14.4 退货打款管理 

在用户申请退货之后，并且将商品寄送到客服中心之后，会进行退货打款 

2.3.15 调度中心 

负责将采购入库、销售出库、退货入库，调度到仓库中去执行 

2.3.16 库存中心 

负责管理商品的库存

01_电商系统v1.0功能结构图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6301.png) 

### 64_需求分析文档：完成用例图的绘制以及核心用例的泳道图绘制

### 65_需求分析文档：完成核心领域类图的绘制

### 66_概要设计文档：完成逻辑架构图的设计与绘制

我们考虑一下，在阶段一中，实际上我们的逻辑架构师非常非常的简单的，为什么呢？因为我们刚开始，为了保证开发效率，不希望耗费太多的时间在复杂的技术架构上，通常我们对第一个版本，会采取比较low的一个技术架构去做，其实任何一个系统，如果不考虑面临的技术难题，其实都是CRUD。 

代表了IT信息系统，基本上全都是CRUD。 

我们的第一个版本，就采取最原始，最普通，最low的架构去做，但是这样可以保证任何一个系统从0到1的时候，有最快的开发速度。 

为什么我要给大家从0开始演示，让大家看到系统架构不断迭代和演进的一个过程。因为我告诉大家一点，架构师容易犯的一个错误，就是所谓的过度设计！就是说，你还没有面临这个技术难题的时候，就胡乱的采用一些复杂的技术架构去做，这样是不对的。 

任何一个系统刚刚开始，从0起步，都是要快速做出来，出东西，此时速度是第一位的，技术可以很low，但是必须很快。所以此时没有必要设计复杂的架构的。 

但是第一个版本最low的版本快速做出来以后，后面，你作为一个有追求的架构师，必须得不断的将这个架构做的越来越复杂。旱地拔葱，哪怕这个系统没有经历什么挑战，但是你也必须给自己设想，我的系统就是有这个挑战，然后我要不断的演进这个架构去解决很多潜在的还没有发生的挑战，高并发、高可用、高性能，等等。。。 

这样，你的架构和技术能力才能提高，你团队里的弟兄才能学到东西，才愿意跟着你干。 

因为你的第一个版本已经快速出了东西出来了，后面你可以放心大胆的去做技术架构的事情了。你刚开始，都是0，什么都没有，你还瞎搞技术架构，复杂的东西，导致你从0到1的一个版本，做的很慢。 

不合格的架构师！！！ 

淘宝、京东、京东手机app后台架构、微信、美团外卖、滴滴，很多知名大公司，刚开始的时候，都是用最普通，最简单的系统架构去做，其实他们刚开始的架构基本上就跟我们现在的这个架构是一样的。为了快，产品，推广，用户起来，业务起来，访问量越来越大，数据量越来越大，系统经常挂大，面临的技术问题越来越多了，快速的系统架构的迭代和演进。 

下面，我这一讲，就带着大家来把比较low的架构，给做出来

01_逻辑架构图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6601.png) 

### 67_概要设计文档：完成运行架构图的设计与绘制

02_采购流程时序图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6701.png)  

 03_购物流程时序图

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6702.png)

 04_退货流程时序图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6703.png) 

### 68_概要设计文档：完成物理架构图的设计与绘制

05_软件架构图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6801.png) 

06_开发环境配置图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6802.png) 

07_集成测试环境配置图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6803.png) 

 08_系统测试环境配置图

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6804.png) 

09_验收测试环境配置图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6805.png) 

10_线上环境配置图 

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\6806.png)

### 69_概要设计文档：让其他部门架构师来进行技术评审

### 70_详细设计文档：完成权限中心的详细设计（一）

### 71_详细设计文档：完成权限中心的详细设计（二）

### 72_详细设计文档：完成权限中心的详细设计（三）

01_权限中心实现类图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\7201.png)

### 73_详细设计文档：完成商品中心的详细设计（一）

### 74_详细设计文档：完成商品中心的详细设计（二）

### 75_详细设计文档：完成商品中心的详细设计（三）

### 76_详细设计文档：完成商品中心的详细设计（四）

### 77_详细设计文档：完成商品中心的详细设计（五）

01_商品中心实现类图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\7701.png) 

### 78_详细设计文档：完成采购中心的详细设计（一）

### 79_详细设计文档：完成采购中心的详细设计（二）

### 80_详细设计文档：完成WMS中心的详细设计（一）

01_审核采购入库单活动图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\8001.png) 

02_WMS中心实现类图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\8002.png) 

### 81_详细设计文档：完成会员中心的详细设计（一）

### 82_详细设计文档：完成会员中心的详细设计（二）

01_会员中心实现类图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\8201.png) 

### 83_详细设计文档：完成购物车的详细设计（一）

### 84_详细设计文档：完成支付中心的详细设计（一）  

### 85_详细设计文档：完成订单中心的详细设计（一）

### 86_详细设计文档：完成订单中心的详细设计（二）

### 87_详细设计文档：完成订单中心的详细设计（三）

01_订单中心实现类图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\8701.png) 

### 88_详细设计文档：完成物流中心的详细设计（一）

### 89_详细设计文档：完成评论中心的详细设计（一）

### 90_详细设计文档：完成促销中心的详细设计（一） 

### 91_详细设计文档：完成促销中心的详细设计（二）

### 92_详细设计文档：完成客服中心的详细设计（一）

### 93_详细设计文档：完成财务中心的详细设计（一）

### 94_详细设计文档：完成库存中心的详细设计（一）

### 95_详细设计文档：完成调度中心的详细设计（一）

### 96_详细设计文档：完成WMS中心的详细设计（二）

### 97_详细设计文档：梳理系统运行流程来完善和补充接口设计

### 98_详细设计文档：分析各业务特点来完善和补充设计模式的应用

### 99_详细设计文档：为核心的复杂业务流程补充更多活动图 

01_调度销售出库流程活动图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\9901.png) 

02_支付订单流程活动图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\9902.png) 

03_退货入库单审核流程活动图 

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\9903.png) 

### 100_完成各个中心的详细设计文档的评审

### 101_项目管理计划（一）：编写活动清单

我们假设，我们现在开始创业，是做某个垂直领域的电商网站

如果你现在还想着去做一个京东，淘宝，找死，真实，细分领域的小电商，拼多多，小红书，花卷，慢慢开始做 

v1.0版本，就是一个雏形版，连内测版可能都谈不上；先出来一个东西，我们可以看看，用一用；快速的对v1.0版本进行迭代，v1.1，v1.2，v1.3，累加更多的功能，完善业务流程；可能到v1.8开始开放内测，邀请一些亲朋好友来使用；v1.9.1版本，正式电商系统对外开放。这个一个思路 

你是一个架构师，你的身份，也是一个这个垂直电商网站的后端技术负责人的这么一个身份，你之前的一个背景，就是10年工作经验，BAT等多家大公司的工作经历背景。目前手下带着4个小弟。 

2个高工，工作5年左右；2个中级工程师，工作3年左右 

目前初期的一个思路，就是你一个架构师直接带所有的人，高工不带人，所有人直接归你来管。一般来说，是到7人以上，你会拆分小团队；拆分成两个小team，每个高工带2个人。这么一个思路。 

后端团队的技术负责人，你也得coding，你除了负责设计架构，你也得写代码 

5个人可以写代码 

给你自己起一个名字：老K 

2个高工：老A，老B 

2个中级工程师：小C，小D 

这里的开发排期，都是包含了每个模块的编码+单元测试+冒烟测试 

并不是说是我们课程里就要开发22个人日，而且我还是一个人分饰5个角色，22 * 5 = 110个工作人。 

就是说，我们自己来想象，你在公司里，每天你工作，其实你用来写代码的时间就有限的，你可能到了公司，要参加会议，汇报，整理思绪，中午还要吃饭，午睡，有的时候状态可能还不是很好。9点到公司，12点吃饭，3小时 -> 1小时；2点，6点，4小时 -> 2小时。人这样干一天，到这个情况下，就差不多了，你的精力已经耗费的差不多了。 

7点30，你再干活儿吗？开会，累，你最后梳理一下最后的一些事儿，差不多就回家了，也许还能最多再干1小时。 

从早上9点，到晚上9点30回家，中间实际上能用来开发的有效时间，可能也就4个小时左右。 

但是，实际上来说，我讲课，第一，对我来说，这些东西写代码都很简单；第二，我本身写代码就很快，当年长时间徒手写代码，直接用命令行，基本的编辑器去写代码，锻炼出来的；我录制课程的时候，比如说我在周六一天，从早上9点录制到晚上9点半，可能时间都是实打实的，没有人和其他的事情来干扰我的。 

4小时，10小时，2.5~3倍，3倍来算 -> 110 -> 35个工作日 -> 写代码的效率和速度，3倍 -> 10~12个工作日，两周的时间，就差不多可以搞定了。

### 102_项目管理计划（二）：绘制网络图

### 103_项目管理计划（三）：绘制甘特图

### 104_项目管理计划（四）：绘制资源配置表 

#### 00_需求评审规范

##### 01_需求评审规范 

1、需求是否足够清晰 

要判断这个需求，你看了以后，是否脑子里能完全展现出来整体的图，就是包括界面是怎么操作的，在界面上用户的操作流程是什么样子的？每一步操作，要显示什么表单、什么表格？查询条件的默认值？是否要分页？ 

原则，你必须要看了需求以后，脑子里直接出来一个产品的界面操作图，然后后台系统的一些流程，在你架构师的脑子里，基本都出来了。 

不一定说一些很年轻的同学，一下子就能做到这一点，这是需要至少好几年的开发功力，有足够的经验 

2、对需求中不合理的地方提出改进建议 

查询菜单，是默认就查询两级，或者是三级，但是我们考虑到了可能有的菜单是三级的，你要是就查询两级，就不对了。产品设计就错了。 

思考说，按照这个需求去走，以后一些特殊的场景，会否导致需求和系统开发要全盘推翻，重新去做。需求流程是否合理。 

3、对不需要做的需求提议砍掉 

有些需求，在当前这个版本特殊的背景下，可能是不需要的，我们要去考虑说，是否建议放到下一个版本去做。我们有权利提议砍掉一些需求，集中力量干大事儿。

#### 01_系统开发规范

##### 00_系统开发流程

01_系统开发流程

（1）业务调研：产品经理搞明白需求是什么1627098499

（2）需求分析：我们去分析产品经理给的需求文档，梳理出系统要干嘛

（3）概要设计：作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构

（4）概要设计评审：找其他部门的架构师来帮忙评审一下我们的架构方案

（5）详细设计：指导团队里的各个同学，自己对自己负责的部分进行详细设计，数据库建模、接口设计、类设计、包设计、功能流程设计、单元测试设计、冒烟测试设计、日志设计

（6）详细设计评审：我们作为架构师要仔细去看一下各个同学的详细设计，确保没问题

（7）工程初始化：指派多个同学，完成所有的初始化的一些事情

（8）版本控制：明确如何对代码进行版本控制，工作流是什么

（9）编码开发：根据阿里的开发规范，写代码即可

（10）单元测试：自己写所有的单元测试，测试每一个类

（11）冒烟测试：自己对负责的系统跑起来，冒烟测一下核心功能

（12）静态代码扫描：确保自己的代码符合规范

（13）代码审查：由高级别的人去审查自己的代码

（14）集成测试：所有环节集成在一起，确保系统整体流程炮通

（15）系统测试：QA来严格测试每个功能

（16）验收测试：PM验收系统

（17）系统上线：按照严格的步骤去执行上线
（18）线上运维：按照标准化的流程去处理线上的bug

##### 01_需求分析规范

需求分析规范  

附加一点说明 

一定要懂得灵活变通，需求分析文档本质，其实就是我们之前需求评审，只是看到了PM写出来的一份产品设计文档。你看到的那份需求文档，实际上是我写的，我不是专业的PM，我很多时候还是技术人员的角度和思维，去写的那份需求文档。 

PM是一点技术都不懂的，跟我写的应该是不太一样的，一般来说PM写的产品需求文档，很多细节都是没有的，很多细节是比较模糊的，他不懂底层系统的一些运行流程什么的，他就是站在一个纯小白，纯用户的角度去考虑这个系统产品应该如何设计。 

那么如果说是上面说的那样的一种情况，那么需求分析文档，是必写。站在架构师的角度去分析那份需求文档，从需求文档中抽取出来对应的核心需求，考虑清楚我们的系统为了要实现所有的需求，我们要实现哪些功能。 

需求文档的本质，就是考虑清楚系统有哪些功能。这就是本质。 

另外说一点点变通，如果是项目进度很紧张，如果那个产品需求文档写的很清晰，碰到了一个很专业的很好的PM，写出来的产品需求文档就是很清晰，条理清晰，细节重试，流程清晰，那么可以考虑说，这个需求分析文档，不写也可以的。 

1、引言

1.1 编写目的

表明这份需求分析文档的核心目的是什么，比如说是用来定义系统的核心功能的，指导后续的系统设计的

1.2 面向对象

该文档编写出来之后，是要给谁看的？其实主要是给RD看的，让工程师明白系统要做哪些东西

1.3 参考文档

（1）《电商系统v1.0需求文档》 

2、概述

2.1 开发意图

描述清楚咱们这个系统开发出来是用来干嘛的，主要的作用是什么 

2.2 功能结构图

功能结构图，主要是给人一目了然的看到这个系统需要包含哪些子系统，每个子系统包含哪些模块，每个模块包含哪些功能，同时对每个子系统以及其模块进行简单的介绍。功能结构图只是一个静态的这么一个东西。

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0401.gif)

2.3 功能简介

2.3.1 XX子系统

XX子系统主要是用来干什么的

2.3.1.1 模块1

模块1主要是用来干什么的

2.3.1.2 模块2

模块2是用来干什么的 

2.3.2 XX子系统

3、用例图

用例图其实也是用来描述一个系统的这么一个功能的，但是他的意义不太一样，我们从另外一个角度来看一下这个系统的功能。他是每个子系统画一张用例图，这张用例图可能会很大。这个用例图最关键的一点是，强调出来系统的功能，但是同时要强调出来，是哪些参与者跟这些功能在交互。 

举个例子，比如说商品中心，商品部门的运营专员，他会负责去使用这个新增商品这个用例，其实这里要体现出来，就是时候每个参与者跟每个用例的关系，每个用例就是对应着一个功能。同时这个参与者可能不是一个人，可能是外部的其他系统，比如说订单中心的更新订单状态的这么一个用例，可能是WMS系统是一个参与者，调用了更新订单状态的这么一个用例。 

用例图，是在功能结构图基础之上， 再从另外一个角度来描述这个系统的功能，也就是说描述清楚哪些参与者跟哪些用例有关系。

3.1 XX子系统 

每个子系统是一张用例图，一张用例图中包含了很多个用例 

3.1.1 功能概述 

说一下XX子系统的功能大概是干嘛的，这里可以说一下，这个子系统是干嘛的，里面包含了哪些模块 

3.1.2 用例图

对于这个画用例图，我从实践的角度给大家一点建议，首先就是，一定要记住一点，就是对你要做的任何事情看透背后的本质，明白你做这个事情是要干嘛，产生什么价值和作用的？ 

其次，在明白了你要干的事情本质的基础之上，你可以对做这个事情的方法，做一些变通。 

一般情况下，我们正常而言，一个用例就是一个单独的一个功能。但是，我们发现自己的系统中，有很多是CRUD类的用例，对某个数据列表、新增、删除、修改、启用/停用，基本就是这么些东西，或者是加上一些提交审核、审核。然后他的话呢就是有很多的重复性的东西。特别的琐碎。 

再加上我们的系统比较庞大的，包含了16个中心，几十个模块，几百个功能。如果你每个中心去画一个用例图，每个中心可能都是几十个功能，那个用例图看起来会特别的庞杂无序。 

这里我们来思考一下，我们画用例图的本质是为了什么？为了体现出系统中的一些功能跟参与者的一个关系，就可以了。 

所以说，如果是这样子的话，我们可以考虑在画用例图的时候，可以考虑将一个模块作为一个用例，也是可以的，看透背后的本质，不要拘泥于固定的形式，一定要懂得变通。画出来这个子系统中，参与者跟模块用例之间的一个关系即可。如果以后觉得有时间了，一定要做一些扩展的话，可以考虑采用包含关系，去画出来一个模块用例里面包含的一些功能用例。

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0402.gif) 

一般情况下，为了简化起见，可以就只是画关联关系就可以了，表明哪些参与者会去执行哪些用例 

包含关闭、扩展关系，会相对增加复杂性，可以将那些太细的一些用例不画在里面了 

3.1.3 用例描述

用例描述这块是这样，如果是系统很大，时间比较着急，同时的话呢某个用例功能对应的流程不是特别的复杂，而且呢，在需求文档里，如果对这个功能的使用流程有了较为详细的说明，我们可以简化，不在这里对每个功能，每个用例，做过于详细的描述 

不然的话，相当于是再把需求文档里的东西给全部重新写了一遍，那样的话就比较坑爹了

但是这里需要写明，可以参考需求文档中的功能描述以及功能运行流程 

什么情况下，需要对这个用例进行详细的描述呢？如果某个用例，他压根儿就不是产品需求文档里提到的，比如说你自己想到的系统应该做的某个事情，采购入库单的校验，采购入库单备份看，有些用例可能是会在需求分析的过程中，自己站在架构师的角度，初步加入了一些额外的系统层面的功能。那么这种你肯定就是要详细描述用例的。 

另外一个，对于一些核心的，重要的功能，要求必须是得写详细的用例描述。常见于某个功能有较为复杂的流程，比如说我们后面的那个调度销售出库，这个用例，他的流程就较为复杂，要跟其他的系统做一些交互，可能光靠需求文档中的描述，不一定特别的清晰。需要我们架构师去对核心重要的功能，包含了复杂的业务流程，去要做详细的描述，画清楚他的泳道图。 

但是对于一些CRUD类的一些功能，可能就不需要了。一定要懂得变通，不要认死理，不要认死法。

3.1.3.1 用例1描述 

（1）简要说明 

这个用例对应的功能是干嘛的 

比如说，新建订单用例主要是用户在购物车中，可以对要下单的商品进行选择，同时选择要使用的优惠，在订单计算出来金额之后，确定提交订单 

（2）事件流 

在执行这个用例的时候，需要执行哪些操作和步骤 

步骤1：选择要订购的商品

步骤2：对商品的库存进行校验

步骤3：选择这个订单要使用的优惠是什么

步骤4：计算出来订单的最终金额

步骤5：点击确认提交订单

步骤6：生成订单 

（3）事件流图（processon画泳道图） 

将上面写好的事件流画成事件流图，一般用泳道图来表示

 ![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0403.gif)

3.1.3.2 用例2描述 

3.1.3.3 用例3描述 

4、领域类图 

领域类图，一般就是从系统间的调用和流转，使用的核心数据类 

订单类，就是一个典型的领域类 

一般来说，领域类如何抽象，其实就是将需求文档中比较核心的那些数据抽象成领域类，比如订单，库存调拨单，出库单，入库单 

这边是可以将一个较为复杂的领域类图拆分为多个领域类，比如说订单主信息，订单项信息，订单优惠信息 

还是这个从实践中来，如果说希望加快项目的进度，不要在写文档上耗费过多的时间，领域类图有一个实践，就是只要将核心的领域类与领域类之间的关系画出来就可以了，不需要给出这个领域类的字段。因为可能需求文档中已经将领域类的字段基本都给出来了。不需要再这个环节去确认这个字段。只是确认系统里核心的一些领域类。具体的字段可以参考需求文档。 

在这个环节，要不要做的很仔细，考虑如何将一个领域类，比如说，商品领域类，拆分成商品基础信息，商品价格信息，一般建议不需要，因为这个环节里，主要还是面向需求的。 

领域类图将每个子系统中，核心的领域数据，描述出来，让我们看一眼大概知道即可

4.1 XX子系统

public：+

private：-

protected：#

package：~

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0404.gif) 

##### 02_系统设计规范

###### 01_概要设计规范

1、引言

1.1 编写目的

1.2 面向对象

1.3 参考文档

2、逻辑架构

采用技术栈架构，包含业务架构，以及系统整体技术架构

2.1 逻辑架构图

没有固定的格式，将整体技术架构画清楚即可 

逻辑架构图，是在正儿八经做系统设计的时候，必须要画的第一张图，这张图必须得有，必须得有。这个图应该也是整套系统最最重要的一张图，直接就是体现了整套系统静态层面看起来长什么样子的。

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0405.gif)

2.2 设计细节

对架构设计中各个环节进行必要的文字说明

3、运行架构

3.1 系统核心流程时序图

将系统整体的各个核心流程的时序图画出来，子系统之间的交互就很清楚了，要求粒度到每一个用例级别，每个子系统的用例都要在时序图上有所体现 

整体的一个思路是什么呢？将系统的所有核心流程，一个一个的在这里用时序图表现出来，这个图里就涉及到了各个子系统在核心流程中会干什么，会负责什么事情，如何将多个子系统串联起来实现整个电商的一个核心的业务流程 

生命线、激活、消息 

这边多提一句，其实大家回忆一下，我们之前第三个课程，电商业务需求分析那个课程，我们一边分析业务，一边就自己写了产品需求文档出来。在那里，我们其实就重点画了三个电商系统v1.0版本的核心流程：采购、购物、退货。那3个流程，其实我们基本上多画了流程图出来，但是不是标准的时序图啊。 

然后另外，我要给大家说的一点是，在普通的PM设计的产品需求文档里，他绝对不会给你那么详细的可以落地的这么一份业务流程设计图。可能他们会画一些图，这个图不一定很详细，就是大概给你看看的。 

在这种情况下，PM这么搞，我们就必须得在概要设计的环节，将运行架构图给画出来，站在我们技术人员的角度，画一个详细的可以落地的清晰的这么一个时序图。 

但是我这里说一点，因为之前的产品设计文档，是我自己写的，我在进行产品需求设计的时候，就已经有点儿站在架构师的角度去考虑问题了，所以我觉得我画的3个核心流程的图，其实是比较清晰可以落地的这么一个图。 

对于那几个图，严格意义上来说，几乎都可以当做我们系统的运行流程图了。可以直接拷贝过来放在我们的这个概要设计文档的运行架构中了。但是，因为要求的标准，必须得在这里画这个时序图，所以说，我们还是得参照那3个图，将3个核心流程，给画成标准的时序图。

3.1.1 系统核心流程1时序图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0406.gif)

3.1.2 系统核心流程2时序图

3.2 XX子系统

这块是这样子的，如果你觉得有些功能，特别复杂，流程也很复杂，那么可以在这里就是对部分核心功能的运行流程，站在技术的角度，去给他画一张时序图出来，画的比较详细。而且流程结合了一些你的特殊的技术设计，重要的核心的功能，还是建议在这里画一些。 

但是，如果说你已经把系统运行的核心流程的时序图给画出来了，那是个必不可少的，必画。但是具体的一些功能的运行流程，在这个地方，如果你觉得大体上跟之前的需求文档是差不多的，你可以不画。

3.2.1 XX模块

3.2.1.1 XX功能1时序图

对上面的核心流程时序图中的每个用例，都画出来具体的每个用例的时序图

3.2.1.2 XX功能2时序图

4、物理架构

4.1 软件架构（组件图）

子系统以及各个基础设施的交互

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0407.gif)

4.2 硬件架构（配置图） 

具体的各个环境的系统以及基础设施的物理部署 

4.2.1 开发环境硬件架构

4.2.2 集成测试环境的硬件架构

4.2.3 系统测试环境的硬件架构

4.2.4 验收测试环境的硬件架构

4.2.5 线上环境的硬件架构

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0408.gif) 

###### 02_概要设计评审规范

1、要评审的一些点

负责评审的同学，需要对架构设计方案，从以下的角度考虑： 

（1）并发性：考量一下，现有的系统架构，能支撑多高的并发，如果说未来并发持续上升的话，这套架构会不会扛不住

（2）伸缩性：考量一下，如果未来系统架构撑不住并发量了 ，现有的这套系统架构，是否是可伸缩的，就是能否在需要的时候，通过加机器，扩容，来增强它能抗住的并发量

（3）可用性：现有的这套系统架构，是否可能会出现不可用的情况，比如说某个外部依赖挂掉了，或者是流量激增，等等，会不会有哪些情况导致系统跨掉了

（4）扩展性：如果后续要对系统进行大量的迭代，快速的业务需求开发，大量的代码改动，现有的这套架构，能否支撑系统快速扩展

（5）安全性：现有系统架构，存在了哪些安全性的漏洞，是否可能被攻击，导致系统挂掉，是否可能导致系统的数据丢失

（6）性能：现有的系统架构，是否会在哪些地方出现性能的瓶颈，或者性能较差的一些情况

（7）稳定性：现有系统是否考虑到了日志、监控、线上问题的快速排查和处理、系统功能运转的一个稳定性 

2、要重点评审哪个部分 

概要设计文档里面，逻辑架构、运行架构、物理架构 

重点要考虑的，就是这个逻辑架构，因为这个逻辑架构就体现了所有的一切技术性的东西和设计 

要考虑一下，逻辑架构体现的技术架构中，是否有哪些缺陷和漏洞 

3、设计评审的记录

###### 03_详细设计规范

1、数据架构

1.1 数据库ER模型 

PowerDesigner ER建模 

数据库的ER建模，ER，Entity Relationship，实体关系，一个表就是一个实体，设计表与表之间的一个关系，也就是实体与实体之间的一个关系 

包括每个实体包含哪些属性，表包含了哪些字段 

一般就是根据需求分析以及概要设计中的内容来考量，就是说负责的这个模块，具体需要哪些数据库表去承载，才能实现出来 

将所有需要的表，全部在一张ER模型图中体现出来 

1.2 数据库逻辑模型 

PowerDesigner将ER模型转为逻辑模型 

1.2 数据库物理模型 

PowerDesigner将逻辑模型转为物理模型 

在正规的流程中，必须是对每个系统，都完成数据库ER模型之后，去完成后续的设计，包括接口、类图、运行流程，结合运行流程，你要执行哪些增删改查的操作，反过来完善物理模型的设计，包括索引、主外键关系 

但是我们这边说一个实践中可以权衡的这么一个方案，就是说，实现类图这一块，我们将增删改查的controller、service、dao、mappper，都没在类图中去设计。这个在实际开发中是可以的。 

所以这就导致我们没法在现在这个阶段，就直接完成索引的设计，因为包括mapper里面有哪些方法和sql都不太清楚，就可以在开发的过程中，一边开发，一边结合你写的sql来设计数据库的索引。 

然后在code review的时候，申请别人review一下索引的设计。

2、接口 

（1）DO：Data Object，数据对象，一个DO一般是对应于一张表，或者是Mapper查询接口中的返回类型，mapper和dao返回的都是DO

（2）DTO：Data Transfer Object，数据传输对象，service组件需要将dao组件返回的DO对象给封装成DTO对象，再返回给controller组件，或者是别的service组件。service必须将数据封装为DTO，返回给其他的controller或者是service来使用

（3）VO：view object，其实就是将页面中需要展示的数据封装在VO里面，然后在以前是将VO给传输给页面模板，比如JSP（JSTL标签语法，可以将VO中的数据给展示出来），freemarker，velocity，thymeleaf。restful接口，在接口中可以将一个接口要返回的数据，封装在VO里面，从接口返回即可。

（4）Query：查询条件，controller里面接收的页面发送过来的查条件，哪怕是service层对外暴露的接口，也可以用query来接收复杂的一些查询条件

（5）PO：就是将DO不是作为data object，而是作为domain object，然后将PO作为persistence object，一个PO对应一张表，DO就是我们平时放在domain包中的领域模型对象

（6）BO：service组件对外可以返回这个BO，这个BO的话呢是包含业务逻辑的，不光是包含一堆数据和getter和setter方法，还包括了这个很多的业务逻辑方法

（7）AO：application object，就是跟展示层相关的一些数据 

大家有没有发现迄今为止，我们耗费了大量的精力在设计这个接口文档。但是其实接口怎么设计，设计的怎么样，不是什么技术问题。接口只不过是两套系统之间互相交互的一个协议。 

所以，我是这么想的，如果咱们继续耗费大量的精力在接口设计这块，可能会导致我们的课程进度较为缓慢。学习的价值不是特别大。 

就是说，如果是那种面向前端的接口，controller里面的接口，我们就不在这里设计了。写很多json格式的输入和输出，很麻烦，耗费的时间太大了。咱们这块直接在详细设计这个环节给省略掉。当然了，如果你们做项目，一定要按照我之前几讲的示范，所有的接口都在详细设计文档里来写。 

但是我们这里，就是说对前端的接口，我们在这里不写了，后面写代码的时候，咱们直接就把接口定义出来，然后就直接写代码。 

但是，有一点很重要的是，这个模块与模块之间的交互的接口，比如说采购中心和调度中心之间的交互，都是需要依靠接口的，而且我们需要在整个工程初始化的时候，就将这个接口给定义出来。所以模块与模块之间的交互的接口，必须是要设计的。 

2.1 XX模块 

2.1.1 XX接口 

（1）接口类

（2）接口方法名称

（3）接口描述

（4）输入

（5）输出 

3、开发架构 

3.1 实现类图 

根据之前的需求分析文档、概要设计文档、数据库模型、接口，去考虑，实现接口的功能，需要哪些类，类与类之间的关系是什么，每个类有哪些成员变量，每个类有哪些方法 

在这里说明一点，这里其实就是所谓的Java面向对象编程的核心所在，这里其实是很体现一个工程师的水平的 

UML的类图里，其实就三点 

（1）把每个类都画出来

（2）类与类之间的继承关系画出来，实线+空心箭头

（3）接口实线关系，虚线+空心箭头

（4）依赖关系，虚线+简单箭头

（5）关联关系，实线+简单箭头

（6）组合关系，实心菱形+实线+简单箭头

（7）聚合关系，空心菱形+实线+简单箭头

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0409.gif) 

根据我的一个实践，我有这么一个经验，就是说如果要提高开发效率，在这个实现类图这个环节，可以做一定的简化。 

在一个普通的业务系统里面，一定是有一些最最基本和最最简单的CRUD，增删改查，如果是最普通的增删改查的操作，可以不用画这个实现类图。此时，就是对于这种CRUD的功能，只要有这个接口，运行流程，你知道基于设计好的数据库模型，可以实现就ok了。 

3.2 包设计 

在UML中有包图的概念，我在这里先补讲，我比较少用 

至少你要设计出来，你有哪些包，每个包下面有哪些类 

com.zhss.eshop.order.domain

com.zhss.eshop.order.controller

com.zhss.eshop.order.mapper

com.zhss.eshop.order.dao

com.zhss.eshop.order.service 

4、运行流程

如果是有较为复杂的业务流程，则必须画活动图

如果仅仅只是一些相对简单的CRUD，则文字描述清楚你的代码实现逻辑即可 

4.1 XX模块 

4.1.1 XX功能1 

每一个功能，参考之前概要设计中的每个功能的用例图，类图、数据库表，画出来这个活动图 

用例图，基本上还是重点在体现较为高层的系统功能的运行流程 

活动图，就要画出来，每个类和每个表之间的交互关系，完整体现出来你的功能要实现的时候，各个类以及表之间的交互顺序和逻辑

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0410.gif) 

4.1.2 XX功能2 

5、测试用例设计 

5.1 单元测试用例设计 

5.1.1 XX模块 

5.1.1.1 测试用例1 

对每个类设计对应的单元测试类，每个方法都要有单元测试的方法 

（1）数据准备

（2）输入

（3）输出

（3）资源清理 

5.1.1.2 测试用例2 

5.2 冒烟测试用例设计 

5.2.1 XX模块 

5.2.1.1 测试用例1 

（1）数据准备

（2）输入

（3）输出

（3）资源清理 

5.2.1.2 测试用例2 

6、日志设计 

6.1 XX模块 

6.1.1 XX功能 

（1）日志埋点1 

（2）日志埋点2

###### 04_详细设计评审规范 

每个人都完成各自的负责的子系统的详细设计之后，每个人各自要召开自己的详细设计评审会 

这个详细设计的评审，就不是从其他部门请来一些架构师来评审，人家精力有限，不会给你过那么细节的东西，概要设计评审的时候，给你看看主要的架构的设计 

详细设计，就落实到具体的细节的层面，主要是靠架构师来对自己的团队内的各个成员的详细设计来进行评审 

软件工程的所有的环节和步骤，都是有其对应的意义的，至少我讲的这个流程里是这样的。如果是那些比较老旧，虚头巴脑的一些东西，不好落地的，过于复杂一些东西，现在暂时这个阶段用不着的一些东西，我都没讲。 

概要设计 -> 架构师必备能力，设计出来一套系统长什么样子的，跑起来大概是什么样子的 

概要设计评审 -> 让前天team的架构师来把一下关，尽量避免你犯了什么大错 

详细设计 -> 是你手下的小弟必备的能力，小弟必须得去对自己负责的那个模块或者子系统，完成对应的一个详细设计。 

P7技术专家，架构师的角色，概要设计；P6高工，带1~3人的小团队，负责一个独立子系统的详细设计，也可能是某个子系统的概要设计；P5初中级的工程师，一般就是干活儿的主力，他们负责对某个小型子系统或者是子系统中的一些模块，完成对应的详细设计 

你必须强力push你手下的小弟，把系统设计的非常详细，参照我们的详细设计规范来。详细设计文档，需要详细到什么程度呢？照着文档就可以写代码。 

数据库、缓存、MQ -> 设计好；接口 -> 设计好；实现类图（面向对象设计的功底，设计模式运用的功底）-> 设计好；完成上面3个步骤之后，将每个功能的运行流程都设计出来，写一些文字，复杂的画一些活动图 

当然，如果你的小弟水平很low，可能刚开始还是得你自己来设计详细设计文档，让小弟参照着文档来做。但是你必须得培养小弟可以独立完成一些模块的详细设计。 

详细设计评审 -> 就是你作为架构师，你手下的小弟完成了所有的详细设计之后，你就需要开会，评审会议，你仔细看你每个小弟的设计文档，你需要结合着那个模块对应的业务需求，来仔细反复思考，他们的详细设计有没有什么地方会有问题的 

1、数据库设计的评审 

重点关注一下数据库设计的索引，索引要确保说未来系统中已有的和可能有的各种功能，都可以用到索引，不会出现全表扫描的情况 

索引设计要好好结合业务需求，去考虑如何建联合索引 

你要重点看一看数据库里面的索引设计 

我们在这里，因为是讲课，没必要将一些CRUD的一些东西讲的太细，可能耗时太长了，大量的时间可能带着大家在设计CRUD的一些东西 

所以说我这里之前给大家讲过了，就是我们对数据库设计这块，就给出了ER模型，数据库的物理设计，没搞，索引，主键，外键，还没弄。因为现阶段比较简单，所以我们可以到一边开发的时候，一边根据我们写了什么SQL，来现场设计和增加索引。 

但是在实际的项目中，必须要求你的小弟在这一块，在完成了数据库ER模型、接口、实现类、运行流程的设计之后，必须要结合自己要执行的SQL操作，完成数据库的物理索引的设计。

数据库的设计这块，一方面你是看一看表名、字段名的命名，备注，你是否看得懂；数据库ER实体之间的关系是否正确；数据库整个设计，凭自己的感觉去看看，有没有什么问题；看看每个表都建立了哪些索引，让召开评审的同学说一说每个索引的用处。 

2、接口设计的评审 

主要是要调用这个人的接口的调用方，要好好仔细看一下接口设计，确认一下接口设计能否满足自己的需求 

主要不是架构师看的，同一个团队内部有互相调用关系的几个同学，互相之间要去看看对方的接口设计，能否满足自己的需求。包括，针对前端的接口，需要前端同学过来参加这个评审，让前端看看这个接口能否满足他的需求 

我们之前为了讲课方便，所以对面向前端的接口，都没有设计，主要是面向前端的接口，大多数都是CRUD的一些操作，设计接口，需要耗费大量的精力来编写输入输出对的json格式。很麻烦，很浪费时间。 

但是，在实际的项目中，肯定是要求你手下的小弟，必须将所有的接口都给设计好的。然后让要调用他的接口的同学来评审，看接口是否ok 

3、开发架构的评审 

面向对象的类图的设计，好好考虑一下，面向对象做的怎么样，是否逻辑清晰，拆分合理，未来的可扩展性是否足够好 

设计模式，就体现在这里了，就类图设计里，看看有没有用合理的良好的设计模式，来进行面向对象的设计，保障代码有足够好的扩展性 

实现类图，你作为一个架构师，你需要去review你手下的小弟的类设计。 

（1）面向对象的设计 

也就是说，我们现在还都是一些比较简单的CRUD的一些操作，没有太多所谓的面向对象的设计，大多数可能给都是一些controller、service、dao、mapper的设计。 

但是到了我们课程的项目后期，大量的复杂技术架构出来，面向对象的设计，就很重要。 

如果这块没有做良好的面向对象的设计，最后写出来的代码基本上就是一坨屎。面向过程去设计，最后可能一个复杂的模块，就两三个类，每个类里面就几个方法，大量的业务逻辑耦合在了一个方法里面。最后一眼看过去，就是一个方法里面一坨屎。 

面向对象是很重要的，如果你设计的好的话，那么你的代码的结构是很清晰的，代码是面向对象的，比如老鹰类，翅膀类，鸟巢类，天空类 -> 老鹰类组合了翅膀类，基于翅膀类去飞，平时基于鸟巢类去休息，可以飞到天空类里面去 -> 老鹰类里面有十几个方法，飞，休息 

（2）设计模式的运用 

跟面向对象的设计有关系的，很多时候你为了面向对象去设计，让代码有清晰的结构，就可能会用这个设计模式。 

如果我们不用任何的设计模式，看起来就是一个类，这个类里有一堆的方法，每个方法有一堆恶心的逻辑。 

命令模式+模板方法模式+工厂方法模式，在对应的操作过来的时候，我们就是去找对应的工厂创建一个对应的库存更新命令出来，执行这个库存更新的命令，这个库存更新命令会按照模板方法定义的模板，来依次执行多个步骤逻辑 

我觉得很多同学所在的团队，或者是公司，哪怕有这一些流程，执行的也不一定很好。设计，不是写文档，设计就是设计，体现的是你的系统设计的功力，文档只不过记录设计的载体。不要说我在写文档，公司里有规范，我必须得写，硬生生凑一堆没有生气的死板的文档出来，这个文档都不好好写，就是满足公司的规范。 

你绝对是不可能成为一个架构师的，我这次讲解的这些流程，都是架构师必须要掌握的东西。而且大家要理解你做的每件事情背后的意义。 

实现类图的设计，我们之前做了一点简化，就是对于那些CRUD相关的，或者是业务逻辑相关的类，我们都没有去设计对应的类图。这个在实际的应用中，是可以接受的，哪怕是在公司的实际工作环境中，这个是ok的。controller -> service -> dao -> mapper。 

但是我们对那些重要的实现类图，体现出有一定面向对象设计含量的，和设计模式运用含量的相关的东西，我们都给出了实现了类图 

我们通常而言，建议说，对于CRUD，也可以设计类图，只不过是设计简单类图。但凡有一定复杂程度的业务流程和业务场景，建议给出详细的面向对象的设计类图；只要能用设计模式的，就给出设计模式的实现类图。 

4、活动图的评审 

仔细过一下，看看每个功能的活动图，里面逻辑是否准确 

实现类图和运行流程，是我在详细设计里面，最最最最重视的两块东西 

很多同学之前做详细设计，可能主要就是做数据库设计，接口设计 -> 恰恰相反，我不觉得这两块会有很大的问题，数据库设计和接口设计，重要 -> 这两块一般来说不是系统设计真正出问题的一个重灾区 

哪怕你手下的小弟写的有问题，数据库表设计的一塌糊涂，接口设计的一塌糊涂；一般来说都能给指正出来，让他去修改的 

很多公司，很多团队，尤其是一些中小型公司，创业型公司，流程和规范不完善的公司，他们做详细设计文档，只写数据库设计和接口设计 -> 类设计，运行流程的设计，基本是泛泛而过，或者根本就不做 

实现类图不设计，代码是一坨屎 -> 运行流程不设计，你的小弟的详细设计文档就是对你来说是个黑盒，你根本不知道他要写哪些类，这些类之间的协作和运行流程是什么 -> 可能会导致最后你的小弟写出来的代码跟你想象的不太一样 

运行流程不设计好的话，那么你作为一个架构师，根本是无法把控你的系统 

哪怕你的概要设计做的再好，根本没法落地，到你的小弟落地的时候，写一坨屎出来，最后功能可以跑通，但是他那个可悲的代码，完全没有办法呗别人理解。甚至可能他写出来的业务流程是错的。直到你集成测试，code review的时候，才会去发现。 

对那些重要的，复杂的流程，我要求必须是要活动图 

对于一些不复杂的流程，可以手写文字版本的运行流程就可以了 

但是对于一些核心的，复杂的，重要的业务流程，我们需要去画活动图，通过活动图体现出来一个正确的，清晰的系统运行的流程 

5、详细设计的重要性总结 

重中之重，一句话，你务必确保说，你作为一个架构师，看了你手下的小弟设计出来的详细设计文档，连你都知道怎么写代码，可能那个代码不用你去写，但是你看着这个文档，绝对知道怎么去写这个代码 

做到这个程度，详细设计文档就成功了 

6、测试用例的评审 

这块需要好好看一下，是否对每个类的每个方法都设计了单元测试。 

在项目初期，进度紧张，业务不是非常的复杂，技术架构不复杂的情况下，可以简略这块的设计，只要提一句，核心的类里面每个方法都要写单元测试就可以了。 

到了后期，做一些较为复杂的系统的时候，技术架构也比较复杂，测试用例，正例、反例、异常情况，都需要去设计 

7、日志的评审 

这块也要好好看一下，对系统各个可能出异常的地方，是否打印了异常日志以及案发现场的保护日志 

刚开始项目初期，进度紧张，系统不是特别复杂，提一句就可以了，在每个类的每个方法中，尽量自己捕获自己的异常，能自己处理的异常就自己处理，有异常就打印出异常相关的完整的日志，日志是帮助我们在处理线上报错和bug的时候排查问题的 

但是在系统后期，对于一些技术架构较为复杂的部分，都是需要去精心设计在什么地方打日志，每个日志包含什么内容的

##### 03_工程初始化规范

###### 01_工程初始化规范

1、每个人本地搭建好开发环境

（1）JDK

（2）开发IDE：eclipse、IntelliJ IDEA

（3）maven：配置nexus私服的地址，settings.xml

（4）git 

2、完成资源申请 

对你的技术架构中，所有需要使用的技术相关的资源进行申请 

如果是在大公司里面：需要跟对应的dba、redis运维团队、RabbitMQ运维团队，申请你需要使用的数据库、redis集群、RabbitMQ资源 

还有你的java服务需要部署的机器资源，也需要跟SRE（运维团队）来申请 

而且要申请好所有环境的资源 

（1）开发环境（dev）：在这个环境中，部署需要使用的mysql、redis、rabbitmq，等等，然后各个开发人员在自己本地，是直接连接统一的一个开发环境中的数据库、缓存、mq，来进行开发和测试的。单元测试，不跟外部依赖的基础设施打交道的；但是在本地冒烟测试，是需要将自己负责的程序跑起来，跟开发环境中的基础设施交互，确保主流程没问题 

（2）集成测试环境（beta）：在这个环境中，其实就是所有人对一个版本都开发好之后，需要进行联调，系统集成。将所有人负责的东西全部集成到一起，如果是单块应用，将每个人的代码分支全部集成到一个统一的分支上去，将那个分支上集成好的代码，部署到集成测试环境的机器上去，同时连的是集成测试环境中的数据库、缓存、MQ。集成测试，部署好之后，由QA来执行，有时候RD自己来做，要将整个系统的所有部分集成在一起，主流程，主功能，跑通。 

（3）系统测试环境（test）：在这个环境中，同样，是需要将集成好的代码，部署到系统测试环境中的机器上去，同时连的是系统测试环境中的数据库、缓存、MQ。主要就是测试工程师，QA介入，进行黑盒测试，他们会写各种测试用例，非常非常的细，这一步重点是测试系统的所有功能包括各个细节点，全部都正确。 

（4）验收测试环境（staging）：在这个环境中，尽量保证跟线上环境一致的情况。比如说mysql，主从架构；开发环境、集成测试环境、系统测试环境里，可能就是单实例mysql；在验收测试环境中，就需要根线上尽量保持一致，必然线上规划的是mysql一主三从的架构，在staging环境，可以简化为一主一从。在这一步的重点意义是，模拟线上环境，甚至有时候会将部分线上环境的数据，或者是请求流量，导入到这个环境中来。这一步重点是需求方来做验收，比如说产品经理，准备好一堆测试用例，在这个环境去使用你的系统，看是否正确 

（5）线上环境（prod）：线上环境，所有的基础设施全部按照规划好的线上环境配置来走 

可以看一下，这里各个环境的资源怎么申请，申请多少，怎么部署，是根据什么来的？ 

概要设计里面的物理架构：配置图，硬件层面去考虑，需要哪些机器，部署哪些基础设施，多少台机器，多少个集群，跨几个机房 

3、数据库初始化 

基于详细设计中的数据库建模，PowerDesigner，里面设计好了各种物理表结构，导出来一份SQL文件 

直接基于那份SQL文件，在开发环境中的数据库里，建好需要的库，初始化好所有的表结构
 4、 工程搭建 

一般会指定一个人，架构师，也可能是项目组中的其他人 

负责在自己本地的IDE中，建立好一个工程，对这个工程中完成系统需要的技术框架的整合（Spring Boot + Spring MVC + Spring + MyBatis） 

（1）maven的pom.xml中，引入所有的依赖

（2）对所有需要使用的技术，完成对应的配置，注解 / xml

（3）其他的工程结构，完成搭建：maven父子工程，maven pom.xml中配置跟nexus集成、用来打包的插件、用于单元测试的依赖、数据库连接池的依赖

（4）本地写一个最基本的测试代码，将框架技术的整合全部跑通：接收http请求 -> 插入数据库，读写redis，读写rabbitmq，单元测试，日志的本地打印 

5、代码上传到仓库 

负责搭建工程的那个哥儿们，将搭建好的工程代码，上传到GitLab的仓库中去 

项目组中其他的同学，就需要从GitLab中拉取代码下来，到自己本地，代码导入IDE中 

将负责搭建工程的那个哥儿们写好的那套测试代码，在本地运行一下，确保说，所有技术的整合以及运行全部能跑通

##### 04_版本控制规范

###### 01_版本控制规范

1、Git工作流 

初步定的是基于GitFlow工作流来做

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0411.gif)

（1）feature分支 

进入一个版本的开发之后，每个人自己拉对应的feature分支。feature分支的拉取，按照一个子系统一个feature分支；一个模块一个feature分支；一个需求一个feature分支；一个功能一个feature分支。不是固定死的，是根据当时的人力的任务分配情况，来定，怎么划分这个feature分支。 

比如说我们现在，假设电商v1.0版本要做15个子系统，1+4的小team，一个架构师带4个初中级工程师。平均每个人分配到的是3个子系统。每个子系统拉一个feature分支，在那个子系统上，就专门开发需要的代码就可以了。 

就是在上一讲，说工程初始化的时候，负责工程搭建的同学，就将所有系统中需要的接口全部定义出来 

这样的话，每个人拉出来的featiure分支，自己仅仅写这个feature中需要的代码，但是如果你的feature中依赖了别人的子系统feature中的接口，没关系，一开始，所有的接口都定义好了。大家都面向接口开发就可以了。写单元测试的时候，对别人的接口实现，采取mock的方式来做。 

每个人拉自己的feature分支，然后写自己的feature里的代码，对依赖别人的地方，面向接口编程

feature的命名规范：feature/order-system-v1.0 

（2）develop分支 

在上一讲，讲到代码初始化好之后，实际上代码是在master分支去初始化的。就直接从master分支拉一个develop分支出来，做为统一的代码集成的分支。 

每个人的feature分支开发好之火，就每个人依次将自己的feature分支的代码，合并到develop分支，进行代码集成。所有人的代码，就在develop分支上，完成了集成，develop分支，就包含了系统这个版本需要的所有代码。 

就可以基于develop分支的代码，去集成测试环境来部署，然后进行集成测试

集成测试的过程中，肯定是会不断的发现一些bug的，如何来修复bug呢？在什么分支上来修复bug？ 

一般来说，在集成测试环境，如果发现了这个bug的话，一般来说，对应有bug的同学，需要在自己的本地来复现这个bug 

这里，推荐说直接基于develop分支的代码来复现和修复bug，因为feature分支的代码是不完整的，可能是没法复现bug的，所以是不能通过feature分支的代码来复现和修复bug的。 

负责修复bug的同学，将develop分支的代码拉到自己本地，本地跑起来，基于开发环境的基础设施，应该在自己本地是可以跑起来的。复现bug，追查bug产生的原因，然后可以直接在develop分支上来修复这个bug。 

push develop分支的修改到GitLab上，然后所有人就基于最新的develop分支继续进行测试 

直到develop分支测试，感觉都保持稳定了，已经没有什么bug了，系统整体可以跑通，此时集成测试就结束了 

（3）release分支 

针对当前这个整体的版本，来从develop分支拉一个release分支出来，命名规范就是release/v1.0.0 

然后就可以基于release分支进行系统测试了，QA同学介入，对于release分支部署的环境，进行功能测试，确保所有的功能都是ok的 

如果此时发现有bug，同理，大家直接在release分支上去修复bug，包括在本地基于release分支代码复现bug，以及修复bug 

release分支如果测试到后面，稳定了，功能都ok了，测试结束了 

此时需要将release分支的代码合并到master分支上，同时将release分支的代码合并到develop分支上 

（4）master分支 

在最一开始，工程初始化的时候，就是基于master分支去初始化的 

这边的话呢，每个版本的release分支都测试完之后，就可以将代码合并到master分支上来。此时master分支上的代码是经过了严格的测试的，单元测试、冒烟测试、集成测试、系统测试 

接下来，就是要进行验收测试了 

直接基于master分支的代码，部署到staging验收测试环境上去，在这个环境上，由PM来进行所有功能的验收 

一般来说，99%的情况，验收测试环节，就不应该有bug了，让需求方体验一把整体的流程，在上线之前，做最后一轮check 

如果这里发现了bug，那么在release分支上来复现这个bug，然后在release分支上来修改这个bug 

bug修复之后，QA会在release分支和系统测试环境中，来验证说bug修复了，然后还会再做一遍回归测试 

release分支分别合并到master分支和develop分支上去 

验收测试通过之后，对master分支来打tag，比如货v1.0.0，打完tag之后，基于这个tag的代码，来进行线上系统的部署 

（5）bugfix分支 

线上发现了bug，而且判断这个bug的修复要超过1天的时间，那么需要从master分支拉一个bugfix分支下来，命名规范是bugfix/xx_bug 

在自己本地复现这个bug，基于bugfix分支上的代码，在自己本地来修复 

修复好bug之后，将bugfix分支的代码，合并一份到develop分支上去，然后让QA在集成测试环境，来初步验证一下说是ok的 

然后将bugfix的代码合并到master分支上去，将master分支代码在验收测试环境部署一下，让PM验证一下，bugfix是ok的 

给master分支打一个tag，再次将修复好bug的代码给上线 

（6）hotfix分支 

线上发现了一个bug，很紧急，需要在1天之内必须修复，哪怕加班到凌晨3也得修复，整体流程跟bugfix分支一样 

命名规范是hotfix/xx_bug 

（7）分支清理 

在一个大的版本最终完成上线之后，需要将这个版本对应的一些分支清理掉，比如说feature分支、release分支，需要删除掉

在修复好一个bug上线之后，需要将bugfix分支、hotfix分支，删除掉 

2、commit规范 

在各个分支上开发的时候，git最基本的就是git commit，git push 

git commit，是可以随便瞎commit的吗？每次commit的规范是什么？

 （1）commit的时机：在feature分支上，一般建议，是每天提交一个commit；在release分支上，每次修复好一个bug，提交一个commit；在develop分支上，每次修复好一个bug，提交一个commit；bugfix分支，修复好bug之后，提交一个commit 

（2）commit comment的规范 

标题：简短的说明了，你这次commit是干了什么，一般就是几十个字，不超过一行 

本次提交的代码改动列表： 

1.完成UserServiceImpl的编写，完成了用户增删改查的功能实现

2.完成UserMapper的编写，完成了用户增删改查的数据库操作逻辑的实现

3.

4.

##### 05_编码开发规范

一、编程规约 

(一) 命名风格 

1.【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 

反例：_name / __name / $Object / name_ / name$ / Object$  

2.【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 

说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。 

正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 

反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 

3.【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 

反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 

4.【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。 

正例： localValue / getHttpMessage() / inputUserId 

5.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 

正例：MAX_STOCK_COUNT 

反例：MAX_COUNT 

6.【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。 

7.【强制】中括号是数组类型的一部分，数组定义如下：String[] args; 

反例：使用String args[]的方式来定义。 

8.【强制】POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。 

反例：定义为基本数据类型Boolean isDeleted；的属性，它的方法也是isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。 

9.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 

正例： 应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring的框架结构） 

10.【强制】杜绝完全不规范的缩写，避免望文不知义。 

反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 

11.【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。 

正例：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。 

反例：变量int a; 的随意命名方式。 

12.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 

说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 

正例：public class OrderFactory;  public class LoginProxy;  public class ResourceObserver; 

13.【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 

正例：接口方法签名：void f();  接口基础常量表示：String COMPANY = "alibaba"; 

反例：接口方法定义：public abstract void f(); 

说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。 

14.接口和实现类的命名有两套规则：  

1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。 

正例：CacheServiceImpl实现CacheService接口。  

2） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。 

正例：AbstractTranslator实现 Translatable。 

15.【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 

说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 

正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKOWN_REASON。 

16.【参考】各层命名规约： 

A) Service/DAO层方法命名规约  

1） 获取单个对象的方法用get做前缀。  

2） 获取多个对象的方法用list做前缀。  

3） 获取统计值的方法用count做前缀。  

4） 插入的方法用save/insert做前缀。  

5） 删除的方法用remove/delete做前缀。  

6） 修改的方法用update做前缀。 

B) 领域模型命名规约  

1） 数据对象：xxxDO，xxx即为数据表名。  

2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。  

3） 展示对象：xxxVO，xxx一般为网页名称。  

4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。  

(二) 常量定义 

1.【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。  

反例：String key = "Id#taobao_" + tradeId;  cache.put(key, value); 

2.【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。 

说明：Long a = 2l; 写的是数字的21，还是Long型的2? 

3.【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。 

说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 

正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。 

4.【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。  

1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。  

2） 应用内共享常量：放置在一方库中，通常是modules中的constant目录下。  

反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：   

类A中：public static final String YES = "yes";  

类B中：public static final String YES = "y";  

A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。  

3） 子工程内部共享常量：即在当前子工程的constant目录下。  

4） 包内共享常量：即在当前包下单独的constant目录下。  

5） 类内共享常量：直接在类内部private static final定义。 

5.【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。 

正例：public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}  

(三) 代码格式 

1.【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：  

1） 左大括号前不换行。  

2） 左大括号后换行。  

3） 右大括号前换行。  

4） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。 

2.【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第5条下方正例提示。 

反例：if (空格a == b空格) 

3.【强制】if/for/while/switch/do等保留字与括号之间都必须加空格。 

4.【强制】任何二目、三目运算符的左右两边都需要加一个空格。 

说明：运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。 

5.【强制】采用4个空格缩进，禁止使用tab字符。 

说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。 

正例： （涉及1-5点） 

public static void main(String[] args) { 

// 缩进4个空格 

String say = "hello"; 

// 运算符的左右必须有一个空格 

int flag = 0;  

// 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格 

if (flag == 0) { 

​	System.out.println(say); 

}  

// 左大括号前加空格且不换行；左大括号后换行 

if (flag == 1) { 

​	System.out.println("world"); 

​	// 右大括号前换行，右大括号后有else，不用换行 

} else { 

​	System.out.println("ok"); 

​	// 在右大括号后直接结束，则必须换行 

} 

} 

6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。 

正例：// 注释内容，注意在//和注释内容之间有一个空格。 

7.【强制】单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则：  

1） 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。  

2） 运算符与下文一起换行。  

3） 方法调用的点符号与下文一起换行。  

4） 方法调用时，多个参数，需要换行时，在逗号后进行。  

5） 在括号前不要换行，见反例。 

正例： 

StringBuffer sb = new StringBuffer(); 

// 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行 

sb.append("zi").append("xin")... .append("huang")... .append("huang")... .append("huang"); 

反例： 

StringBuffer sb = new StringBuffer(); 

// 超过120个字符的情况下，不要在括号前换行 

sb.append("zi").append("xin")...append ("huang");  

// 参数很多的方法调用可能超过120个字符，不要在逗号前换行  

method(args1, args2, args3, ... , argsX); 

8.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 

正例：下例中实参的"a",后边必须要有一个空格。 method("a", "b", "c"); 

9.【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。 

10.【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 

正例： 

int a = 3; 

long b = 4L; 

float c = 5F; 

StringBuffer sb = new StringBuffer(); 

说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 

11.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 

说明：没有必要插入多个空行进行隔开。 

(四) OOP规约 

1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 

2.【强制】所有的覆写方法，必须加@Override注解。 

说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 

3.【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。

说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） 

正例：public User getUsers(String type, Integer... ids) {...} 

4.【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。 

5.【强制】不能使用过时的类或方法。 

说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 6. 【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 

正例："test".equals(object); 

反例：object.equals("test"); 

说明：推荐使用java.util.Objects#equals（JDK7引入的工具类） 

7.【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。 

说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。 

8.关于基本数据类型与包装数据类型的使用标准如下：  

1） 【强制】所有的POJO类属性必须使用包装数据类型。  

2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。  

3） 【推荐】所有的局部变量使用基本数据类型。  

说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。  

正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。  

反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。 

9.【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。 

反例：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 

10.【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。 

说明：注意serialVersionUID不一致会抛出序列化运行时异常。 

11.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。 

12.【强制】POJO类必须写toString方法。使用IDE的中工具：source> generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。 

说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。 

13.【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。 

说明： 

String str = "a,b,c,,"; 

String[] ary = str.split(","); 

// 预期大于3，结果是3 

System.out.println(ary.length); 

14.【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第15条规则。 15.【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法。 

说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。 

16.【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。 

反例： 

public Integer getData() { 

if (true) { 

​	return this.data + 100; 

} else { 

​	return this.data - 100; 

} 

} 

17.【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。 

说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。 

反例： String str = "start"; for (int i = 0; i < 100; i++) { str = str + "hello"; } 

18.【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：  

1） 不允许被继承的类，如：String类。  

2） 不允许修改引用的域对象，如：POJO类的域变量。  

3） 不允许被重写的方法，如：POJO类的setter方法。  

4） 不允许运行过程中重新赋值的局部变量。  

5） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。 

19.【推荐】慎用Object的clone方法来拷贝对象。 说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。 

20.【推荐】类成员与方法访问控制从严：  

1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。  

2） 工具类不允许有public或default构造方法。  

3） 类非static成员变量并且与子类共享，必须是protected。  

4） 类非static成员变量并且仅在本类使用，必须是private。  

5） 类static成员变量如果仅在本类使用，必须是private。  

6） 若是static成员变量，必须考虑是否为final。  

7） 类成员方法只供类内部调用，必须是private。  

8） 类成员方法只对继承类公开，那么限制为protected。 

说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。

思考：如果是一个private的方法，想删除就删除，可是一个public的service方法，或者一个public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。  

(五) 集合处理 

1.【强制】关于hashCode和equals的处理，遵循如下规则： 

1） 只要重写equals，就必须重写hashCode。 

2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。 

3） 如果自定义对象做为Map的键，那么必须重写hashCode和equals。 

说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。 

2.【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList. 

说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。 

3.【强制】在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。 

4.【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。 

说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 

正例： 

List<String> list = new ArrayList<String>(2); 

list.add("guan"); 

list.add("bao"); 

String[] array = new String[list.size()]; 

array = list.toArray(array);   

反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。 

5.【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 

说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。  

String[] str = new String[] { "you", "wu" };  

List list = Arrays.asList(str); 

第一种情况：list.add("yangguanbao"); 运行时异常。 

第二种情况：str[0] = "gujin"; 那么list.get(0)也会随之修改。 

6.【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，做为接口调用赋值时易出错。 

说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用<? extends T>。第二、经常往里插入的，适合用<? super T>。 

7.【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。 

正例： 

Iterator<String> iterator = list.iterator(); 

while (iterator.hasNext()) { 

​	String item = iterator.next(); 

​	if (删除元素的条件) { 

​		iterator.remove(); 

​	} 

} 

反例： 

List<String> list = new ArrayList<String>(); 

list.add("1"); 

list.add("2"); 

for (String item : list) { 

​	if ("1".equals(item)) { 

​		list.remove(item); 

​	} 

} 

说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 

8.【强制】 在JDK7版本及以上，Comparator要满足如下三个条件，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。 

说明：三个条件如下  

1） x，y的比较结果和y，x的比较结果相反。  

2） x>y，y>z，则x>z。  

3） x=y，则x，z比较结果和y，z比较结果相同。 

反例：下例中没有处理相等的情况，实际使用中可能会出现异常： 

new Comparator<Student>() { 

​	@Override 

​	public int compare(Student o1, Student o2) { 

​		return o1.getId() > o2.getId() ? 1 : -1; 

​	} 

}; 

9.【推荐】集合初始化时，指定集合初始值大小。 

说明：HashMap使用HashMap(int initialCapacity) 初始化， 

正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loader factor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。 

反例：HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表，严重影响性能。 

10.【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。 

说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。 

正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。 

11.【推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格： 

| 集合类            | Key          | Value        | Super       | 说明                   |
| ----------------- | ------------ | ------------ | ----------- | ---------------------- |
| Hashtable         | 不允许为null | 不允许为null | Dictionary  | 线程安全               |
| ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（JDK8:CAS） |
| TreeMap           | 不允许为null | 允许为null   | AbstractMap | 线程不安全             |
| HashMap           | 允许为null   | 允许为null   | AbstractMap | 线程不安全             |

反例： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。 

12.【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。 

说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。 

13.【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。  

(六) 并发处理 

1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 

说明：资源驱动类、工具类、单例工厂类都需要注意。 

2.【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 

正例： 

public class TimerTaskThread extends Thread { 

​	public TimerTaskThread() { 

​		super.setName("TimerTaskThread"); 

​		... 

} 

3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 

4.【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 

说明：Executors返回的线程池对象的弊端如下： 

1）FixedThreadPool和SingleThreadPool:  允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 

2）CachedThreadPool和ScheduledThreadPool:  允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 

5.【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。 

正例：注意线程安全，使用DateUtils。亦推荐如下处理： 

private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {  

​	@Override 

​	protected DateFormat initialValue() { 

​		return new SimpleDateFormat("yyyy-MM-dd"); 

​	} 

}; 

说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。  

6.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 

说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。 

7.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 

说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。 

8.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。 

说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。 

9.【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。 

10.【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。 

说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。 

11.【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。 

说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。 

正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。 

12.【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。 

反例： 

class Singleton { 

​	private Helper helper = null; 

​	public Helper getHelper() { 

​		if (helper == null) synchronized(this) { 

​			if (helper == null) 

​				helper = new Helper(); 

​		} 

​		return helper; 

​	} 

​	// other methods and fields... 

} 

13.【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。 

14.【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 

15.【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。  

(七) 控制语句 

1.【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。 

2.【强制】在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements; 

3.【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成： 

if (condition) {  

​	...  return obj; 

} 

// 接着写else的业务逻辑代码; 

说明：如果非得使用if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。 

正例：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： 

public void today() {  

​	if (isBusy()) {  

​		System.out.println(“change time.”);  

​		return;  

​	}   

​	if (isFree()) {  

​		System.out.println(“go to travel.”);  

​		return;  

​	}  

​	System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);  

​	return; 

} 

4.【推荐】除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 

说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 

正例： 

// 伪代码如下 

final boolean existed = (file.open(fileName, "w") != null) && (...) || (...); 

if (existed) {  

​	...

} 

反例： 

if ((file.open(fileName, "w") != null) && (...) || (...)) {  

​	... 

} 

5.【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。 

6.【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 

7.【参考】下列情形，需要进行参数校验：  

1） 调用频次低的方法。  

2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。  

3） 需要极高稳定性和可用性的方法。  

4） 对外提供的开放接口，不管是RPC/API/HTTP接口。  

5） 敏感权限入口。 

8.【参考】下列情形，不需要进行参数校验： 

1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。  

2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。  

3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。  

(八) 注释规约 

1.【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用// xxx方式。 

说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 

2.【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 

说明：对子类的实现要求，或者调用注意事项，请一并说明。 

3.【强制】所有的类都必须添加创建者和创建日期。 

4.【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。 

5.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 

6.【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。 

反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 

7.【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。 

说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 

8.【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。 

说明：代码被注释掉有两种可能性：

1）后续会恢复此段代码逻辑。

2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 

9.【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 

10.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 

反例： 

// put elephant into fridge 

put(elephant, fridge);  

方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 

11.【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。  

1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）  表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。  

2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）  在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。  

(九) 其它 

1.【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 

说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 

2.【强制】velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。 

说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。 

3.【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。 

说明：如果var=null或者不存在，那么${var}会直接显示在页面上。 

4.【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。 

5.【强制】获取当前毫秒数System.currentTimeMillis(); 而不是new Date().getTime(); 

说明：如果想获取更加精确的纳秒级时间值，使用System.nanoTime()的方式。在JDK8中，针对统计时间等场景，推荐使用Instant类。 

6.【推荐】不要在视图模板中加入任何复杂的逻辑。 

说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。 

7.【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 

8.【推荐】及时清理不再使用的代码段或配置信息。 

说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。 

正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。  

二、异常日志

 (一) 异常处理 

1.【强制】Java 类库中定义的一类RuntimeException可以通过预先检查进行规避，而不应该通过catch 来处理，比如：IndexOutOfBoundsException，NullPointerException等等。 

说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过catch NumberFormatException来实现。 

正例：if (obj != null) {...} 

反例：try { obj.method() } catch (NullPointerException e) {...} 

2.【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 

3.【强制】对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 

4.【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 

5.【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。 

6.【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 

说明：如果JDK7及以上，可以使用try-with-resources方式。 

7.【强制】不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 

8.【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 

说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 

9.【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。调用方需要进行null判断防止NPE问题。 

说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。 

10.【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：  

1）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。  

反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 

2） 数据库的查询结果可能为null。  

3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。  

4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。  

5） 对于Session中获取的数据，建议NPE检查，避免空指针。  

6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。 

正例：使用JDK8的Optional类来防止NPE问题。 

11.【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。 

12.【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 

说明：关于RPC方法返回方式使用Result方式的理由：  

1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。  

2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 

13.【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 

说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 

正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取： 

private boolean checkParam(DTO dto) {...} 

 (二) 日志规约 

1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 

import org.slf4j.Logger; 

import org.slf4j.LoggerFactory;  

private static final Logger logger = LoggerFactory.getLogger(Abc.class); 

2.【强制】日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。 

3.【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 

正例：mppserver应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 

说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 

4.【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。 

说明：logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 

正例：（条件） 

if (logger.isDebugEnabled()) { 

​	logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 

} 

正例：（占位符） 

logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol); 

5.【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。 

正例：<logger name="com.taobao.dubbo.config" additivity="false"> 

6.【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。 

正例：logger.error(各类参数或者对象toString + "_" + e.getMessage(), e); 

7.【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 

说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 

8.【参考】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出error级别。  

三、单元测试 

1.【强制】好的单元测试必须遵守AIR原则。 

说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 

A：Automatic（自动化） 

I：Independent（独立性） 

R：Repeatable（可重复） 

2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。 

3.【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。 

反例：method2需要依赖method1的执行，将执行结果做为method2的输入。 

4.【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 

说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。 

正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。 

5.【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 

说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。 

6.【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 

说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 

7.【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。 

说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。 

8.【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100% 

说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。 

9.【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。 

B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。 

C：Correct，正确的输入，并得到预期的结果。 

D：Design，与设计文档相结合，来编写单元测试。 

E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。 

10.【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 

反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。 

11.【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。 

正例：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。 

12.【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 

13.【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。 

14.【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 

15.【参考】为了更方便地进行单元测试，业务代码应避免以下情况： 

构造方法中做的事情过多。 

存在过多的全局变量和静态方法。 

存在过多的外部依赖。 

存在过多的条件语句。 

说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 

16.【参考】不要对单元测试存在如下误解： 

那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 

单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。 

单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 

单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。   

四、安全规约 

1.【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。 

说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 

2.【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 

说明：查看个人手机号码会显示成:1589119，隐藏中间4位，防止隐私泄露。 

3.【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。 

4.【强制】用户请求传入的任何参数必须做有效性验证。 

说明：忽略参数校验可能导致： 

page size过大导致内存溢出 

恶意order by导致数据库慢查询 

任意重定向 

SQL注入 

反序列化注入 

正则输入源串拒绝服务ReDoS 

说明：Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 

5.【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。 

6.【强制】表单、AJAX提交必须执行CSRF安全过滤。 

说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 

7.【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 

说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 

8.【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。  

五、MySQL数据库

 (一) 建表规约 

1.【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）。 

说明：任何字段如果为非负数，必须是unsigned。 

正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。 

2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 

说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 

正例：aliyun_admin，rdc_config，level3_name 

反例：AliyunAdmin，rdcConfig，level_3_name 

3.【强制】表名不使用复数名词。 

说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 

4.【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。 

5.【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。 '_

说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。 

6.【强制】小数类型为decimal，禁止使用float和double。 

说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。 

7.【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。 

8.【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 

9.【强制】表必备三字段：id, gmt_create, gmt_modified。 

说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified的类型均为date_time类型，前者现在时表示主动创建，后者过去分词表示被动更新。 

10.【推荐】表的命名最好是加上“业务名称_表的作用”。 

正例：alipay_task / force_project / trade_config  

11.【推荐】库名与应用名称尽量一致。 

12.【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 

13.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：  

1）不是频繁修改的字段。  

2）不是varchar超长字段，更不能是text字段。 

正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 

14.【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。 

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 

15.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 

正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 

| 对象     | 年龄区间  | 类型              | 字节 | 表示范围                  |
| -------- | --------- | ----------------- | ---- | ------------------------- |
| 人       | 150岁之内 | unsigned tinyint  | 1    | 无符号值：0到255          |
| 龟       | 数百岁    | unsigned smallint | 2    | 无符号值：0到65535        |
| 恐龙化石 | 数千万年  | unsigned int      | 4    | 无符号值：0到约42.9亿     |
| 太阳     | 约50亿年  | unsigned bigint   | 8    | 无符号值：0到约10的19次方 |

(二) 索引规约 

1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 

说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 

2.【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 

说明：即使双表join也要注意表索引、SQL性能。 

3.【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分 度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 

4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 

说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 

5.【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 

正例：where a=? and b=? order by c; 索引：a_b_c 

反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。 

6.【推荐】利用覆盖索引来进行查询操作，避免回表。 

说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 

正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using index。 

7.【推荐】利用延迟关联或者子查询优化超多分页场景。 

说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 

正例：先快速定位需要获取的id段，然后再关联：  

SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 

8.【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 

说明：  

1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。  

2）ref 指的是使用普通的索引（normal index）。  

3）range 对索引进行范围检索。 

反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。 

9.【推荐】建组合索引的时候，区分度最高的在最左边。 

正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。 

说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。 

10.【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 

11.【参考】创建索引时避免有如下极端误解：  

1）宁滥勿缺。认为一个查询就需要建一个索引。  

2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。  

3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。  

(三) SQL语句 

1.【强制】不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。 

说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 

2.【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 

3.【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。 

正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 

4.【强制】使用ISNULL()来判断是否为NULL值。 

说明：NULL与任何值的直接比较都为NULL。  

1） NULL<>NULL的返回结果是NULL，而不是false。  

2） NULL=NULL的返回结果是NULL，而不是true。  

3） NULL<>1的返回结果是NULL，而不是true。 

5.【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。 

6.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 

说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 

7.【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 

8.【强制】数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能执行更新语句。 

9.【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。 

10.【参考】如果有全球化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。 

说明：  

SELECT LENGTH("轻松工作")； 返回为12  

SELECT CHARACTER_LENGTH("轻松工作")； 返回为4  

如果需要存储表情，那么选择utfmb4来进行存储，注意它与utf-8编码的区别。 

11.【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 

说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 

 (四) ORM映射 

1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 

说明：

1）增加查询分析器解析成本。

2）增减字段容易与resultMap配置不一致。 

2.【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。 

说明：参见定义POJO类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。 

3.【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。 

说明：配置映射关系，使字段与DO类解耦，方便维护。 

4.【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。 

5.【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。 

说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。 

正例：Map<String, Object> map = new HashMap<String, Object>(); map.put("start", start); map.put("size", size); 

6.【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 

说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。  

7.【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。 

8.【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。 

9.【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 

10.【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。  

六、工程结构 

(一) 应用分层 

1.【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推：  

开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。 

终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。 

Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 

Service层：相对具体的业务逻辑服务层。 

Manager层：通用业务处理层，它有如下特征：  

1） 对第三方平台封装的层，预处理返回结果及转化异常信息；  

2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理；  

3） 与DAO层交互，对多个DAO的组合复用。 

DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。 

外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。 

2.【参考】 （分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上 抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。 

3.【参考】分层领域模型规约： 

DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。 

DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。 

BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。 

AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 

VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。 

Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。  

(二) 二方库依赖 

1.【强制】定义GAV遵从以下规则：  

1） GroupID格式：com.{公司/BU }.业务线.[子业务线]，最多4级。  

说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress等BU一级；子业务线可选。  

正例：com.taobao.jstorm 或 com.alibaba.dubbo.register  

2） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。  

正例：dubbo-client / fastjson-api / jstorm-tool  

3） Version：详细规定参考下方。 

2.【强制】二方库版本号命名方式：主版本号.次版本号.修订号  

1） 主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。  

2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。  

3） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。 

说明：注意起始版本号必须为：1.0.0，而不是0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 

3.【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。 说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。  

4.【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行<excludes>排除jar包。 

5.【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。 

6.【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 

说明：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。 

7.【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。 

说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 

8.【推荐】所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。 

说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。 

9.【推荐】二方库不要有配置项，最低限度不要再增加配置项。 

10.【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则： 

1）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。 

2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。  

(三) 服务器 

1.【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。 

说明：操作系统默认240秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。 

正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）：  net.ipv4.tcp_fin_timeout = 30  

2.【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。 

说明：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 

3.【推荐】给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。 

说明：OOM的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 

4.【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。 

5.【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。 

##### 06_系统测试规范

###### 01_单元测试规范

1、单元测试 

针对的是代码中的每个类，一个类认为是一个代码组件，对每个代码组件都编写一个单元测试类。这个单元测试类中会有多个方法，通常至少对要测试的类中的每个方法都编写一个对应的测试方法。 

单元测试，面向的是代码组件的级别，它是最小最细粒度的测试单元 

通常而言，通过单元测试检查出来的bug是最多的，所以它是位于测试金字塔模型的最底端 

单元测试，需要每个RD对自己编写的代码自己去写单元测试，一般是使用JUnit框架，如果你使用了一些其他的框架，Spring，Spring MVC，都有对应的跟JUnit整合起来进行单元测试的一些框架，逻辑判断的Hamcrest框架，mock对象的Mockito框架。 

初步的一些规范： 

（1）单元测试类，必须以test来结尾，以要测试的类来打头

（2）针对每个类，一般都要写一个单元测试类来进行测试

（3）单元测试中的每个方法，针对的是被测试类中的每个方法，方法以test打头，跟上要测试的方法名称 

下面给出单元测试的一个基本的例子： 

```
public class HelloWorld {
    
    public String sayHello(String name) {
        return "hello, " + name;
    }
    
} 
```

```
public class HelloWorldTest {
    
    private HelloWorld helloWorld = new HelloWorld();
    
    @Test
    public void testSayHello() {
        String name = "leo";
        String result = helloWorld.sayHello(name);
        assertEquals("hello, leo", result);
    }    
} 
```

下面是使用测试替身的一个例子

```
public class HelloWorld {
    
    private GreetingMessageService greetingMessageService;
    
    public String sayHello(String name) {
        greetingMessageSerivce.save(name);
        return "hello, " + name;
    }
    
    public void setGreetingMessageService(GreetingMessageService greetingMessageService) {
        this.greetingMessageService = greetingMessageService;
    }
    
    public GreetingMessageService getGreetingMessageService() {
        return greetingMessageService;
    }    
}
```

```
public class GreetingMessageServiceImpl implements GreetingMessageService {
    
    private GreetingMessageDAO greetingMessageDAO;
    
    public void save(String name) {
        greetingMessageDAO.save(name);
    }  
} 
```

重要的原则：单元测试中，你测试一个类，就只能针对这一个类中的代码来进行测试。如果这个类依赖了其他的类，必须用测试替身将依赖的类和要测试的类隔离开来。为什么呢？记住，单元测试是什么，单元测试其实是最小的测试单位，一个单元测试类就负责测试一个代码组件（一个类），如果这个类依赖了其他的类。那么你就自己模拟一些测试替身，注入到要测试的类中去，将要测试的类和依赖的类隔离开来。 

避免说，要测试的类和依赖的类耦合在一起测试，互相如果有bug会互相影响 

```
public class GreetingMessageServiceStub implements GreetingMessageService {
    
    public void save(String name) {
        System.out.println("received a message: " + name);
    }   
}
```

```
public class HelloWorldTest {
    
    private HelloWorld helloWorld;
    
    @Before
    public void setup() {
        this.helloWorld = new HelloWorld();
        GreetingMessageService greetingMessageService = new GreetingMessageServiceStub();
        this.helloWorld.setGreetingMessageService(greetingMessageService);
    }
    
    @Test
    public void testSayHello() {
        String name = "leo";
        String result = helloWorld.sayHello(name);
        assertEquals("hello, leo", result);
    }
    
    @After
    public void teardown() {
        this.helloWorld = null;
    }   
} 
```

fake对象的示例 

```
public class UserDAOFake implements UserDAO {
    
    private Map<Long, User> mockDB = new HashMap<Long, User>();
    
    public void save(User user) {
        mockDB.put(user.getUserId(), user);
    }
    
    public void update(User user) {
        mockDB.put(user.getUserId(), user);
    }
    
    public void remove(Long userId) {
        mockDB.remove(userId);
    }
    
    public User getUserById(Long userId) {
        return mockDB.get(userId);
    }    
} 
```

spy对象的示例 

```
public class GreetingMessageServiceSpy implements GreetingMessageService {
    
    private String _name;
    
    public void save(String name) {
        this._name = name;
        System.out.println("received a message: " + name);
    }
    
    public boolean received(String name) {
        return _name.equals(name);
    }   
}
```

```
public class HelloWorldTest {
    
    private HelloWorld helloWorld;
    
    @Before
    public void setup() {
        this.helloWorld = new HelloWorld();
        GreetingMessageService greetingMessageService = new GreetingMessageServiceSpy();
        this.helloWorld.setGreetingMessageService(greetingMessageService);
    }
    
    @Test
    public void testSayHello() {
        String name = "leo";
        String result = helloWorld.sayHello(name);
        assertEquals("hello, leo", result);
        
        GreetingMessageServiceSpy greetingMessageService = 
            (GreetingMessageServiceSpy)helloWorld.getGreetingMessageService();
        assertTrue(greetingMessageService.received(name));
    }
    
    @After
    public void teardown() {
        this.helloWorld = null;
    }    
} 
```

mock对象的伪代码示例 

```
public class HelloWorldTest {
    
    private HelloWorld helloWorld;
    
    @Before
    public void setup() {
        this.helloWorld = new HelloWorld();
        
        GreetingMessageService greetingMessageSerivce = mock(GreetingMessageSerivce.class);
        when(greetingMessageSerivce.save("leo")).thenReturn("success");
        
        this.helloWorld.setGreetingMessageService(greetingMessageService);
    }
    
    @Test
    public void testSayHello() {
        String name = "leo";
        String result = helloWorld.sayHello(name);
        assertEquals("hello, leo", result);
    }
    
    @After
    public void teardown() {
        this.helloWorld = null;
    }    
} 
```

重要原则：单元测试绝对不能依赖任何的外部基础设施，比如说mysql、redis、rabbitmq，绝对不能依赖这些东西来写单元测试。如果要依赖的话，直接注入测试替身，用模拟的行为来替代掉。 

重要规范：单元测试覆盖率，要保证你写的单元测试覆盖了足够多的代码，保证覆盖的代码至少达到70%，对核心模块的代码要覆盖100% 

一个好的单元测试要符合的一个规范和规则 

- 什么是单元测试？
  - 直接裸奔不写单元测试的弊端
    - 如果裸奔不写单元测试的话，就直接意味着，这个RD根本就没有对自己编写的代码负责
    - 最基本的单元测试都没有，凭什么让人相信你的代码是经过测试的呢？
  - 写更多的单元测试对代码质量提高的稳定曲线
  - 写更多的单元测试对代码设计质量提高的稳定曲线
- 优秀的单元测试有哪些特质？
  - 可读性
  - 良好的测试代码结构
  - 精准的测试名称
  - 测试代码的可重复性
  - 自动化单元测试的3大工具
    - 测试框架：JUnit来测试，加上其他一些辅助性质的测试框架
    - 运行单元测试的自动化构建：基于maven的插件，mvn test，自动把所有的单元测试都自动化跑一遍
    - 测试替身：主要使用的是Mockito框架，模拟出来各种各样实现某个接口的类，每个方法的模拟的行为是什么
- 测试替身
  - 测试替身的几大作用
    - 隔离要测试的代码组件：将测试替身对象传入要测试的组件
    - 加快测试执行速度：替换复杂耗时的代码执行
      - 有的时候会有这样的一种情况，比如你要测试的是类A，类A依赖了类B，类B中的代码非常复杂，执行了大量的数据库读写操作
      - 导致类B的那个方法跑起来是很慢的
      - 就是用测试替身代替类B，将类B中的方法实现为非常简单的一些打印日志的模拟的实现就可以了，因为我们重点要测试的是类A，不是类B
      - 测试替身的一个效果，就是可以加速类A中的方法的执行速度，也就可以加快我们的单元测试运行的速度
    - 让代码行为变得足够稳定：将随机行为改为固定行为
      - 类A依赖了类B，类B中会随机生成一个随机数，根据随机数来执行一些行为
      - 这就会导致类A每次调用类B，执行的结果是随机的，不够稳定
      - 用测试替身替代掉类B，每次调用就是返回一个固定的值，就可以了，让代码行为变得足够稳定
      - 就能保证我们的单元测试每次都是稳定运行的
    - 模拟特殊的异常情况：主动抛出网络调用异常
      - 类A依赖了类B，现在需要测试的是，如果类B的方法抛出了异常，类A捕捉到异常之后，能否正常执行类A中的catch中的代码逻辑
      - 此时可以用测试替身替代掉类B，让类B中的方法就固定抛出一个异常
    - 访问私有数据：测试后获取依赖组件的内部私有数据来断言
      - 类A依赖了类B，现在测试是要看那一下，类A调用了类B之后，类B中的部分变量是否改变为了我们期望的一个值
      - 此时就可以用测试替身来替代掉这个类B，在里面增加捕获变量改变历史的一些数据
      - 最后测试完了以后，我们就可以看一下是否符合期望
  - 测试替身的几种类型
    - 测试桩：stub
      - 最简单的测试替身
      - 一般就是用一两行代码模拟行为
      - 比如日志记录组件，可以用测试桩来替代
    - 伪造对象：fake
      - 相对复杂一些的情况，需要使用伪造对象来模拟真实场景
      - 比如DAO组件可以用fake对象
      - 使用内存数据库来实现数据的增删改查
    - 测试间谍：spy
      - 要检查依赖组件的行为，是无法直接断言的，需要使用spy
      - 将依赖组件做成spy，对方法调用可以保存数据
      - 对测试组件执行完之后，对spy保存的数据进行断言
    - 模拟对象：mock
      - mock对象，指定某个参数传入时返回什么结果
      - 使用mock对象可以模拟任意复杂度的依赖代码组件
  - 测试替身的使用规则
    - 如何选择测试替身
      - 操作行为用mock对象
      - 查询行为用stub对象
      - 复杂的一套业务逻辑用fake对象
      - 无法断言返回结果用spy对象
    - 单元测试编写范式：准备、执行、断言
    - 测试框架：JUnit+Mockito+Hamcrest
      - 单元测试主要用JUnit
      - 用Mockito来模拟4种测试替身
      - 用Hamcrest来配合assertThat断言
- 单元测试的反面教材
  - 可读性较差
    - 基本断言：断言时用了算数运算符，让人看不懂
      - assertTrue(a > 100)
      - assertThat(a, greaterThan(100))，Hamcrest框架
    - 过度断言：对大量的代码逻辑的执行结果进行一次断言，出问题不好排查
      - 一次性对多个方法进行了测试和断言
      - 要将对多个方法的测试拆分到不同的测试方法中，尽量降低测试的粒度
    - 位断言：断言时使用了按位与等特殊操作符号，让人看不懂
      - 在写单元测试的时候，不要使用位运算符，比如说<<，>>
    - 人格分裂：将较为复杂的多个不同类别的逻辑放在一个测试类里
      - 在一个测试类中，对多个不同的类，或者一个类中多种不同的负责逻辑进行测试
      - 可以尝试将过于复杂的测试逻辑拆分到不同的测试类中去
    - 逻辑分割：测试代码依赖了外部文件中的内容，很难查看
      - 测试代码里面，使用了外部的一个文件，比如说a.txt，或者b.csv
      - 尽量用内嵌在代码中的文本去替代外部的文件
      - 保证说所有的内容都在单元测试中
    - 魔法数字：断言时用了magic number，让人看不懂
      - assertTrue(a > 100)，100，magic number
      - assertThat(productPrice, greaterThan(price(100)))
    - 冗长安装：setup方法中代码过于冗长，不拆分一下让人不好看懂
      - @Before的setup方法中，将过于复杂的逻辑拆分到不同的私有方法中去执行
    - 过分保护：一个测试方法中有多个断言，有过分保护之嫌
      - 太过于谨慎了，一个测试方法中，多个断言，对同一个结果，不同角度反复断言
  - 可维护性较差
    - 重复：数字、字符串和类似代码逻辑多次重复，需要抽取
      - 对于测试代码中一些重复性的数字、字符串，抽取出来，抽取成一个独立的变量，不要有太多重复的东西
    - 条件逻辑：不要在测试代码中加多个if else逻辑判断
    - 脆弱的测试：随机性的逻辑导致测试经常运行失败，不够稳定
    - 文件路径：使用绝对路径导致在别人那里测试运行失败
    - 沉睡的蜗牛：使用Thread.sleep来控制多线程，导致运行缓慢和随机性
    - 像素完美：对图像类测试代码，使用了过多像素数字
    - 参数化混乱：过多使用参数化测试技术，导致测试代码不易于调试
    - 方法见缺乏内聚：一个类中混杂太多的测试方法和测试类实例
  - 可信赖程度较差
    - 注释掉的测试：不要注释测试，而是直接删除掉
    - 歧义注释：有些注释有歧义，误导人理解，需要重写注释
    - 永不失败的测试：检查抛出异常的测试，却永远接收不到异常
    - 轻率承诺：测试代码被注释，没有写断言，都是无意义的测试代码
    - 降低期望：对代码执行的结果要求很低，轻易就通过测试
    - 平台偏见：不同平台的测试需要划分到不同的类中，对windows平台的测试用一个类，对unix平台的测试用一个类
    - 有条件的测试：如果依赖条件来进行测试，那么可能会有问题，不要出现if else
- 可测试的设计
  - 什么是可测试的设计？
    - 模块化设计
    - SOLID原则
    - 上下文中的模块化设计
    - 以测试驱动出模块化设计
  - 无法测试的问题
    - 无法实例化某个类
    - 无法调用某个方法
    - 无法观察到输出
    - 无法替换某个协作者
    - 无法覆盖某个方法
  - 可测试设计的指南
    - 避免复杂的私有方法
    - 避免final方法
    - 避免static方法
    - 谨慎使用new创建对象：如果你这里用了new来创建对象，会导致我们没法注入测试替身
    - 避免在构造函数中包含复杂逻辑
    - 避免使用单例模式
    - 使用组合优先于使用继承
    - 将外部组件封装在自己的组件中
    - 避免远程服务查找和调用 

你开发好你所有的功能代码之后，运行完所有的单元测试之后，跑出来一份单元测试覆盖率的报告，这份报告的话呢，需要保留好，因为在后面，会有一个审查的环节

###### 02_冒烟测试规范

冒烟测试 

冒烟测试，大概的意思是这样子的，名字是从哪儿来的呢？以前国外有程序员，传闻说是从微软那边程序员传出来的 

以前如果就是光写单元测试的话，其实可能还是会有不少的bug 

然后程序员就会很懒，他们会觉得说，我们就不用化很多的时间去测试代码了，直接甩给QA去测，他们测出来了，我们再修改就可以了 

后来QA很火冒三丈，BAT都有这样的情况，QA觉得你提测的时候，怎么bug这么多啊，很多都是初级的bug，你当时如果自己好好测一下不就得了，到我这里来就没那么多的bug了。更加重要的一点是什么呢？之前有人做过统计，每一个测试环节，如果你的一个bug越往后发现和修复，耗费的成本可能是上一个环节发现和修复的成本的10倍。比如在单元测试环节，就发现有一个bug，就修复了，这算是美金是10美金；如果到集成测试环节，再发现一个bug，可能要话费的是100美金的成本；如果到系统测试的环节，再发现一个bug，可能要花费的成本是1000美金的成本。 

那么现在比较流行的是说，在提交给QA的集成测试之前，RD必须在自己本地，跑起来，基础设施全部连通开发环境中的mysql、redis、mq，自己负责的代码跑起来，对各个接口，自己测一测，如果觉得都能跑通，逻辑正确，那么测试通过 

这个，其实就是花不了多少时间，这个就不是说一个类一个类的测试了，可能你总共就20个接口，对应了200个类。对200个类，要写200个单元测试。对20个接口，一行代码不用写，系统跑起来，自己模拟一下http或者rpc的请求，构造一些参数，看一下返回结果，就可以了。 

这可能就花费抽一根烟的时间，所以有人传闻，冒烟测试，可能就是从这儿来的 

冒烟测试，就是负责开发的RD，自己简单的去进行一下测试，确保自己写的代码大问题没有 

在进行详细设计的时候，就需要设计好自己要执行的冒烟测试的测试用例 

（1）测试名称

（2）测试接口

（3）输入

（4）输出 

你执行了冒烟测试过后，要记录下来一份冒烟测试报告，这里面就写清楚，你执行了哪些冒烟测试用例，输入是什么，输出是什么，每个冒烟测试的结果是否通过

###### 03_静态代码扫描规范

静态代码扫描

静态代码扫描，主要是看一下代码写的是否足够规范，如果靠人肉去看代码写的是否足够规范的话，耗费时间太多，不太靠谱，可能会有遗漏 

针对我们的编码规范，用了阿里的java开发规范，用阿里配套的代码扫描的插件，去扫描一下代码，看一下，是否都是符合规范的，如果扫描结果提醒，有不符合规范的地方，需要你将对应的不规范的代码重构一下，直到代码全部符合规范 

然后最终通过扫描的扫描报告，需要留存一份，后面会有人来审查

###### 04_代码审查规范

code review，代码审查，代码走读 

到这里为止，你的team里的一个同学，就已经把他要干的活儿全部都干完了 

此时，他就应该push自己本地的代码到gitlab上去，然后在gitlab上对他自己的feature分支，提交一个Pull Request到develop分支上去 

Pull Request的reviewer就是你，架构师本人，也可以是团队内其他的高工，如果你作为一个架构师，带了十几个人，二十人的团队，你手下有三四个高工，每个高工带了一个小团队，那么其实一般就是让高工负责去审查他们的代码就可以了，你负责审查高工的代码 

Pull Request里面，是可以写备注的 ，这个备注的规范如下： 

（1）标题：用一行文字，简短的概括说明，你本次开发好了哪些东西 

（2）列表 

1.完成了订单系统的开发

（1）包括XX模块

（2）包括XX模块

2.完成了调度系统的开发

（1）包括XX模块

（2）包括XX模块 

单元测试报告：可以通过邮件去发送，然后在这里可以备注好，通过哪份邮件，已经发送过去了，对方可以查看

冒烟测试报告：邮件

静态代码扫描报告：邮件 

接收到这个Pull Request的同学，就需要对他的代码去进行审查了 

code review，要看哪些东西，众说纷纭，可以写的很详细，也可以写的很粗糙 

这一块，基本上要定一个特别细的规范，很难的，负责review的那个人，自己时间很紧张，可能一般都没有太多的时间去给你看代码 

所以你务必要确保说，在短时间内，这个负责审查代码的人，可以确保说，这个代码是ok的 

我根据经验梳理出来一些，看别人的代码，重点要看什么： 

（1）看懂别人的代码：基本上都按照编码规范，命名都很清晰，面向对象的划分都很清晰，注释很清晰，逻辑交互很清晰。如果说你觉得能看懂这个人的代码，而且代码设计的很优雅，未来的可扩展性很高，那么就可以。但是如果你发现有些地方的命名，或者是代码注释，不够清晰，导致你不好理解，看不懂，而已给建议。这块是在把控代码的质量。第一点，就是让人能看懂。 => 代码质量 

（2）仔细审查一下业务逻辑是否准确，对照着详细设计文档来看，你作为一个小leader，你要负责确保说，你手下写出来的代码，是按照详细设计文档里的设计在写的，整个业务流程和业务逻辑都是准确的。看一下这个逻辑，是否有可能会在某些特殊情况下出现bug，也是根据你的经验和能力来的，你的经验和能力越强，这一步能看出来的问题就越多。 => bug 

（3）看一看代码编写的细节有没有什么问题：这个，就根据你的经验来判断，比如说，你发现某一段代码，在for循环内部出现了每次循环都创建一个对象的，备注一下，建议将循环内创建对象的逻辑抽到循环外面来执行。我可以给出来很多很多的建议和细则，大家很难去执行的，还有很多，根据你自己的技术能力和技术经验来了，你的技术越强，经验越丰富，往往在这个环节，你可以提出很多的问题。io读取文件，你会建议说，是否可以重构为nio的方式。 => 对代码设计和技术实现的质量 

（4）单元测试，初步浏览一遍，看看单元测试代码写的是否ok，如果出现一些不太规范不太好的地方，给一些建议，让单元测试代码重构一下。看一下单元测试覆盖率的报告，确保说，70%的覆盖率，核心包下的代码覆盖率是100%。 

（5）冒烟测试，仔细看一遍，确保说，他设计的那些冒烟测试用例都执行了，这个就代表着说他做了这个事情

（6）静态代码扫描的报告，这个就是确保说，都是符合编码规范的，代码是规范的 

有了规范，必须确保可以落地，可以执行，唯一能够依靠的就是check 

在code review这个环节，就可以去check之前的所有流程，单元测试覆盖率是否达标，冒烟测试是否全部通过，静态代码扫描是否全部通过 

负责审核你的代码的人，他需要在审核之后，给出你一份总评，就是说，审核了你哪些哪些地方，然后最终判定通过

###### 05_集成测试规范

集成测试 

互联网行业里，集成测试，都是RD自己做的，不是QA介入的。联调测试，每个人的部分要集成到一起，联通外部的所有基础设施，让整套系统跑起来，对系统的核心流程，以及核心的功能，都去进行测试，验证。确保整套系统是可以跑通的。我们一般会称之为，小黑屋阶段。因为涉及到多个人的联调，集成，测试。所以一般在这个环节，我们一般都会提前订好几个的会议室，每天上班第一件事情，就是大家一起去小黑屋里去测试，有一个人负责去执行系统的所有核心流程，QA，PM。发现有问题，大家就根据日志去排查问题，现场排查，现场直接修复。 

跟传统IT行业，不一定完全一样 

集成测试通过之后，就是要确保系统的所有核心主流程全部跑通 

集成测试的测试用例，是QA去设计的，QA在这里去执行集成测试的用例，我们RD主要负责配合排查bug和修复bug 

每次集成测试过程中，需要有一个人记录下来，本次集成测试的报告，里面记录好，对哪些集成测试用例进行了执行，测试的结果是什么

###### 06_系统测试规范

系统测试 

这一步不用说了，一定是QA去做的 

QA提前设计好对应的所有的系统测试的用例，这个用例一般都是很详细，很复杂的，涵盖了各种细节，各种异常和特殊的情况 

就是直接将整套系统部署到test环境，联通test环境整套基础设施，然后由QA去测试 

引入一个东西，叫做缺陷管理 

就不是走小黑屋的模式了，RD自己在那儿瞎测，大家都通过了集成测试了，都对自己的系统和代码比较有信心了，直接部署好在test环境，我们就坐等QA反馈bug 

QA，如果在比较原始的其情况下，基于word文档来记录缺陷bug，来反馈 

现在其实有一些很好的产品，项目全生命周期的管理，包括了bug缺陷的反馈。但是我们在第一个阶段，尽量用比较原始的方式来做，因为让你了解原始的方式，怎么把整套东西给跑通了。到了阶段二，我们就会去用一些专门项目管理软件，缺陷管理软件。 

QA，发现一个bug，就会记录下来，这个bug的发生时间，bug标题，具体描述，截图 

一轮一轮的来测试 

第一轮测试之后，就统一一个word文档，发给各个RD，每个RD去排查和修复自己负责的那个bug。大家全部都修复好之后，再次提测。 

QA再次进行第二轮测试，word文档。以此类推，三轮，四轮，三轮左右，就可以搞定了。QA觉得一个bug都没有了。 

负责测试的QA有责任产出一份测试报告，就是说明他做了哪些测试用例，每个测试用例的执行结果是什么，一共是几轮，第一轮测出了多少个bug，第二轮是多少个bug

###### 07_验收测试规范

验收测试 

QA全部测试完之后，理想情况下，那么此时bug数为0，系统就完全达到可以上线的状态了 

但是此时还是需要将系统在验收环境，staging环境去部署一下，然后让PM来验收，PM会自己设计很多的验收测试用例，执行自己设计的那些验收测试用例。确保说系统的所有核心功能全部可以跑通。 

此时系统就完全达到了可以上线的状态。 

负责验收系统的人，比如这个PM，有责任记录一份验收测试的报告，记录下来自己做了哪些测试，执行了哪些测试用例，每个测试用例的执行结果是什么

##### 07_系统上线规范

###### 01_系统上线规范
 一、上线checklist 

每个在本次要上线的版本中负责开发的同学，都需要提交自己的上线checklist，最终合并到同一份上线checklist文档中去。上线checklist文档，就是在里面要写清楚每个人负责的那个部分，那个子系统的整个软件工程流程过程中，沉淀下来的所有文档，都需要附加在这份checklist文档中，一般比如说可以用一个word文档，在这个word文档中，附加上你每个过程对应的一个截图和报告。 

1、各系统的测试报告 

1.1 XX子系统的测试报告 

（1）单元测试报告：确认你的单元测试覆盖率是否达标

（2）冒烟测试报告：确认你的冒烟测试全部通过

（3）静态代码扫描报告：确认你的代码完全符合开发规范

（4）代码审查结果：就是在Gitlab中，你提交的PR最终会被人通过和merge，负责审核你的代码的人，他需要在审核之后，给出你一份总评，就是说，审核了你哪些哪些地方，然后最终判定通过，给一个截图。确认你的代码是经过审查的 

1.2 XX子系统的测试报告 

2、系统整体的测试报告 

2.1 集成测试报告

2.2 系统测试报告

2.3 验收测试报告 

这份文档，可以由架构师指派一个人去收集所有人沉淀下来的过程文档。一个大的需求版本上线，必须由这个系统的总架构师，亲自在上线前去审核这份文档，确保说，这个文档里反映出来的每个子系统都经过了良好和充足的测试，每个环节都做了，每个环节都按照标准、要求和规范去做了。 

二、上线文档 

架构师也可以指派一个人去做，有些公司，比如说一些较为传统的IT公司，一般对权限收的特别紧张，要求说只有经理才有级别去做什么代码合并，只有经理才有级别去操作线上系统，只有经理才有权限去执行上线。见过很多公司是这样子收缩权限的。 

我的风格不是这样的。一般来说，我的理念，是说，尽量提升团队里每个人的能力。如果要提升每个人的能力，那么最好的办法，就是把他扔到线上的血与火的环境中去锤炼。有的人可能就工作个两三年那样子，甚至是一两年。但是如果他足够有潜力，你想要培养他的话，那就尽可能让他去做更多的事情。 

尽量让年轻人做更多的事情 

（1）详细设计：让组员自己去做，锻炼他的系统设计能力，而不是只会写代码

（2）工程初始化：让组员去做，锻炼他们从0开始迅速搭建出来一个系统的能力，而不是只会在现有的框架基础之上去填充代码

（3）集成测试、系统测试、验收测试：尽量让各个组员自己去做，配合QA、PM、其他团队的RD，让他们去协调，去沟通，锻炼他们的跨团队的沟通协作能力

（4）系统上线：让年轻的成员去进行线上操作，这样可以真正锻炼他们的能力，让他们有线上操作和运维的能力 

如果高工走了，可能就没人能接活儿，没人去做设计，没有人会从0开始搭建一个工程出来，没人能协作组织跨团队的测试协作，没人能执行系统上线，和线上运维的一些操作 

可能就导致说，你作为一个架构师，很累，什么事情，都要事必躬亲 

1、初始化线上数据库 

（1）从哪儿导出来一份SQL文件

（2）在哪个线上数据库中执行这份SQL文件

（3）执行过后，需要检查一下，需要的128张表是否全部完成初始化 

2、部署系统到线上机器 

（1）将完整的代码，打成war包

（2）到线上的哪台机器上去，将tomcat停止

（3）然后用scp将war包上传到机器上去，然后放入tomcat的webapp目录下

（4）然后重新启动tomcat服务器

（5）观察系统启动日志，各个环节的初始化是否正常，比如说数据库连接池的初始化 

3、线上验证 

（1）系统成功部署之后

（2）对几个核心流程和功能，手动执行一些操作

（3）确认所有功能正常运行

（4）确认所有的日志都正常打印

（5）确认所有的数据库中的数据记录都正常 

三、执行上线 

执行上线，一般会有一个规范，就是在什么时间点，可以执行上线 

一般来说，是选择系统的低峰期 

分开来说，不同的系统上线的情况，可以允许的时间是不一样的 

（1）大版本，上线，v1.0，v1.2，一般是建议在晚上9点以后，就是在低峰期，甚至是建议在凌晨2点，凌晨5点

（2）小版本，修复一个bug，做了一些改动，一般是建议在非高峰期的一些相对低峰的时间段，可以执行上线，上午的10点以前，下午2点~4点 

执行上线的规范 

（1）需要超过2个以上的人在场

（2）一般是负责执行上线的同学，按照之前审核过的上线文档来一步一步执行操作

（3）级别较高的同学，高工，会去在旁边仔细看着他上线的每个步骤

（4）如果一旦出现任何问题，需要进行回滚，比如说，用之前版本的代码，再次重新上线

##### 08_线上运维规范

###### 01_线上运维规范

线上运维，最基本的一个事情，其实就是说线上系统，如果没有其他的什么技术挑战的话，主要就是出bug。如果出了bug，你怎么来解决，按照什么流程，谁来解决，解决之后，需要记录什么东西下来。 

线上bug处理的SOP 

Standard Operation Procedure：标准的操作步骤 

1、线上故障反馈群 

每个公司自己内部的IM，社交沟通的工具，钉钉，QQ，百度hi，咚咚 

但是很多小公司，也可能是微信群，QQ群 

得有一个专门的群是一个大群，这个群是专门给人反馈线上的bug的 

如果说，接收到了一个bug的反馈，用户提交的，产品经理发现，运营发现的，需要在线上bug反馈群中去抛出这个问题，同时打电话通知今天负责值班的人 

2、线上bug的分级标准 

（1）S级：直接影响了系统的核心主流程，比如电商里，不能查看商品，不能使用购物车，不能下订单，不能支付了。要求1小时内解决。

（2）A级：没有阻塞系统的核心主流程，但是在核心流程里发生了一些影响用户体验的bug，查看商品的时候，css样式乱了，商品无法排序。4小时内解决。

（3）B级：阻塞系统的非核心流程，无法发表评论了，无法对别人的评论点赞了。1天内解决。

（4）C级：没有阻塞系统的非核心流程，评论列表没法分页。3天内解决。 

3、线上bug反馈的模板 

（1）bug名称

（2）bug发生的时间

（3）bug提交人

（4）bug的详细描述

（5）bug的相关截图

（6）bug的分级

（7）相关系统

（8）相关负责人 

4、团队里的值班机制 

团队里，有5个人，那么就需要按照一定的顺序排好，每周谁怎么值日，7天，可以这样子，有些级别高的人，可以承担更多的责任，可以去值班两天，有些年轻的同学，而已值班一天就可以了 

（1）周一，小A

（2）周二，小B

（3）周三，老C

（4）周四，老C

（5）周五，老D

（6）周六，老D

（7）周日，小E 

当天负责值班的同学，需要保持全天24小时，手机电话畅通，持续关注公司里的交流群 

5、定位bug原因 

根据bug反馈报告，到线上系统打印的日志中去，看一些那个时间点，相关的日志，根据日志的情况，定位出是什么bug 

日志很重要的，如果日志打印的不好，那么根本没法排查线上的bug 

定位到bug的原因之后，立即在线上事故反馈群里，反馈一下，这个bug，它的问题找到了，原因是什么 

6、解决bug 

值班人，将bug转移给对应的bug负责人 

bug负责人此时需要从master分支拉一个bugfix分支出来，在自己本地跑起来整个系统，复现出来这个bug 

在本地修复这个bug和确认修复 

将bug合并到develop分支上去，由QA介入，在集成测试环境，确认说这个bug已经修复了 

将bug合并到master分支上去，在staging环境发布一下，由QA再次回归测试和验收，确保bug修复 

将master分支打一个tag，发布修复了bug的代码到线上去上线。给出上线checklist（bug反馈报告，原因，如何解决，bug修复测试的报告），给出一份上线文档（本次上线的步骤），执行具体的上线。 

7、将bug的完整过程记录到一个bug文档中去 

bug1 

（1）bug的反馈报告

（2）bug的定位原因

（3）bug的解决思路

（4）bug的上线文档

（5）bug的反思：为什么会出现这个bug？少了测试用例，在测试的时候，没有伪造一些异常的请求和数据去测试？或者少了一些校验和验证的系统设计？

（6）bug的后续改进步骤：在设计测试用例的时候，需要构造更多的异常的请求和数据；在系统设计的时候，需要考虑更多的校验逻辑 

8、将bug文档同步给团队里的leader和其他同学 

每个人都要仔细看这个bug的具体的步骤和情况，去学习bug，共同进步

#### 02_项目管理规范

##### 01_项目计划规范

###### 01_项目计划规范

1、活动清单 

活动清单，一般是每个人对自己负责的那个部分，需要自己在这个表格里填充对应的排期，因为只有自己负责的这个部分，自己是最熟悉的，大概是知道自己要做多长时间的。最终会汇总到一个完整的活动清单中去 

活动清单汇总完成之后，需要由架构师仔细审查每个人定的活动清单的人/日排期。最主要的是，根据架构师的丰富项目经验，要判断一下，每个人的每个工作，有没有多排期（职场里有很多老油条，是不好好干活的，比如说只要1天可以做完，2天，自己就可以多一天的时间出来自己玩儿，清闲一些），就需要架构师去判断，必要的时候需要对排期做调整，尽量保证排期是比较紧凑以及合理的。我个人的建议，架构师站在丰富的经验上，比如说我，如果我来带一个项目，在前期完全我来主导设计，然后评审每个人的详细设计之后，做了很多年的开发的人，对每个事情，每个工作任务，以那个人的能力和智商，大概要花费多少时间，其实大家心里都有数的。比如说我，基本我对排期的工作量的判断，99%。 

只可意会不可言传，没什么特别大的技巧，就是你如果工作了至少5~8年，以8年以上为最佳状态。那你对各种事情需要多少时间，门儿清 

有些同学，很积极主动的同学，可能希望自己是尽量少的时间里做更多的事情，他们跟上一种同学，相反。一件事情可能要2天，结果他们硬是给自己排了1天。需要大量的加班，排期很不健康的，很可能会导致项目会delay。架构师看到这种情况之后，要及时识别出来，有些同学排期太过于紧张，让他们增加一些排期。 

我个人建议，28法则。工作的排期，留出来20%的buffer，用80%的精力给做了。这种情况是最合适的。 

比如说一个工作大概是需要4天，那么你可以给排个5天。留20%的buffer。如果说正好是4天干完，多了一天出来，可以让手下的同学轻松一点，可以自己看看书，学习一下技术。如果说5天之内，出现了一些意外，导致4天内没有干完，20%的buffer顶上去，可以留有余地，不至于delay。根据我之前的一些实践，20%的buffer合理的。我常见到有些老油条，2倍，3倍，4倍，5倍的时间，去做一件事情。 

（1）架构师定好类似这样的一个表格

（2）通知组内每个同学，根据自己的详细设计的文档，在表格中填充自己的排期

（3）然后架构师组织一个排期评审会议，这个会议上，每个排期一条一条的过

（4）架构师重点关注，老油条和过度积极的同学，20%的buffer 

| 一级任务 | 二级任务 | 三级任务                   | 工作描述                                               | 负责人 | 所需人/日 | 备注                                                         |
| -------- | -------- | -------------------------- | ------------------------------------------------------ | ------ | --------- | ------------------------------------------------------------ |
| 系统设计 |          |                            |                                                        |        |           |                                                              |
|          | 概要设计 |                            |                                                        |        |           |                                                              |
|          |          | 编写概要设计文档           | 根据之前的需求分析文档，完成系统的概要设计文档         | 老D    | 5人/日    | 老D一个人花费5天时间去做                                     |
|          |          | 第一轮概要设计评审         | 找部门B和部门C中的三个架构师过来，帮忙评审概要设计文档 | 老D    | 5人/日    | 老D，小A，小B，老C，小E，团队中的5个人都要花费1天的时间来出席设计评审 |
|          |          | 第一轮修改概要设计文档     | 根据第一轮评审的意见完成的概要设计文档的修改           | 老D    | 2人/日    |                                                              |
|          | 详细设计 |                            |                                                        |        |           |                                                              |
|          |          | 编写XX子系统的详细设计文档 |                                                        | 小A    | 5人/日    |                                                              |
|          |          | 编写XX子系统的详细设计文档 |                                                        | 小B    | 5人/日    |                                                              |
| 系统开发 |          |                            |                                                        |        |           |                                                              |
|          | XX子系统 |                            |                                                        |        |           |                                                              |
|          |          | XX模块                     |                                                        | 小C    | 4人/日    | 包含编码、单元测试、冒烟测试                                 |
|          |          | XX模块                     |                                                        | 小C    | 3人/日    | 包含编码、单元测试、冒烟测试                                 |
|          | XX子系统 |                            |                                                        |        |           |                                                              |
|          |          | XX模块                     |                                                        | 小E    | 5人/日    | 包含编码、单元测试、冒烟测试                                 |
|          |          | XX模块                     |                                                        | 小E    | 3人/日    | 包含编码、单元测试、冒烟测试                                 |
| 系统测试 |          |                            |                                                        |        |           |                                                              |
|          | 集成测试 |                            |                                                        |        |           |                                                              |
|          |          | 设计集成测试用例           |                                                        | 小M    | 10人/日   | 测试组的QA同学，负责设计用例                                 |
|          |          | XX主流程集成测试           |                                                        | 老D    | 20人/日   | 需要4人参与，每人投入5个工作日的时间，总人/日是20人/日       |
|          |          | XX主流程集成测试           |                                                        | 老D    | 20人/日   | 需要4人参与，每人投入5个工作日的时间，总人/日是20人/日       |

2、网络图 

画出来三级任务之间的执行流程和串联关系 

每个节点包含任务名称、负责人、所需人/日

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0412.gif) 

3、进度计划（甘特图） 

制定一个指导项目完整的进度计划的一张图，甘特图 

每个任务如何穿行，如何并行，将每个任务就不是以几人/日来表示，具体到某一个任务是从几号到几号 

使用甘特图绘制出来完整的进度计划

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0413.gif)

4、资源配置表 

在甘特图的基础之上，绘制出来每个任务的人员配置

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0414.gif) 

##### 02_项目执行规范

###### 01_项目执行规范 

1、执行计划 

项目管理的一大重要实践准则：从多年项目的血与火的锤炼中，总结出来的真理和真谛。项目的执行计划，绝对是要在执行的时候，定到非常非常详细的一个颗粒度。务必细化到每个人每天要干什么，每天要干的事情，要写的非常的详细。接下来，做项目执行监控的时候，是完全按照每天的一个粒度，去检查每个人这一天干活儿干的怎么样，事儿干完了没有，有没有什么问题。 

为下一周执行详细的执行计划，务必非常仔细，细化到每一天 

每个人做的第一件事情，要求团队中的每个同学，都必须按照自己在项目管理计划中的排期，将每个任务拆解，拆解到非常详细，细粒度，细化到每天要做1234哪些事情，形成自己的一份下周每天要工作的执行计划 

| 人员     | 本周主要任务                                                 | 周一                                                         | 周二                                                         | 周三                                                         | 周四                                                         | 周五                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 小A      | 1、完成订单系统的X1模块（3人/日）   2、完成订单系统的X2模块（2人/日） | 1、完成订单系统的X1模块的X1功能的开发【100%】   2、对订单系统的X1模块的X1功能，完成单元测试的编写【50%】   3、对订单系统的X1模块的X1功能，完成冒烟测试的执行【delay，60%】 | 1、完成订单系统的X1模块的X2功能的开发【100%】   2、对订单系统的X1模块的X2功能，完成单元测试的编写【100%】   3、对订单系统的X2模块的X1功能，完成冒烟测试的执行【100%】   4、晚上加班2小时，对订单系统的X1模块的X1功能，执行冒烟测试，进度预期达到80%【80%】 | 1、完成订单系统的X1模块的X3功能的开发   2、对订单系统的X1模块的X3功能，完成单元测试的编写   3、对订单系统的X1模块的X3功能，完成冒烟测试的执行   4、晚上加班2小时，对订单系统的X1模块的X1功能，完成冒烟测试的执行【100%】 | 1、完成订单系统的X2模块的X1功能的开发   2、对订单系统的X2模块的X1功能，完成单元测试的编写   3、对订单系统的X2模块的X1功能，完成冒烟测试的执行 | 1、完成订单系统的X2模块的X2功能的开发   2、对订单系统的X2模块的X2功能，完成单元测试的编写   3、对订单系统的X2模块的X2功能，完成冒烟测试的执行 |
| 小B      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 小C      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 老D      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 老E      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 问题汇总 |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 编号     | 问题                                                         | 问题发生原因                                                 | 解决对策                                                     | 需要的帮助                                                   | 反馈人                                                       |                                                              |
| 1        | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库      或者      在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无   （有可能会是什么呢？如果是跨团队协作的时候，是需要帮助。让运维给你干个什么事儿，调整一个linux的内核参数，你没有权限。那哥儿们特别不靠谱，为人懒散）      需要某某leader，出面协调，java后端组的老大，去找运维组的老大去协调，让那个不靠谱的运维把linux内核参数给调了 | 小A                                                          |                                                              |

2、类百度的站立会制度 

B里面，有非常好的一个传统，每天早上10分钟站立会制度 

每天早上一上班，第一件事情，就是开站立会，不要找会议室，很麻烦。直接定一个公司里的某个角落。项目组相关的人全部聚齐在这个地方。每个人1分钟以内，整体控制在20分钟以内，尽量在10分钟以内 

通过这个东西，一个架构师，或者说一个项目的leader和负责人，可以通过face to face，面对面的方式，去把控说，按照那个细粒度的每个人的执行计划，每个人每天的活儿有没有干完，就是有了这样的一个到天粒度的项目进度的监控机制，就可以确保说，人的懒癌就没法犯了。你要是懒癌犯了，昨天跑了，任务没干完，第二天站立会制度直接就被戳穿了，频繁几次的话，你就可以等着被开除了。价值观，在瞎干。 

（1）每个人说自己昨天完成了什么工作，今天计划完成什么工作，目前是否发现了什么问题，打算如何解决

（2）项目负责人将每个人的进度更新到执行计划中去，对完成的任务标志一个状态，状态包括了【已完成】【进度60%】【进度50%，delay】【取消】

（3）项目负责人将每个人反馈的问题更新到问题汇总中去，包括了问题是什么？为题发生的原因是什么？如何解决问题？执行计划是否需要调整？ 

根据经验来看，一般如果你push每个同学将项目的进度定的粒度很细，到每天的一个粒度，每天按照站立会的制度去check昨天的进展，出现问题立即解决，给出补救的措施，一般来说，补救措施，都是加班，或者采取某些方案+加班，晚上加班，周末加班 

99%的情况下，每天的站立会都很快，一般都是完成完成完成 

在这样的一个制度下，每个人每天早上都在一个集体中去说自己活儿干的怎么样，人要脸树要皮，每个人都是有一定的自尊心，要面子的，懒癌，犯懒，为了自己最基本的在团队里继续待下去的一个尊严，其实每个人都会尽力将每天的每个事情做完 

3、个人周报 

每周五的下午，每个人准备好自己的个人周报，组织周会 

| 姓名：       | 小A                                                          | 部门：                                                       | Java后端组                                                   | 项目：     | 电商系统v1.0 | 2017.05.26~2017.05.30 |      |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- | ------------ | --------------------- | ---- |
| 本周主要工作 |                                                              |                                                              |                                                              |            |              |                       |      |
| 编号         | 工作内容                                                     | 工作细节以及完成情况                                         |                                                              |            |              |                       |      |
| 1            | 订单系统的X1模块                                             | 1、订单系统的X1模块的X1功能，完成开发、单元测试、冒烟测试【100%】   2、订单系统的X1模块的X2功能，完成开发、单元测试、冒烟测试【100%】   3、订单系统的X1模块的X3功能，完成开发、单元测试、冒烟测试【100%】 |                                                              |            |              |                       |      |
| 2            | 订单系统的X2模块                                             | 1、订单系统的X2模块的X1功能，完成开发、单元测试、冒烟测试【100%】   2、订单系统的X2模块的X2功能，完成开发、单元测试、冒烟测试【100%】 |                                                              |            |              |                       |      |
| 问题汇总     |                                                              |                                                              |                                                              |            |              |                       |      |
| 编号         | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助 |              |                       |      |
| 1            | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库      或者      在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无         |              |                       |      |
|              |                                                              |                                                              |                                                              |            |              |                       |      |

4、每个人的下周执行计划 

| 人员     | 本周主要任务                                                 | 周一                                        | 周二                                       | 周三                                  | 周四                                  | 周五                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------ | ------------------------------------- | ------------------------------------- | ---------------------------------------- |
| 小A      | 1、配合QA完成用户下单购物主流程的集成测试（2人/日）   2、配合QA完成用户退货主流程的集成测试（3人/日） | 1、配合QA去执行用户下单购物主流程的集成测试 | 1、对集成测试中发现的bug完成相关的修复工作 | 1、配合QA执行第一轮退货流程的集成测试 | 1、配合QA执行第二轮退货流程的集成测试 | 1、完成退货流程集成测试中发现的bug的修复 |
| 小B      |                                                              |                                             |                                            |                                       |                                       |                                          |
| 小C      |                                                              |                                             |                                            |                                       |                                       |                                          |
| 问题汇总 |                                                              |                                             |                                            |                                       |                                       |                                          |
| 编号     | 问题                                                         | 问题发生原因                                | 解决对策                                   | 需要的帮助                            | 反馈人                                |                                          |
|          |                                                              |                                             |                                            |                                       |                                       |                                          |

5、项目周报 

| 项目名称：           | 订单系统v1.0                                                 |                                                              |                                                              |            |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| 部门：               | Java后端团队                                                 | 起止日期：                                                   | 2017.06.01~2017.06.05                                        |            |
| 本周主要任务         |                                                              |                                                              |                                                              |            |
| 编号                 | 任务                                                         | 完成状态                                                     | 持续时间                                                     |            |
| 1                    | 订单系统的X1模块                                             | 100%                                                         | 2017.05.26~2017.05.28                                        |            |
| 2                    | 订单系统的X2模块                                             | 100%                                                         | 2017.05.29~2017.05.30                                        |            |
| 本周遇到的问题和对策 |                                                              |                                                              |                                                              |            |
| 编号                 | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助 |
| 1                    | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库      或者      在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无         |
| 下周主要任务         |                                                              |                                                              |                                                              |            |
| 编号                 | 任务                                                         | 持续时间                                                     |                                                              |            |
| 1                    | 完成用户下单购物主流程的集成测试（2人/日）                   | 2017.06.01~2017.06.02                                        |                                                              |            |
| 2                    | 完成用户退货主流程的集成测试（3人/日）                       | 2017.06.03~2017.06.05                                        |                                                              |            |
|                      |                                                              |                                                              |                                                              |            |

##### 03_风险管理规范

###### 01_风险管理规范

风险管理 

讲过，项目管理的过程中，一定是会遇到一些风险的。那么有些风险是比较小的，或者没有提前预料。如果没有提前预料到的一些风险，发生了，其实就是在我们每天的站立会里，就会问每个人，执行每项工作，是否遇到了一些问题，那么那些问题就是发生的一些风险。但是对于这种风险的话，一般会通过问题的处理方案和补救措施来解决，那么这样的话呢，我们之前就已经讲解过了这样的一种情况。 

但是如果每次都是光靠风险发生了，问题都发生了，然后事后我们第二天才知道，才开始想办法去如何解决，采取什么样的对策，那可能有的时候就晚了。因为你光是考虑出来具体的对策，可能就需要耗费一些时间，而且为了解决这个风险或者是问题，你可能还需要耗费更多的时间去做一些事情。风险但是如果我们事前就可以识别出来项目进展的过程中，可能会发生什么样的问题和风险，然后提前就识别出来了，然后提前就准备好了预案，那么等到风险真正发生的时候，我们就可以立即拿出来这套预案来执行和解决问题。 

给大家举一些例子，就是在提交每周的一个项目周报的时候，都需要在这个项目周报中，写清楚这个项目未来可能会有什么样的风险，然后我们准备好的风险预案是什么，风险是否发生了，如果发生之后，采取了什么方案来解决，风险解决的结果是什么。都需要在每周的项目周报中要写清楚的。风险管理，是项目管理中非常重要的一个环节。其实风险管理，也是比较复杂的，在很多公司里，尤其是一些传统的IT公司，会积累下来一份常见风险的模板，对每个新启动的项目，你做项目管理的时候，可以对照着风险的模板，去看一下说，我们这个项目中，是否有可能会发生这个模板里列出来的一些风险。 

这个东西，我觉得还是不同的公司是不一样的，传统IT公司，互联网公司，遇到的一些风险都是不一样的 

还是只能我们定义好一套处理风险的流程和规范，大家在真正做项目的时候，首先第一件事情，建立起来这个风险管理的意识，就是说， 你要有这个意识，我们需要去做风险管理。然后最怕的是说，你根本就没有这个风险管理的意识，在项目启动的时候，压根儿脑子就没去考虑过项目执行的过程中，可能会发生哪些风险。如果你压根儿就没去考虑，那是肯定不行的。你一定要去考虑说，我要有这个风险管理的意识。每次做项目的时候，就按照我们这一套流程和规范去走，尝试去识别出来有什么风险，尝试去制定一些风险的预案。 

最主要这块，还是说在你多年做项目的过程中，真正按照这个流程去积累经验，可能你的每个项目都会遇到一些问题，那些问题，实际上就是我说的你没有预料到的一些风险。如果你之前预料到了，那么就不是问题了，其实就是之前准备好的风险发生了，采用你的预案。如果你没有准备好会遇到这些问题，那么实际上遇到这些问题的时候，你就可以积累一下经验，可能会出现的风险是什么？ 

所以这块，也是属于只可意会不可言传，不同的项目，差异实在是太大了。传统IT行业，电信项目，业务，一做就是很多年。那么在这种情况下，你的技术，过程，都是类似的，你说还可以去使用之前积累下来的一些风险模板，去尝试规避。在我的经验而言，互联网行业 里做项目，不同的公司，不同的团队，不同的情况，不同的项目，其实风险的识别出来，提前能够预料到一些风险，主要靠架构师的经验，就是建立起来了一种对风险的第六感。识别出来这样那样的一些问题，这个都是多年积累而来的一个经验。 

小A同学遇到了一个问题，就是说在冒烟测试的时候，或者是集成测试的时候，突然发现说测试环境的redis集群挂掉了，需要运维人员去进行运维，比如说采用更高的机器配置来给你搭建redis集群。测试环境，突然发现测试环境的mysql挂了，测试用的mysql是一台服务器，上面建了不同的数据库，不同的系统和项目都在走，并行的在跑，然后就会发现说，有一个项目在集成测试环境里，或者是在系统测试环境里，在做压力测试。压力测试导致测试环境的mysql突然性能变得巨差，甚至直接就挂掉了。 

我后面，尽量会在做这个电商项目v1.0的时候，完全按照纯真实的项目过程，去给大家演示，我的第六感和判断，我们的这个项目在执行的过程中，可能会遇到一些什么样的风险，带着大家尽量在模拟真实的环境中去体验风险如何管理。 

风险识别、风险分析（发生概率、影响范围）、风险预案、风险监控

| 项目名称：           | 订单系统v1.0                                                 |                                                              |                                                              |                                                              |          |                                                              |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 部门：               | Java后端团队                                                 | 起止日期：                                                   | 2017.06.01~2017.06.05                                        |                                                              |          |                                                              |
| 本周主要任务         |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 任务                                                         | 完成状态                                                     | 持续时间                                                     |                                                              |          |                                                              |
| 1                    | 订单系统的X1模块                                             | 100%                                                         | 2017.05.26~2017.05.28                                        |                                                              |          |                                                              |
| 2                    | 订单系统的X2模块                                             | 100%                                                         | 2017.05.29~2017.05.30                                        |                                                              |          |                                                              |
| 本周遇到的问题和对策 |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助                                                   |          |                                                              |
| 1                    | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库      或者      在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无                                                           |          |                                                              |
| 下周主要任务         |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 任务                                                         | 持续时间                                                     |                                                              |                                                              |          |                                                              |
| 1                    | 完成用户下单购物主流程的集成测试（2人/日）                   | 2017.06.01~2017.06.02                                        |                                                              |                                                              |          |                                                              |
| 2                    | 完成用户退货主流程的集成测试（3人/日）                       | 2017.06.03~2017.06.05                                        |                                                              |                                                              |          |                                                              |
|                      |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 项目的主要风险       |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 风险                                                         | 发生概率                                                     | 影响范围                                                     | 应对预案                                                     | 是否发生 | 应对情况                                                     |
| 1                    | 系统测试预定是两轮测完所有bug，但是可能会出现两轮没有测完所有bug的情况 | 20%                                                          | 导致项目延期一到两周                                         | 接下来晚上和周末所有人过来加班，通过加班快速完成最后的几轮测试，以及所有bug的修复，尽量通过晚上和周末的加班来解决 | 是       | 通过连续3个晚上每晚加班4小时，包括周末加班两天，每天加班10小时，完成了额外的第三轮测试，项目没有延期 |

##### 04_变更管理规范

###### 01_变更管理规范

需求变更 

0、案例式的讲解 

比如说我们项目干到一半儿了，突然有一天，PM过来找你，这个项目的负责人，他说，有一个XX功能，能不能改一下实现方式，或者修改一下这个功能的运作流程，或者是对这个功能加强一下，比如说有一个查询的功能，商品查询。本来预定的商品查询的条件是4个，商品名称，商品编号，品牌，类别。整个咱们的这个系统和代码，都是按照这个预定义的需求去做的，包括这个功能的代码实现，包括这个功能内部的一些运转流程，包括之前设计好的设计模式，都是针对这个需求来的。 

结果这个PM跑过来找你说，诶，我发现这个需求好像不太对啊，好像这个功能需要改一改，再做一些加强，商品查询的功能，不能只是按照4个条件来查询，需要支持8个条件，比如商品状态、商品创建人、商品库存、商品好评率，他可能脑洞大开，又要让你加好多的查询条件。 

然后这个时候，你一听，如果要改动这个功能的话，可能要增加很多的工作量。那么此时一般来说，RD，思维，一定不是站在产品设计的角度去走的，我们一般都是站在技术实现的角度去考虑的。跟PM是完全不一样的，PM会觉得说增加4个查询条件对运营人员的工作效率可以起到大幅度的提升。但是对于你来说，如果要增加4个查询条件，可能导致多了几天的工期，甚至导致整个项目可能会delay。此时一般你会拒绝他，你会说，不好意思，我不想修改。 

但是此时，PM通常会这么说，不就是加几个查询条件吗，很简单的。有什么难的。甚至更有甚者，他提出的需求变更是加4个查询条件以及2个排序条件，支持按照什么什么规则去排序。然后他说很简单的，你就随便改一下，找一个人，花一个小时可能就搞定了。 

但是，你作为架构师，你考虑一下，是这么简单吗？首先，加的那4个查询条件，商品状态、商品创建人、商品库存、商品好评率。商品状态、商品创建人，还好说，因为你想一下，这两个字段可能是涵盖在商品的主信息表里，那么直接修改查询商品的条件就可以了。但是问题在于后面两个查询条件，商品库存、商品好评率，这个就不简单了，因为可能是需要将商品跟库存表去关联，然后查询，商品好评率，可能也是一样的额，需要将商品数据跟评论表去关联，然后去查询。而且这里有一些问题，如果仅仅只是修改SQL也就算了，但是这里可能是挺复杂的，如果要做这些关联，你要去评估，索引有没有设计，SQL如果这么做的话，SQL的性能会不会大幅度下降。 

甚至，可能评论是放在别的数据库中，微服务里，你还不好直接去查询，可能还要请求别的服务的接口，从别的服务里获取这个数据到自己服务里来拼接，那么此时可能还要涉及到你要跟其他team的人去交流，可能还要让其他team的同学配合着加一个接口。 

评估，加4个查询条件：调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）、设计实现方案（详细设计文档）、开发、单元测试、冒烟测试、静态代码扫描、集成测试、系统测试 -> 耗费多少人力，首先负责开发的RD要耗费几天的时间 -> 此时代码修改了，要重新进行集成测试，耗费1个QA+4个RD，5个人重新再小黑屋里回归一遍 -> 耗费QA的时间，将这个功能重新进行功能测试 -> 不是说你就修改了部分代码，就重新测试部分代码就可以了，你只要修改了代码，那么原则上来说，我们又不知道你只是修改了部分代码，我们也不好确认说，你修改的这点代码有没有影响别的代码 -> 各个测试环节，全部进行全量的回归测试 

评估完了这个成本之后，你再来告诉PM，你还要不要随便这样子修改需求了？ 

案例式的方式，带着大家去走了一遍，修改需求的时候，会出现什么样的一个坑爹的情况 

1、需求变更的常见原因 

（1）不靠谱的原因 

PM不靠谱，99%的需求变更的情况，就是PM不靠谱，就是PM在进行产品设计的时候，思考这个产品需求的时候，没有考虑清楚，没有细化所有的需求，没有考虑到各种各样的情况。导致在系统开发到一半的时候，PM来搞这个事后马后炮。一开始的时候，是按照4个条件来查询，8个条件，10个条件，支持所有列双击界面上的列头，都可以按照那个列来排序。PM自己上手，1个小时就可以搞定这个事情。 

大家按照PM没有考虑清楚的需求文档就开始做了，结果开发到一半儿，PM反悔了 

（2）靠谱的原因 

常见于市场竞争态势的变化 

比如我们以前开发一个产品，市面上是有几个竞争对手的，BAT现在也开始在做很多产品，对外也都是竞争的。我们有一个大版本，是持续两个月的。结果在做到一半的时候，市场竞争态势出现了变化，就是竞争对手率先推出了新的功能，抢占了一些用户和市场。此时我们的高管就着急了，副总裁级别的人，副总就直接下命令说，必须在这个版本中加入某某某功能，要跟我们的竞对要持平。 

我们作为技术人员的价值在哪儿？就是我们开发出来的东西，他一定是要为公司产生直接的经济效益的。节省成本，增加市场占有率，增加用户流量。 

对于这种靠谱的原因，那么作为我们RD来说，义不容辞的，有价值观。我印象里有一句话，我之前就是做项目的时候，碰到过几次类似这样的情况，有同事就特别棒，他说的是，上刀山下油锅，都必须把这个东西给做出来。 

如果一个RD胡乱按照自己的思维去做事情，完全不考虑公司的利益，那你作为一个RD就没有存在的价值了，可以被公司开除 

靠谱原因仅仅占比1% 

2、对待需求变更的思路 

（1）对不靠谱的需求变更 

第一点 

要加强需求评审的意识，就是说作为RD，你在评审产品经理编写的产品设计文档，产品需求文档的时候，你一定一定要仔细看每个环节，仔细的去思考这个产品的每个需求的细节，力求脑子里基本上就知道为了做这个需求，大概技术设计该怎么做。如果在评审需求文档的时候，你感觉可能会有坑，赶紧提出来，给PM提前提意见，让他提前调研和思考清楚，有些功能要不要做。 

比如说商品查询的功能，作为一个RD，你要有一定的产品意识，当你工作了很多年之后，做了很多的项目之后，建立起来了比较丰富的工作经验，对待产品的设计，你虽然没设计过，但是你做过很多产品，你培养起来了自己的一种第六感。站在这个第六感的角度，你可以去考虑一下，每个产品需求功能，是否靠谱。比如对于商品查询的功能，你就可以站在产品设计的角度，去考量以下，诶，这个商品查询就4个条件，是不是太少了？这个时候这句话，可能就是你的第六感告诉你的。然后你就要反馈给产品经理，让它重新在考虑一下，说这个商品查询，你再想想，要不要加入更多的查询条件。 

也许通过你的很牛的第六感的提议，可以让产品经理提前把一些坑给填了，不至于后面给你挖坑 

倒逼产品经理去完善需求文档，你的脑子里，在看完需求文档之后，脑子里基本要建立起来一个流程、概念和意识，就是大体上你都知道系统层面，需要怎么做系统开发，来实现这样的一些需求和功能。那么如果你在脑子里思考技术和系统实现的时候，感觉有些问题，感觉有些需求模模糊糊的，不清不楚的，那么此时就要在需求评审的时候，提出建议，让PM反过来去完善需求文档，细化，重新思考。 

我们之前写好了一份需求文档，但是那份需求文档是一定有不够完善的地方的。那么接下来我们做系统的时候，就站在架构师的较多，从需求评审开始，一点一点去评审整个流程，在脑海中去思考这个系统层面怎么去做这个东西。如果感觉有不靠谱的地方，可以记录下来需求评审意见。我们自己模拟自己是产品经理，去完善这个需求文档。 

这个大家不要觉得这个事情很虚，这个都是架构师非常重要的软素质。 

第二点 

如果是在开发过程中，不靠谱PM提出来不靠谱的需求变更，判断出来是99%的情况，直接打回去，作为一个架构师，你要据理力争，否则如果你不断的妥协的话，你就会导致你手下的弟兄，像一群猴儿一样被PM耍的团团转。如果你接受PM提出的不靠谱的需求变更，你手下的弟兄就会各种反复加班，去修改代码，去满足那些乱七八糟的要求。你是在坑你的弟兄。 

直接给他打回去，如果他一定要做，让他找产品总监，直接对接你上面的技术总监，让两个总监去PK。 

如果打回去之后，因为产品总监过于强势，强行逼迫你的技术总监答应，要改动这个东西，就走后续的需求变更的流程，技术总监审批，delay 

（2）对靠谱的需求变更 

无条件接受了，但是要说清楚，肯定要走一个需求变更的流程，需要有高层领导，技术总监级别的人，要审批 

一旦有需求变更，基本上就意味着，肯定要延期，工期增加了，正常延期，找你的技术总监去审批 

3、需求变更的流程 

3.1 PM发起需求变更的申请 

一份需求变更的申请模板 

（1）商品系统-商品管理模块-商品查询功能 

（2）原有的需求是 

按照4个条件来查询商品，4个条件包括了：商品名称，商品编号，品牌，类别 

（3）现在需要将需求改动为 

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率 

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序 

（4）需求改动的原因 

需要支持这样的功能，来辅助商品相关的运营人员去更好的管理商品，在需要的时候可以尽快查出想要查看的商品数据，而且支持商品列表按字段来排序 

3.2 需求变更的评估 

找具体负责这个需求的同学来评估一下，要为了这个需求做哪些事情，耗费多少人日，从几号到几号，导致项目delay几天 

（1）商品系统-商品管理模块-商品查询功能 

（2）将这个功能改动为 

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率 

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序 

（3）需要改动的一个步骤是 

调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）：1人/日

设计实现方案（详细设计文档）：1人/日

重新开发：1人/日

单元测试：1人/日

冒烟测试：1人/日

静态代码扫描：1人/日

集成测试：2人/日

系统测试：2人/日 

（4）改动持续的时间 

从6月5号持续到6月15号 

（5）耗费的成本 

耗费总人/日是10人/日 

（6）对项目进度的影响 

导致项目整体delay达到10天 

3.3 对需求变更进行审批 

架构师负责将这个需求变更的申请和评估报告，提交给技术总监 

项目delay是一个大事，轻则影响绩效，重则影响公司业务发展你要被开除，p2p领域，数一数二的龙头，XX贷。XX贷出来的一个同学，就是做一个项目，delay了一个月。领导直接二话不说，开除。北邮的硕士，XX贷公司背景也很好，但是背上了项目delay被开除的结果，到很多公司面试都碰壁。离职证明上会写明，由于该员工项目delay，所以公司决定与其解除劳动合同。 

技术总监负责对这个delay的时间进行考评，考量过后，确认通过审批 

4、具体去实施这个需求变更 

项目管理计划的4张图都要修改，很多任务都要delay，额外加入了一些任务 

当前正在进行的本周或者是下周的执行计划里，要修改，加入这个额外的任务 

接下来，照着修改过后的项目管理计划，和每周的执行计划，去执行就可以了，就开始干这个额外增加的新需求

#### 03_技术调研规范

#####  01_技术调研规范


 1、什么时候做技术调研？ 

一般来说是在做完了需求评审之后，我们已经评审完了需求，知道了要做一个什么样的系统，大概也知道了这个系统的复杂度，功能有多少，对性能的要求是什么样子的，数据量会有多大，并发量会有多大。接着我们就会做需求分析，在需求分析之后，我们从技术角度去定义清楚了这个系统要做成什么样子，包括功能长什么样子，系统运转的流程是什么样子，有哪些特殊的需求（并发性、可用性、数据量、安全性）。 

接着就是要做技术了，但是这里有个问题，可能在做技术设计之前，我们会发现说，作为架构师，你可能想要用一些新的技术，来做这个项目。比如说用Spring Boot来作为整个系统的脚手架框架， 让系统的框架整合和启动效率更加高一些；我们还希望使用一些设计模式，来更好的设计我们的系统中的各个代码组件，保证我们的系统的代码的可扩展性是非常高的；因为团队越来越大，需求越来越复杂，多团队并行开发需求，特别频繁，这个时候可能需要微服务的架构来解决这个问题，可能又要去学习Spring Cloud、DevOps等知识来做微服务的架构。 

所以严格意义上来说，在需求评审过后、需求分析完成后、技术设计开始前，需要进行一些技术调研，为后续的系统设计，储备需要的技术 

2、如何去做这个技术调研？ 

一般来说，我的风格，一般做一个新的项目，我们都会尽可能去增加一些最新的技术，最流行的一些东西。互联网行业，好就好在这里，互联网行业是一个比较开放，快速变化，会承担很多的技术挑战的一个行业，传统IT行业是不太一样的。互联网行业，你一半要做的是说，开发一个系统出来，支撑你的这个互联网公司的整个业务的发展，此时你要承载的就是更多的用户，更大的访问量，高并发，高性能，高可用，安全性，快速迭代，你要负责去解决这些技术挑战。 

而行业里，不断的每年都涌现出一些新的技术出来，都是为了解决各种各样的问题而产生的，此时对于互联网行业来说，一般就是快速的去吸收这些全新的技术和理念，思想，架构，基于这些最新的东西，来重构自己的架构设计，让自己的架构更好，可以解决更多的技术挑战和问题，更好的服务公司的业务发展。 

传统的IT行业，我开发出来一个IT产品，IT系统，去服务于我的客户，为我的客户提供软件系统的功能，去更好的让我的客户的业务实现发展。IT系统，承担的用户都是一个公司内的一些员工。一般技术挑战很少，更加重要的是说，我每次接到一个单子，要做一个系统，如何能够以更低的成本，直接复用之前的代码，稍微改一改，就可以服务于新的客户，快速交付，用更少的人力去交付产品，获取利润。 

如果要不断的使用新技术，就意味着传统的IT行业要不断的投入大量的人力物力去研究技术，不断的去重构自己之前已经做好的系统。这个对于传统IT行业来说，是没有意义的。如果10年前开发好的一套系统，10年后还能继续给新的用户来使用。成本很低，但是可以不断获取利润。我是传统IT企业的老板，我也不会干这事儿。对于传统IT企业来说，如果要用新技术，重新做这个系统，一定是有原因的。 

之前大数据火了，其实很多传统的数据项目，用oracle搞定，但是人家客户不认，我要做大数据，流行，跟风啊，数据量很少，还得去部署那种几台机器的小集群，与运行hadoop，hbase，spark，一整套技术。oracle集群可能就搞定了。 

互联网行业的公司，一般技术更好，用的技术更新，承担的技术挑战更大，出来的人技术能力更强，工资更高。互联网行业工作5年的人，薪资就在30~35k之间了。 

传统IT行业的公司，一般技术较为陈旧，技术更新很慢，系统没什么技术挑战，出来的人技术能力较为平庸，工资较为平平。20~25k，少了10k，这都是有可能的。 

每次做新的项目，必定会有技术调研的环节，因为在互联网行业中，拥抱新技术，快速使用新技术，尽快的去实践新技术，保证自己的系统架构是最好的。 

spark课程，2015年出过spark课程，2013年~2014年某个时间点，spark 0.2.x版本，刚刚出来，很原始的时候，我当时还在BAT某公司里，我应该就是最早去实践和使用spark的人之一，在国内。spark的技术大量的实践，踩过大量的坑，积累很多的经验。所以在2015年推出了spark课程。 

组织团队内的各个同学，每个人负责一个技术，去调研一下这个技术 

3、技术调研的流程和规范 

3.1 技术有哪些功能 

看官网，要求我的同学看官网，不行的话就买一些中文的书，或者技术博客 

写一个demo快速入门一下，对那个技术看一下初步的介绍，这个技术是干什么的 

仔细看一下这个技术官网相关的官方文档，买一本书看看，里面的重点以及核心的技术都实践一下 

3.2 技术的热门和流行程度 

（1）开源技术的GitHub的更新频率：如果保持较好的更新频率，那是ok的；但是如果这个技术很少更新，那就不要考虑了

（2）这个技术在国内的运用怎么样：是否足够热门，在国内有哪些公司在使用这个技术

（3）这个技术在国内的中文资料是否足够多：如果中文资料足够多，就说明这个技术较为热门，有更多的资料可以参考 

3.3 技术跟公司的整体技术环境是否适合整合 

比如说你如果用Spring Cloud，假如说你在阿里，那就肯定不合适了，其他一些大公司。因为那些大公司都是自己研发的微服务的整体架构，都是用自己的东西的。如果你冷不丁搞一个跟公司开发好的基础设施架构重复的东西，那肯定是不合适的。 

3.4 看一下这个技术的其他的方方面面 

（1）易用性：是否足够简单上手使用

（2）稳定性：是否足够稳定可以使用，bug较少

（3）功能性：功能是否足够完善和强大

（4）与其他技术的整合性：能否良好的跟其他相关的技术进行整合

（5）性能：类似Spring Boot框架，就没什么好说的了；redis，memcached，mongodb，elasticsearch。适当自己在测试环境下，做一些简单的性能测试

（6）并发能力（吞吐量）：每秒可以承载多少请求，做一些简单的压力测试

（7）可用性：这个技术是否提供了高可用部署的机制，比如redis就可以基于redis sentinal哨兵机制实现高可用架构，做一些简单的故障演练

（8）伸缩性：这个技术如果需要扩容的话，是否可以扩容

（9）扩展性：是否可以对这个技术进行一定程度上的扩展，比如说Spring Boot，就可以支持我们自己写spring-boot-starter-x的项目，支持我们自己将Spring Boot跟其他技术进行整合

（10）安全性：这个技术是否足够安全，没有过多的安全漏洞，struts2框架，安全漏洞频频爆出 

3.5 技术跟同类技术的横向对比调研 

Spring Cloud -> Dubbo -> DubboX

Thymeleaf -> freemarker -> velocity

Redis -> Memcached

Elasticsearch -> Solor 

对比哪些方面呢？就是上面说的那些方面，产出一份横向对比的表格 

3.6 选择这个技术的理由 

调研完了，了解清楚了这个技术了，也跟其他技术对比了优势和劣势了 

4、编写技术的培训手册 

一般是用ppt的形式来变现的，主要是在决定选择使用一个新技术之后，需要将这个技术编写成使用手册，引入团队中，对团队进行培训 

（1）介绍清楚这个技术的基本原理

（2）介绍清楚这个技术的核心功能

（3）介绍清楚这个技术的一些调研情况

（4）给出这个技术使用的demo，不是特别简单的demo，而是将这个技术引入我们的公司环境中，如何跟公司现有的技术栈整合，如何在公司的项目里去使用这个技术 

5、对团队里的成员进行培训 

每个人都要学习清楚这个技术是怎么回事儿，在项目中来使用的时候，每个人都能得心应手 

6、就可以将这个新技术用到我们的项目的技术设计中去了 

7、课程里，就会对每个技术的学习，都模拟成是，你现在要为你的公司引入这门技术，然后你学习就是在做调研。完全模拟公司里真实的技术调研和引入的环境和流程以及场景。Spring Boot和设计模式。

#### 04_需求评审

##### 01_电商系统v1.0版需求评审记录

一、权限中心需求评审建议 

1、权限树的每个节点，显示什么东西？

2、添加根节点的时候，怎么添加，点击哪个按钮？

3、同上，添加子节点、编辑节点、删除节点，该怎么操作？

4、不要单纯的在纯前端去操作一颗权限树，操作完了以后，一次性同步这棵树，那样的话会导致我们的后台逻辑，太复杂

5、新增角色的界面中，对于表单显示哪些字段、权限树操作的一些细节，都比较模糊，希望予以补充

6、同上，编辑角色的界面中，很多细节信息，比较模糊

7、启用/停用按钮，我们不清楚，什么时候显示启用，什么时候显示停用

8、角色列表的查询条件，默认值是什么？默认情况下查询出来哪些角色呢？

9、账号信息，是否需要添加更多员工的更加详细的信息？比如说地址之类的一些东西？

10、账号列表的查询条件，需要完善默认值

11、账号列表中，显示哪些字段啊？

12、添加账号的操作，很多信息比较模糊，不够完善，比如说点击按钮过后，是会显示什么东西呢？

13、编辑账号的操作，同上，很多地方比较模糊，希望予以完善

14、启用/停用账号的操作，修改密码操作，同上，很多地方比较模糊，希望予以完善

15、权限控制那块，左侧菜单栏的显示，权限应该一般是三级的，是否会四级五级的情况会出现？

16、既然不能限定四，就查询二级，或者是三级权限，作为菜单，那么如何区分菜单权限和按钮/其他权限呢？

17、架构师，给一个提议，第一个版本，要不先不做这么复杂，操作日志，直接基于tomcat日志来记录不就可以了么？就是说，内测版本，不涉及到什么对外，黑客，没有安全问题，那么是不是操作日志可以暂缓，等到后面的版本再来迭代。一个版本，我有时候一定要根据这个版本对应的背景，来考量，这个功能到底需要不需要。

18、架构师，给出一个建议，既然我们的v1.0版本是内测版，黑名单管理，不对外，可以暂时不做，后面的版本我们再迭代的

19、账号管理中，居然没有写删除的功能，补充一下 

二、商品中心需求评审建议 

1、属性管理这块，还是太模糊，增删改查，没有说明白具体的功能流程

2、类目管理这块，还是太模糊，没有说明白具体的功能流程

3、品牌管理这块，还是太模糊，没有说明白具体的功能流程

4、商品管理这块，还是太模糊，没有说明白具体的功能流程

5、刚开始第一期，不做库存自动预警相关的功能，可以讲那个字段先删除掉

6、刚开始第一期，是不打算让不同级别的会员享受不同的折扣的，因为这个纵观各个电商网站，现在主流都不是这么玩儿的了，会员的级别是享受，积分是3倍，5倍，一年享受10次免运维，以我的想法，就不要在这里这样做

7、第一期，就得支持到SKU粒度，去设置库存和价格，不能放到以后，SKU是实际的交易的载体

8、没有看到商品删除的功能，建议因为已经有了上架/下架的操作，不需要已删除的状态

9、删除属性的时候，是有类目关联属性的，要做一个限制，就是如果判断有类目还关联着这个属性，就不允许删除属性

10、删除类目和品牌的时候，也是的，如果有商品关联着某个类目和品牌，就不允许删除类目和品牌了

11、对商品粒度（SPU粒度）需要有一个商品编码，对SKU粒度（也需要单独设置一个编码）

12、对商品进行审核的时候，其实是需要点击审核按钮，进入一个审核界面，审核界面中提供商品的所有数据，最后给审核的选项，通过/不通过

13、商品审核，由谁来审核？有谁有这个权限可以去进行审核？建议，第一版做的简单一些，不区分谁能够来审批，但是需要记录下来审核人。假设的是电商公司刚开始，团队很小，可能商品的运营就两三个人，负责采购的就两三个人。那么可能就是比较简单的，就是某个人需要审核，就告诉工位旁边的领导，跟他说，你来审核一下。 

三、采购流程需求评审建议 

1、刚开始，电商公司刚开始经营，就不做自营供应商，第三方供应商，需求设计里可以取消掉自营供应商的环节

2、供应商CRUD的操作，没有给出具体的功能流程

3、对供应商的删除功能，提出异议，就是说供应商关联的数据实在是太多了，包括了采购单，财务结算单，如果允许物理删除，导致各个系统之间耦合太严重了。建议目前不要做删除的功能，仅仅能对供应商增加和修改，启用/停用的状态。

4、将供应商绩效的评级，添加到供应商列表中

5、供应商，看到了他是B级，A级，点击评级，可以进入一个页面，这个页面里可以查看到这个供应商他每一次交货的一个记录

6、对采购单管理的各种细节，还是很模糊，需要进行完善

7、采购单谁能进行审核，假设的是刚开始都是小团队作战，沟通成本很低，谁都能来审核，提交审核的人，告诉领导来审核即可。

8、就是在采购单发给供应商之后，没有一个财务打预付款的这么一个过程，连点定金都没有。一开始公司成立，用的供应商，都是老板以前的老人脉，老资源，不需要付预付款项，直接都是走商品入库以后，按照结算周期，按照周/月/季度，统一结算一次即可。

9、调度采购入库这块，实在是太简单了，都没法按照这么简单的需求去做系统设计。大家千万别觉得PM都很专业，我就见过太多的欠缺经验，不靠谱，刚毕业的，菜PM，设计出来的产品需求文档，第一个版本就跟我设计的差不多。很多细节他都没没有考虑到，很多地方都很模糊，甚至是一笔带过。开发人员就没办法根据他的产品设计文档，去进行技术的设计。

10、作为技术人员，猛烈的来抨击PM，作为我们的第一版系统，不应该做的这么复杂。其实行业里，这块，如果做的比较简单的一些的话，他是在采购入库单中，是可以由人工手动添加，将某个商品多少多少件，放到了哪个货位上去。然后呢，仓库里的工作人员，接到了采购入库单，指导每个商品要过来多少件，然后呢，实际商品到货之后，仓库工作人员，负责将商品，自己人工选择，将哪些商品放到哪个货架上去，通过肉眼去判断，每个货架还有多少剩余空间，商品应该怎么来放置。工作人员，可以从最近的货位开始，去寻找还有空余空间的货位，依次将商品上到货位里面去。每次上一批商品到货位中去以后，会在采购入库单中，更新一下，将哪个商品，多少件，给放到了哪个货位中去。

11、WMS中，没有定义创建采购入库单新建的逻辑

12、WMS中，采购入库单列表、编辑、审核，还是较为简单，比较模糊

13、WMS中，对采购入库单审核后的一些流程，定义的非常模糊，不太清晰

14、财务中心，采购结算单的这个管理，定义的非常模糊，不太清晰

15、财务中心，没有定义清楚如何在财务结算单审核通过之后，如何对供应商进行打款 

四、购物流程需求评审建议 

1、站在架构师的角度，第一版是内测版，还是建议不要太过于复杂。首页建议跟前端直接约定好，由前端直接做死。我们在后台初始化好一堆类目树以后，我们会告诉他，我们希望他在前台展示的左侧类目树是什么样子的，点击一个类目才会访问我们的后台接口。搜索框，也是，搜索的时候，访问我们的后台接口。中间的轮播广告，建议直接就是纯前端做死，点击可能是进入某个活动页面，也可能是直接访问我们后台接口，进入某个商品的详情页。下面的每个类目的热门商品，直接做死，点击之后访问后台接口，进入咱们的商品详情页。 

2、站在技术的角度来分析一下，我们不要看京东做的多么好，多庞大的技术团队在做。如果要搜索一个词，然后可以出来一个商品列表页，同时上面还要有筛选条件。大家考虑一下，这个筛选条件是怎么出来的？必须是你搜索的关键词，他要智能的识别出来是属于哪个类目的？因为知道了是要搜索哪个类目的，才能将那个类目的所有导购属性的值提取出来，动态做成筛选条件？这块第一版，是不太好做的，建议不做。建议是什么呢？一旦搜索某个商品之后，直接就出来一个商品列表页，在商品列表页中，可以分页浏览，暂时不支持进一步的条件筛选。 

3、在我真实的工作场景里，我给大家展现的都是我在进行需求评审的时候这个思考的一个这么过程，你要站在技术的角度，去各种权衡利弊，考虑当前这个版本的产品背景下，我们是不是可以做一些取舍。因为正经的产品，一定不是一口吃个大胖子的，一定是一步一步来的，刚开始第一个版本一定是粗糙的，很多功能还没有，但是核心功能可以跑出来，但是因为一些功能的不完善，只能内测，不能对外。 

4、一开始是不支持全文检索的，我们仅仅支持like的搜索，like %keyword%，左右模糊匹配。我们不想引入全文检索框架，内测，要求的就是流程跑通即可，一些使用的用户体验可以降低要求，降低技术的复杂性，加快第一个版本开发出来的一个速度。 

5、滚动广告那块，基于之前对首页的一个建议，那块建议就是要么是放一个广告，点击之后进入一个静态的广告页面，广告页面里可以有一些热门商品，点击热门商品进入我们的商品详情页即可；要么滚动广告里就是静态页面里做死一个商品，点击后直接进入商品详情页即可。 

6、基于首页的分析，建议每个类目的热门商品，直接静态页面里做死一些商品，点击之后进入商品详情页。 

7、这个配送至的功能，其实相对来说，我们不需要在一开始就做。为了优化快递物流的一个效率，其实在全国各地部署多个仓库，每个仓库支持一个区域。让你看一下， 你所在的那个区域对应的仓库有没有货，如果没有货，就不给你发货了。避免快递耗费的时间或者资金不大，可能你一个商品才50块钱，结果快递费要30块钱，这就尴尬了，从福建仓库一直运到西藏的仓库去。我们这里，一开始就是小电商，我们假设成，我们一开始就一个仓库，然后我们这个仓库是支持发全国各地的，基于第三方物流去发货的，下订单的时候，会根据商品选择好的一个物流运费的一个模板，根据那个模板会算出来我们的仓库发到你的地址，要多少运费，你自己去判断。建议说这个配送至就不做了。 

7、将商品加入购物车的过程，实在是太简单了，需要完善一下具体的流程 

8、我们已经假设了一个前提，刚开始做一个小型电商，很有可能就是面向一个区域的电商，刚开始主要做营销和宣传的可能就是公司和仓库所在地周围的一两个省份，或者是两三个省份，只需要一个仓库就可以了。就不需要所谓的区域内仓库是否有货，这边需要显示一下当前的商品总库存，当前要购买的这个数量在仓库中是否有货。比如说你总共库存就100件，你要购买200件，此时显示库存不足。 

9、运费不在购物车商品列表上方单独去计算了，直接就是在购物车下方，计算出一个总价：商品总价 - 优惠金额 + 商品运费 

10、活动库存和预售库存，先不用做，是配合以后的秒杀活动，拼团活动 

11、提交订单确认页的细节大量的完善 

12、正式提交订单之后，库存如何扣减和锁定的逻辑，需要完善

13、支付订单之后，库存扣减和锁定的逻辑，需要完善 

14、调度中心，调度销售出库这块，没有看到比较清晰的一个将商品调度到对应货位的一个算法，而且我们这里第一个版本采取一个简化的一个策略，就是指定就将商品调度到一个仓库里去，因为一开始我们假设自己就一个仓库。电商系统开在南京，小电商平台，针对的就是南京市的一些大学生，在南京有一个仓库就可以了。 

15、取消订单的时候，我们居然没有做这个提交订单的一个反向逻辑，需要将各个层次的库存重新改变一下，这里没有考虑到 

16、运费模板，是在创建商品的时候，就会跟商品进行绑定的，但是我们没有定义清楚这个运费模板管理的一些细节 

17、调度中心调度销售出库的细节没有完善 

18、无论是采购入库单、采购结算单、销售入库单，这些单子，我们都没有记录创建时间、操作人、最近一次操作时间、审核人、审核时间。 

19、整个销售出库流程中，很多细节都没有完善，所以这里都建议进行完善和细化 

五、退货流程需求评审建议

1、申请退货操作这块还是太简单了，不够详细。同时申请退货的时候，除了选择一个下拉里列表中的原因以外，还得有用户自己填写的备注。 

2、客服中心对退货工单的管理的流程，太模糊了，不够详细 

3、所以说我这里讲解的时候的确是一边讲解，一边我自己其实也是在飞速的运转大脑，在考虑 

4、调度退货入库那个环节，实际上是不做商品退货跟货位的关联的，入库的时候，由入库的工作人员自己根据最近货位的原则，去考虑如何将商品放到某一个货位中去 

5、采购入库的时候，没有细化仓库和调度中心的库存 

六、促销中心需求评审建议

1、站在架构角度提第一点建议，内测，建议是先促销活动不要针对会员级别，默认就是针对所有的人进行促销。而且实际上很多电商网站，大部分的促销活动，都是针对所有会员级别的 

2、通过促销中心，发现了商品得多出来一个字段，上架时间。一开始简化一下，不加上架时间字段了。 

3、促销中心的一些细节比较模糊，需要完善一下 

4、建议将价格计算模块，放到订单中心里，不是商品中心 

5、针对单个商品的优惠券，我们建议在这里暂时给砍掉，先不做，就做针对整个订单的优惠券。建议会员等级暂时别跟优惠券关联起来。建议，会员积分跟优惠券先不做绑定，建议就是免费发放的优惠券，删除推广范围这个字段。 

6、我们先不做优惠券的删除 

7、满减促销，其实还是要针对单个商品，范围可以是全部商品，还是要按照单个商品来计算，满赠促销，建议统一都是针对单个商品去算，这样比较简单一些 

8、购物车那块，可以给每个商品下拉框选择某个促销活动，但是购物车页面不会现场计算，统一走进入订单确认页面的时候，统一来计算价格，附加赠品

七、会员中心需求评审建议

1、会员等级我们是属于暂缓型：我们会去计算会员的成长分数，也会去增加会员的等级，但是一开始不给什么特权，以后考虑清楚了再说。这个很符合很多小网站刚起步的一个策略。京东、猫眼，刚开始你都感受不到会员，系统在默默的给你累加这个会员的分数和等级。 

2、建议评价送成长值，不设限最低金额 

3、会员积分目前仅仅是做，但是不提供积分兑换礼品的服务和功能

八、评论中心需求评审建议

1、评论暂时不做追评估 

2、WMS的库存调拨、库存盘点，我们这次不做，以后一定会做 

3、支付对账，刚开始不做

#### 05_需求分析

##### 01_电商系统v1.0版本需求分析文档 

1、引言

1.1 编写目的

需求分析文档用于对电商系统v1.0的需求文档进行分析，然后站在架构师的角度，去梳理清楚整个系统的功能组成以及业务流程。主要关注的点还是在业务层面，暂时不会考虑过多的技术。但是也还是会从技术层面去进行一些考量。

1.2 面向对象

该文档编写出来以后，面向的主要是技术团队的同学，包括架构师、高级工程师、初中级工程师。

1.3 参考文档

1、《电商系统v1.0产品需求文档》，具体参加项目附件

2、概述

2.1 开发意图

该电商系统完成开发之后主要针对下面的3个场景： 

1、可以对商品的采购和仓储进行管理，让公司可以采购商品到对应的仓库中去

2、可以对有的商品、会员、订单、支付、评论、促销等各种电商网站的核心功能进行管理

3、可以让电商网站的用户来网站中浏览和购买商品

2.2 功能结构图

[**电商系统v1.0****版本功能结构图**](https://www.processon.com/mindmap/5a76a1c8e4b0615ac04a3552)

2.3 功能简介

2.3.1 权限中心

主要是对电商系统的使用权限进行控制的，可以给每个电商公司的工作人员分配一个账号，接着给每个账号分配一个角色，每个角色可以分配一些权限。每个权限就代表了一个菜单、一个按钮、一个URL，控制公司里不同部门不同岗位的工作人员只能使用电商系统中一部分的功能，跟他的岗位相关的这些功能。

2.3.1.1 权限管理

对电商系统里的权限数据进行维护和管理

2.3.1.2 角色管理

对电商系统里的角色数据进行维护和管理

2.3.1.3 账号管理

对电商系统里的账号数据进行维护和管理

2.3.1.4 权限控制

对电商系统里的左侧菜单栏的展示，以及每个后台界面中的按钮的显示，URL请求访问，进行权限的控制 

2.3.2 商品中心 

主要就是负责对电商网站中的商品数据进行相关的维护和管理，有了商品数据之后，我们才可以执行后台仓库的商品采购，包括将商品数据提供出去给前台的页面展示，让用户来浏览商品和查看。 

2.3.2.1 属性管理 

可以管理商品的属性数据 

2.3.2.2 类目管理 

可以管理商品的类目数据 

2.3.2.3 品牌管理 

可以管理商品的品牌数据 

2.3.2.4 商品管理 

可以管理商品的商品本身的数据 

2.3.3 采购中心 

负责维护供应商的数据，还有就是负责维护采购单的数据，可以创建采购单将我们需要的商品采购入库 

2.3.3.1 供应商管理 

主要就是维护和管理供应商的数据和绩效 

2.3.3.2 采购单管理 

主要是可以进行采购开单，开单之后就可以发送采购单给供应商来采购商品到我们的仓库中去

2.3.4 WMS 

负责仓库管理，包括了仓库的基础数据的管理（仓库信息和货位信息），采购入库、销售出库、退货入库、仓库库存的管理 

2.3.4.1 仓库信息管理 

负责管理仓库的相关数据 

2.3.4.2 货位信息管理 

负责管理仓库中的货位相关的数据 

2.3.4.3 采购入库单管理 

采购开单之后，会同步采购入库单到这里来，在接收到供应商的发货之后，需要去维护采购入库单 

2.3.4.4 销售出库单管理 

用户下订单支付之后，就会同步一个销售出库单过来，在接收到这个单子之后，需要去将订单中的商品进行出库发货 

2.3.4.5 退货入库单管理 

用户申请退货，并且寄还商品到客服中心之后，会启动退货入库的流程 

2.3.4.6 仓库库存管理 

对仓库中的每个商品的库存，以及每个货位中每个商品的库存，进行管理 

2.3.5 会员中心 

2.3.5.1 会员注册 

支持用户基于手机号直接进行注册 

2.3.5.2 会员登录 

支持基于之前注册的账号来登录，或者是基于微信等第三方方式来登录 

2.3.5.3 会员个人信息 

可以查看和设置会员的个人信息 

2.3.5.4 会员等级管理 

可以根据会员在网站中的不同操作，完成会员成长值的增减，同时完成维护会员的等级，完成维护会员成长值变更的明细 

2.3.5.5 会员积分管理 

可以根据会员在网站中的不同操作，完成会员积分的增减，同时完成维护会员的积分增加明细 

2.3.6 商品展示 

2.3.6.1 商品搜索 

可以在网站的首页对商品执行搜索操作 

2.3.6.2 品类导航 

可以在网站的首页对品类进行导航 

2.3.6.3 商品列表页 

搜索商品，或者是品类导航，都会进入商品列表页 

2.3.6.4 商品详情页 

对商品列表页中的每个商品，都可以进入一个商品详情页

2.3.7 购物车 

2.3.7.1 加入购物车 

在商品详情页，可以点击加入购物车的按钮，将商品加入购物车中 

2.3.7.2 查看购物车 

查看购物车中的商品情况，可以选择一些商品去下订单 

2.3.7.3 购物车结算 

在购物车中选择了一些商品之后，就可以点击购物车结算按钮，进入订单确认页面 

2.3.8 订单中心

2.3.8.1 生成订单 

在订单确认页中完成订单确认之后，可以提交订单 

2.3.8.2 订单列表 

用户可以在订单列表页中查看自己的订单 

2.3.8.3 订单详情 

用户在订单列表页中选择某个订单，可以查看订单的详细信息 

2.3.8.4 取消订单 

用户可以选择手动取消某个未付款的订单，同时也可以由系统在24小时之后启动取消这个未付款的订单 

2.3.8.5 订单支付 

用户可以选择为这个订单支付对应的金额 

2.3.8.6 更新订单状态 

在对应的一些操作发生的时候，会来更新订单的状态 

2.3.8.7 查看物流进度 

用户在付款之后，可以查看物流的进度 

2.3.8.8 确认收货 

用户在收到货品之后，可以手动点击确认收货，也可以等待7天之后由系统自动确认收货 

2.3.8.9 申请退货 

用户在收到商品之后，如果不满意可以申请退货 

2.3.8.10 价格计算 

在订单的确认页面中，会根据订单的总金额，每个商品使用的促销活动，对订单使用的优惠券，运费，去计算出来订单最后的一个总金额

2.3.9 支付中心 

2.3.9.1 对接第三方支付 

在用户支付订单的时候，可以对接微信/支付宝来支付 

2.3.9.2 支付交易流水管理 

每次用户支付的时候，都需要去插入一笔交易流水，可以让后台管理人员查看交易的流水 

2.3.10 物流中 

2.3.10.1 运费模板管理 

每个商品都会关联一个运费模板 

2.3.10.2 运费计算 

在用户购买商品的时候，会根据这个运费模板去计算运费 

2.3.10.3 获取物流单 

在用户支付之后，调度中心调度发货的时候，会对这个订单跟物流中心通信，要求跟第三方物流商系统通信，申请一个物流单号 

2.3.10.4 物流追踪 

用户支付之后，可以查看物流的进度 

2.3.11 评论中心 

2.3.11.1 发表评论 

用户购买商品之后，可以手动发表评论，也可以由系统在30天之后自动发表评论 

2.3.11.2 评论管理 

管理员可以在后台对评论进行一个审核和管理 

2.3.11.3 评论前台展示 

在商品详情页中，会展示所有的评论 

2.3.12 促销中心 

2.3.12.1 促销活动管理 

可以管理电商网站中的促销活动的数据 

2.3.12.2 优惠券管理 

可以管理电商网站中的优惠券的数据 

2.3.13 客服中心 

2.3.13.1 退货工单管理 

在用户申请退货的时候，由客服去管理对应的退货工单 

2.3.14 财务中心 

2.3.14.1 采购结算单管理 

在采购入库完成之后，会有一个采购结算单，可以管理这块东西 

2.3.14.2 供应商结算管理 

在采购结算单完成审核之后，会周期性的给供应商打款结算 

2.3.14.3 物流公司打款管理 

在销售的时候，完成销售出库了，需要给物流公司打款 

2.3.14.4 退货打款管理 

在用户申请退货之后，并且将商品寄送到客服中心之后，会进行退货打款 

2.3.15 调度中心 

负责将采购入库、销售出库、退货入库，调度到仓库中去执行 

2.3.16 库存中心 

负责管理商品的库存

3、用例图

3.1 权限中心

3.1.1 用例图

[权限中心用例图](https://www.processon.com/diagraming/5a76d678e4b0874437ba3cac)

3.1.2 用例描述

所有的用例在需求文档中，都已经将用例对应功能说的较为明确，而且功能运行流程也比较清晰，所以不再这里赘述多余的描述了，避免跟需求文档重复

3.2 商品中心

3.2.1 用例图

[商品中心用例图](https://www.processon.com/diagraming/5a76daffe4b024b99bee9713)

3.2.2 用例描述

参考需求文档即可

3.3 采购中心

3.3.1 用例图

[采购中心用例图](https://www.processon.com/diagraming/5a76df01e4b0874437ba4534)

3.3.2 用例描述

参考需求文档即可

3.4 WMS

3.4.1 用例图

[WMS用例图](https://www.processon.com/diagraming/5a76e066e4b059c41ab42e21)

3.4.2 用例描述

参考需求文档即可

3.5 会员中心

3.5.1 用例图

[会员中心用例图](https://www.processon.com/diagraming/5a76e275e4b0615ac04a8275)

3.5.2 用例描述

参考需求文档即可

3.6 商品展示

3.6.1 用例图

[商品展示用例图](https://www.processon.com/diagraming/5a76e33fe4b0615ac04a830e) 

3.6.2 用例描述

参考需求文档即可

3.7 购物车

3.7.1 用例图

[购物车用例图](https://www.processon.com/diagraming/5a76e3a1e4b0615ac04a8353)

3.7.2 用例描述

参考需求文档即可

3.8 支付中心

3.8.1 用例图

[支付中心用例图](https://www.processon.com/diagraming/5a76e3f4e4b024b99bee9e47)

3.8.2 用例描述

参考需求文档即可

3.9 订单中心

3.9.1 用例图

[订单中心用例图](https://www.processon.com/diagraming/5a76e470e4b0874437ba49a6)

3.9.2 用例描述

参考需求文档即可

3.10 物流中心

3.10.1 用例图

[物流中心用例图](https://www.processon.com/diagraming/5a76e55fe4b024b99bee9f78)

3.10.2 用例描述

参考需求文档即可

3.11 评论中心

3.11.1 用例图

[评论中心用例图](https://www.processon.com/diagraming/5a76e5e3e4b024b99bee9fd9)

3.11.2 用例描述

参考需求文档即可

3.12 促销中心

3.12.1 用例图

[促销中心用例图](https://www.processon.com/diagraming/5a76e663e4b024b99beea033)

3.12.2 用例描述

参考需求文档即可

3.13 客服中心

3.13.1 用例图

[客服中心用例图](https://www.processon.com/diagraming/5a76e6d8e4b0615ac04a85b6)

3.13.2 用例描述

参考需求文档即可

3.14 财务中心

3.14.1 用例图

[财务中心用例图](https://www.processon.com/diagraming/5a76e718e4b059c41ab433b9)

3.14.2 用例描述

参考需求文档即可

3.15 调度中心

3.15.1 用例图

[调度中心用例图](https://www.processon.com/diagraming/5a76e81de4b064e9ddb68234)

3.15.2 用例描述

3.15.2.1 调度销售出库

1、简单描述 

在用户下了订单之后，并且对订单完成支付之后，订单中心就会通知调度中心，来调度这个订单中的商品从仓库里面发货 

2、事件流描述 

（1）创建销售出库单

（2）创建发货单

（3）跟物流中心通信，让物流中心去跟第三方物流厂商通信，获取到一个物流单

（4）同步销售出库单、发货单、物流单到WMS 

3、泳道图 

[调度销售出库泳道图](https://www.processon.com/diagraming/5a76e9e0e4b059c41ab435d3)

3.16 库存中心

3.16.1 用例图

[库存中心用例图](https://www.processon.com/diagraming/5a76e8b5e4b0812a0f059047)

3.16.2 用例描述

4、领域类图 

领域类图，一般就是从系统间的调用和流转，使用的核心数据类 

订单类，就是一个典型的领域类 

一般来说，领域类如何抽象，其实就是将需求文档中比较核心的那些数据抽象成领域类，比如订单，库存调拨单，出库单，入库单 

这边是可以将一个较为复杂的领域类图拆分为多个领域类，比如说订单主信息，订单项信息，订单优惠信息 

4.1 权限中心

[**权限中心领域类图**](https://www.processon.com/diagraming/5a76ed6ee4b0615ac04a8ae2) 

4.2 商品中心

[**商品中心领域类图**](https://www.processon.com/diagraming/5a76ee2ae4b064e9ddb6879d)

4.3 采购中心

[采购中心领域类图](https://www.processon.com/diagraming/5a76eeb2e4b059c41ab43a08)

4.4 WMS中心

[WMS中心领域类图](https://www.processon.com/diagraming/5a76ef71e4b059c41ab43ad4)

4.5 会员中心

[会员中心领域类图](https://www.processon.com/diagraming/5a76effbe4b064e9ddb6893c)

4.6 购物车

[购物车领域类图](https://www.processon.com/diagraming/5a76f090e4b0874437ba5374)

4.7 支付中心

[支付中心领域类图](https://www.processon.com/diagraming/5a76f0e5e4b0615ac04a8e01)

4.8 订单中心

[订单中心领域类图](https://www.processon.com/diagraming/5a76f114e4b0874437ba53f5)

4.9 物流中心

[物流中心领域类图](https://www.processon.com/diagraming/5a76f157e4b0615ac04a8e6c)

4.10 评论中心

[评论中心领域类图](https://www.processon.com/diagraming/5a76f193e4b0615ac04a8e9b)

4.11 促销中心

[促销中心领域类图](https://www.processon.com/diagraming/5a76f1dce4b0812a0f059740)

4.12 客服中心

[客服中心领域类图](https://www.processon.com/diagraming/5a76f21ce4b0874437ba54da)

4.13 财务中心

[财务中心领域类图](https://www.processon.com/diagraming/5a76f248e4b0615ac04a8f46)

4.14 调度中心

[调度中心领域类图](https://www.processon.com/diagraming/5a76f2a6e4b0615ac04a8fa1)

4.15 库存中心

[库存中心领域类图](https://www.processon.com/diagraming/5a76f2cbe4b0874437ba5562)

#### 06_系统设计

##### 01_电商系统v1.0版本概要设计文档

1、引言

1.1 编写目的

编写概要设计文档，是为了指导后续的详细设计

1.2 面向对象

架构师、高级工程师、初中级工程师

1.3 参考文档

1、《电商系统v1.0版本产品需求文档》

2、《电商系统v1.0版本需求分析文档》

2、逻辑架构

2.1 逻辑架构图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0415.gif)

2.2 设计细节

2.2.1 Web服务器

采用tomcat作为web服务器，不引入apache或者是nginx这种服务器，因为第一个版本，预计的用户数量也就是100个内测用户，并发量基本低于1/s。系统主要是为了跑通咱们的系统逻辑，进行内测。所以说为了开发和部署的方便以及效率起见，直接采用tomcat作为web服务器。

2.2.2 业务系统

直接将16个中心（权限中心、商品中心、采购中心、WMS中心、会员中心、商品查询、购物车、支付中心、订单中心、物流中心、评论中心、促销中心、客服中心、财务中心、调度中心、库存中心）全部放在一个单块应用中。 

不做任何的系统拆分，全部采取B/S架构，接口对外提供服务。因为刚开始我们开发人员很少，不需要做太多的服务拆分，全部耦合在一个服务中，开发所有的代码，效率反而是最高的。

2.2.3 脚手架框架

采用目前业界最新最热门最流行的spring boot技术，作为脚手架框架，利用spring boot与其他的框架技术快速的整合。同时spring boot的可扩展性非常好，未来如果要用到缓存、mq等其他的技术，都可以快速的跟spring boot脚手架进行整合。 

而且，团队已经初步对spring boot完成了技术调研，spring boot 20%的核心功能都已经掌握的很扎实了。

2.2.4 MVC框架

采取业界最流行的spring web mvc框架即可

2.2.5 IOC/AOP框架

采取业界最流行的spring core框架即可

2.2.6 ORM框架

采取业界最流行的mybatis3框架，不采用纯粹的ORM框架，hibernate，是因为类似hinernate那样的框架太重了，黑盒，自动生成的那个SQL性能较差。所以不建议采用hibernate。反而是mybatis框架基本可以自己手写sql语句，灵活，通用，很方便。

2.2.7 数据库

采用MySQL作为数据库，因为oracle数据库到了后期使用要付费，费用高昂，而且扩展性不是很好。目前互联网行业最通用的都是采用mysql数据库，哪怕是后面数据量大了，要分库分表，也有很多成熟的方案可以用。

2.2.8 基础设施

机器，网络，基础设施，采用阿里云，因为目前行业里国内，基本上就是这个阿里云的产品最好，稳定性，技术支持能力最好。我们作为一个初创型团队，不应该直接自己花很多的钱去采购和运维管理自己的服务器，那样的话成本太高了，而且很麻烦。

2.2.9 日志框架

采用spring boot默认支持的logback作为日志框架即可

2.2.10 系统监控

第一个版本主要是内测，不需要复杂的系统监控，只需要使用spring boot actuator提供的简单的健康检查监控即可。

3、运行架构

3.1 系统核心流程

3.1.1 采购流程时序图

[采购流程时序图](https://www.processon.com/diagraming/5a77cbb8e4b059c41ab4ea8a)

3.1.2 购物流程时序图

[购物流程时序图](https://www.processon.com/diagraming/5a77d33ce4b059c41ab50763)

3.1.3 退货流程时序图

[退货流程时序图](https://www.processon.com/diagraming/5a77d821e4b0812a0f065bc0)

3.2 功能时序图

功能的运行流程与需求文档中几乎保持一致，所以在这里就不画了

4、物理架构

4.1 软件架构

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0416.gif)

4.2 硬件架构

4.2.1 开发环境

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0417.gif)

4.2.2 集成测试环境

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0418.gif)

4.2.3 系统测试环境

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0419.gif)

4.2.4 验收测试环境

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0420.gif)

4.2.5 线上环境

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0421.gif)

##### 02_电商系统v1.0版本概要设计文档技术评审 

1、并发层面的问题 

如果未来并发量持续增长，tomcat服务器可以部署集群+前面的负载均衡设备。 

但是mysql是单库单表，会有并发的瓶颈，一般来说，mysql单服务器承载的并发不能超过2k。如果mysql单库的写并发到1.5k的时候，建议就要分库了；如果mysql单库的读并发到1.5k的时候，建议就要挂主从架构，读写分离，挂多个从库。 

所以目前架构设计中的mysql单库单表可能未来会是一个风险点。但是现在系统刚起步，可以先这么做，但是以后要去考量这个事情。 

2、伸缩性 

tomcat是没有问题的，只要加机器就可以了。 

但是你的业务系统，是否具备伸缩性，要仔细去考量一下。就是说，如果你的设计里面，你的业务系统必须用单个服务实例承接所有的请求才能正常工作，一旦你业务系统部署多个实例，请求落到不同的服务实例上，会导致请求处理出错，那么就意味着你的业务系统只能部署单个实例。 

如果是这样子的话，那你的业务系统就不具备可伸缩的能力，因为他是没有办法去扩容的。 

但是这里主要是提醒一下，在后面做详细设计的时候，务必要考量到这一点。 

举个例子吧，假设，某个订单，被你的某个服务实例在内存中维护了一个什么状态。此时就导致，如果这个订单相关的请求落到其他的服务实例上去，会导致你的整个程序出错。那么此时，你的系统就是不可伸缩的。你只能要求所有的请求都要落到一个服务实例上，才能完成正确的操作，那你不能扩容了。 

mysql，单库单表，是典型的不可伸缩。你即使加更多的mysql服务器，也是搞不定的。所以以后要让mysql可伸缩，必须结合业务去设计对应的分库分表的mysql架构。 

3、可用性 

（1）tomcat+业务系统的部署，都是单机部署的，那么意味着，只要这个机器，或者是这个机器上的tomcat，或者是这个tomcat里部署的业务系统，挂掉了，那么整个系统就挂掉了，可用性很差 

（2）mysql，只要一个mysql宕机了，那么数据库就挂了，一旦数据库挂了，那么整个系统就挂掉了，可用性很差 

所以在现在初期，先不用考虑，但是以后架构必须得去考量这个可用性的问题 

4、扩展性 

扩展性很差，因为你如果要大团队协作，多人开发，会发现说，这里的模块耦合太严重了。都耦合在了一个单块应用中，到了后期，几十个人修改一个工程，大量的代码冲突，不同的项目不同的版本之间的测试、开发的排期大量的冲突，互相之间占用测试环境，你等我，我等你。然后的话，上线，也是的。 

假设，我们现在有3个项目并行在做，分别是3个小team在做，一起修改一个单块应用。然后其中一个项目的上线时间定在了07.01，那么这就意味着什么呢？项目二的上线时间就不能定在07.01，如果项目二和项目一同一天上线，就意味着大家要耦合在一起做测试啊什么的，是不可能的。这样的话，就导致项目二只能定在07.02，然后同理，项目三只能定在07.03. 

这个还只是3个项目，如果是30个项目呢？上百人开发。 

比如你临时修复了一个bug，要上线，这个时候怎么办？可能有其他团队正要上线呢，你还得等他们先上线，然后你再上线呢？ 

暂时不用解决，1+4的一个小team，单块应用。10个人以上，那就不太合适了。 

5、安全性 

目前没有考虑任何的安全性的措施，裸奔。内测，仅仅面向部分少量的用户，用一些测试数据来内测，所以还好。 

6、高性能 

性能肯定的是有问题的，大量的全部基于数据库来操作，没有任何的缓存，或者是MQ介入，那么性能肯定是会差很多的 

7、稳定性 

系统会不会频繁的出一些bug和未知的一些问题，排查问题的效率和解决问题的效率怎么样？日志，通过日志可以排查和解决问题。 

但是监控这一块，做的比较low，只能通过spring boot提供的接口，人肉时不时上去看看，调用一下接口看一眼。没有那种自动化的监控系统，可以看到问题，然后直接发短信、邮箱通知RD。

##### 03_电商系统v1.0版本权限中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.2 数据库物理模型

2、接口

2.1 权限管理

2.1.1 根权限列表查询

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/priority/roots/  

（3）接口描述 

查询所有的根权限 

（4）输入 

无 

（5）输出 

[

  {

​    "id": 1,

​    "code": "TEST_PRIORITY_01",

​    "url": "/api/v1.0/test",

​    "priorityComment": "测试权限",

​    "priorityType": 1,

​    "parentId": 2,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​     "id": 2,

​    "code": "TEST_PRIORITY_02",

​    "url": "/api/v1.0/test02",

​    "priorityComment": "测试权限02",

​    "priorityType": 1,

​    "parentId": 2,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  }

] 

2.1.2 子权限列表查询

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/priority/children/{id}  

（3）接口描述

查询某个权限的子权限 

（4）输入 

权限id 

（5）输出 

[

  {

​    "id": 1,

​    "code": "TEST_PRIORITY_01",

​    "url": "/api/v1.0/test",

​    "priorityComment": "测试权限",

​    "priorityType": 1,

​    "parentId": 2,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​    "id": 2,

​    "code": "TEST_PRIORITY_02",

​    "url": "/api/v1.0/test02",

​    "priorityComment": "测试权限02",

​    "priorityType": 1,

​    "parentId": 2,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  }

]

2.1.3 添加权限

（1）接口所属的类 

（2）接口定义 

POST /api/v1.0/auth/priority/  

（3）接口描述 

添加权限 

（4）输入 

{

  "code": "TEST_01",

  "url": "/api/v1.0/test01",

  "priorityComment": "测试权限01",

  "priorityType": 1,

  "parentId": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.1.4 查询权限

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/priority/{id}  

（3）接口描述 

查询某个权限 

（4）输入 

权限id 

（5）输出 

{

  "id": 1,

  "code": "TEST_01",

  "url": "/api/v1.0/test01",

  "priorityComment": "测试权限01",

  "priorityType": 1,

"parentId": 1,

  "gmtCreate": "2017-01-01 10:00:00",

  "gmtModified": "2017-01-01 10:00:05"

}

2.1.5 更新权限

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/priority/{id}  

（3）接口描述 

更新权限 

（4）输入 

权限id 

{

  "id": 1,

  "code": "TEST_01",

  "url": "/api/v1.0/test01",

  "priorityComment": "测试权限01",

  "priorityType": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.1.6 删除权限

（1）接口所属的类 

（2）接口定义 

DELETE /api/v1.0/auth/priority/{id}  

（3）接口描述 

删除权限 

（4）输入 

权限id 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2 角色管理

2.2.1 查询角色列表

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/role/ 

（3）接口描述 

查询角色列表 

（4）输入 

{

  "offset": 0,

  "size": 10,

  "code": "test_01",

  "roleName": "测试角色",

  "isEnabled": 1 // 0是未启用，1是启用

} 

（5）输出 

[

  {

​    "id": 1,

​    "code": "ROLE_01",

​    "roleName": "测试角色",

​    "roleComment": "测试角色备注",

​    "isEnabled": 1

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "code": "ROLE_01",

​    "roleName": "测试角色",

​    "roleComment": "测试角色备注",

​    "isEnabled": 1

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"  

]

2.2.2 添加角色

（1）接口所属的类 

（2）接口定义 

POST /api/v1.0/auth/role/  

（3）接口描述 

添加角色 

（4）输入 

{

  "code": "TEST_01",

  "roleName": "测试角色01",

  "roleComment": "测试角色01",

  "isEnabled": 1,

  "priorityIds": [1, 3, 9, 10, 20]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.3 查询角色

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/role/{id} 

（3）接口描述 

添加角色 

（4）输入 

角色id 

（5）输出 

{

  "id": 1,

  "code": "TEST_01",

  "roleName": "测试角色01",

  "roleComment": "测试角色01",

"isEnabled": 1,

  "gmtCreate": "2017-01-01 10:00:00",

  "gmtModified": "2017-01-01 10:00:00",

  "priorityIds": [1, 3, 9, 10, 20]

}

2.2.4 更新角色

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/role/{id}  

（3）接口描述 

更新角色 

（4）输入 

{

  "id": 1,

  "code": "TEST_01",

  "roleName": "测试角色01",

  "roleComment": "测试角色01",

  "isEnabled": 1,

  "priorityIds": [1, 3, 9, 10, 20]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.5 删除角色

（1）接口所属的类 

（2）接口定义 

DELETE /api/v1.0/auth/role/{id}  

（3）接口描述 

删除角色 

（4）输入 

角色ID 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.6 启用/停用角色

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/role/enabled/{id}  

（3）接口描述 

更新角色的启用状态 

（4）输入 

{

  "id": 1,

  "isEnabled": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.3 账号管理

2.3.1 查询账号列表

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/account/  

（3）接口描述 

查询账号列表 

（4）输入 

{

  "offset": 0,

  "size": 10,

  "username": "test_01",

  "employeeName": "测试角色",

"roleId": 1,

"isEnabled": 1 // 1是启用，0是未启用

} 

（5）输出 

[

  {

​    "id": 1,

​    "username": "testuser",

​    "employeeName": "张三",

​    "accountComment": "测试账号备注",

​    "isEnabled": 1

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "username": "testuser",

​    "employeeName": "张三",

​    "accountComment": "测试账号备注",

​    "isEnabled": 1

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  }

]

2.2.2 添加账号

（1）接口所属的类 

（2）接口定义 

POST /api/v1.0/auth/account/  

（3）接口描述 

添加账号 

（4）输入 

{

"username": "testuser01",

  "password": "12345678",

  "employeeName": "张三",

  "accountComment": "张三员工",

"isEnabled": 1,

  "roleIds": [1, 3, 9, 10, 20],

  "priorityIds": [1, 3, 9, 10, 20]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.3 查询账号

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/account/{id}  

（3）接口描述 

查询账号 

（4）输入 

账号id 

（5）输出 

{

"id": 1,

"username": "testuser01",

  "employeeName": "张三",

  "accountComment": "张三员工",

"isEnabled": 1,

  "roleIds": [1, 3, 9, 10, 20],

  "priorityIds": [1, 3, 9, 10, 20]

} 

2.2.4 更新账号

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/account/{id}  

（3）接口描述 

更新账号 

（4）输入 

{

"id": 1,s

"username": "testuser01",

  "password": "12345678",

  "employeeName": "张三",

  "accountComment": "张三员工",

"isEnabled": 1,

  "roleIds": [1, 3, 9, 10, 20],

  "priorityIds": [1, 3, 9, 10, 20]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.5 删除账号

（1）接口所属的类 

（2）接口定义 

DELETE /api/v1.0/auth/account/{id}  

（3）接口描述 

删除账号 

（4）输入 

账号ID 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.6 启用/停用账号

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/account/enabled/{id}  

（3）接口描述 

更新账号的启用状态 

（4）输入 

{

  "id": 1,

  "isEnabled": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.7 修改密码

（1）接口所属的类 

（2）接口定义 

PUT /api/v1.0/auth/account/password/{id}  

（3）接口描述 

更新账号的密码 

（4）输入 

{

  "id": 1,

  "password": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.4 权限控制

2.4.1 查询账号有权限的菜单树

上来先查询账号有权限的根菜单权限，显示在页面左侧的菜单栏里，如果用户点击某个菜单，异步加载那个菜单下面的子菜单即可 

（1）接口所属的类 

（2）接口定义 

GET /api/v1.0/auth/priority/tree/authorized/?accountId=1  

（3）接口描述 

查询某个账号被授权的菜单树 

（4）输入 

账号ID 

（5）输出 

[

  {

​    "id": 1,

​    "code": "TEST_PRIORITY_01",

​    "url": "/api/v1.0/test",

​    "priorityComment": "测试权限",

​    "priorityType": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​    "id": 3,

​    "code": "TEST_PRIORITY_02",

​    "url": "/api/v1.0/test02",

​    "priorityComment": "测试权限02",

​    "priorityType": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  }

]

2.4.2 查询账号对某个权限是否授权

在页面上，显示了某个按钮的时候，对那个按钮是否显示需要使用特殊的标签，在标签里给一个按钮对应的权限的编号，然后后台会去查询账号对这个编号的权限，是否有授权 

（1）接口所属的类 

（2）接口定义

GET /api/v1.0/auth/priority/authorized/{id}?accountId=1  

（3）接口描述 

查询某个账号对某个权限是否授权 

（4）输入 

权限ID、账号ID 

（5）输出 

{

"authorized": true // true是授权，false是未授权

}

2.4.3 请求URL权限控制

这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求 

（1）接口类 

PriorityService 

（2）接口定义 

Boolean checkPriorityAuthorized(Long accountId, String url)  

（3）接口描述 

查询某个账号对某个权限是否授权 

（4）输入 

权限ID、账号ID 

（5）输出 

是否授权，true是授权，false是未授权

3、开发架构

3.1 实现类图

[权限中心实现类图](https://www.processon.com/diagraming/5a796a90e4b024b99bf22f66) 

将账号、角色、权限，相关的数据，通过享元模式，在内存里维护一份

3.2 包设计

com.zhss.eshop.auth.web

com.zhss.eshop.auth.service

com.zhss.eshop.auth.service.impl

com.zhss.eshop.auth.dao

com.zhss.eshop.auth.dao.impls

com.zhss.eshop.auth.mapper

com.zhss.eshop.auth.vo

com.zhss.eshop.auth.dto

com.zhss.eshop.auth.do

com.zhss.eshop.auth.query

4、运行流程设计

4.1 权限管理

4.1.1 根权限列表查询

直接查询出来所有的根权限即可，就是没有parentId就是根权限。

4.1.2 子权限列表查询

根据parentId去查询某个权限的子权限即可

4.1.3 添加权限

将权限信息保存到数据库即可

4.1.4 查询权限

根据权限ID来查询即可

4.1.5 更新权限

根据权限ID来跟新即可

4.1.6 删除权限

这块必须要进行递归删除，也就是说，你要删除一个权限的话： 

第一，你必须先删除最底层的子权限，然后一级一级往上删除，删除到当前的权限 

第二，你除了删除权限之外，你还得care一下角色、账号跟权限之间的关联关系，我们要做一个check，也就是说，如果这个权限还跟有一些角色和账号跟之进行关联，就不能直接删除 

第三，此处采用设计模式，组合模式+访问者模式，采用组合模式，在这里将权限组装成一颗树，或者是不用提前组装，就是不断的去递归动态组装出来一颗树也可以。然后对这颗树注入一个删除的visistor访问者，这样，以后我们还可以动态注入别的visitor来实现对这颗权限树的不同的操作。 

第四，在对这棵树递归删除的过程中，如果发现某个权限还被别人给引用，此时要返回一个特殊的状态码，这个状态码要标明某一级权限还被某个角色或者是账号在引用，就不能直接这样删除，需要回滚整个事务。 

我们在这里因为要采取设计模式，所以需要为了这块东西，单独设计一套类出来 

这个场景，应该是完美的可以让我们后面去实践组合模式和访问者模式的一个场景，就是我们需要开发两个visitor，第一个visitor需要遍历所有子权限，判断是否有某个权限还被账号或者角色在关联着；第二个visitor，是如果全包所有的子权限都没有被别人在关联，那么就递归删除

4.2 角色管理

4.2.1 查询角色列表

根据筛选条件+分页查询角色即可

2.2.2 添加角色

（1）先添加角色

（2）添加角色和权限之间的关系

2.2.3 查询角色

（1）根据ID查询角色

（2）查询角色被授予的权限ID列表

2.2.4 更新角色

（1）更新角色

（2）将角色与权限的关联关系都删除

（3）重新插入角色与权限的关联关系

2.2.5 删除角色

（1）是否有账号关联了这个角色，如果有是不允许删除角色的

（1）删除角色跟权限的关联关系

（2）删除角色本身

2.2.6 启用/停用角色

（1）是否有账号关联了这个角色，如果有是不允许停用角色的

（2）更新角色的启用状态即可

4.3 账号管理

4.3.1 查询账号列表

根据筛选条件分页查询账号列表即可

4.3.2 添加账号

（1）添加账号

（2）添加账号和角色的关联关系

（3）添加账号和权限的关联关系

4.3.3 查询账号

（1）查询账号

（2）查询账号关联的角色id

（3）查询账号关联的权限id

4.3.4 更新账号

（1）更新账号

（2）删除账号与角色的关联关系，再插入新的账号与角色的关联关系

（3）删除账号与权限的关联关系，再插入新的账号与权限的关联关系

4.3.5 删除账号

（1）删除账号与角色的关联关系

（2）删除账号与权限的关联关系

（3）删除账号本身

4.3.6 启用/停用账号

直接更新账号的状态即可

4.3.7 修改密码

直接更新账号的密码即可

4.4 权限控制

4.4.1 查询账号有权限的菜单树

（1）查询这个账号有权限的根菜单

（2）使用visitor去递归每个根菜单，对每个根菜单都去查询这个账号有权限的子菜单，填充为根菜单的子菜单

（3）以此类推，就可通过visitor得到一颗账号有权限的菜单树

4.4.2 查询账号对某个权限是否授权

在页面上，对每个按钮，都有一个标签，对这个按钮对应的权限的编号，去查询这个用户对这个编号的权限，有没有授权。 

（1）查询这个编号对应的权限

（2）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询

4.4.3 请求URL权限控制

这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求 

（3）查询这个URL对应的权限

（4）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询 

5、测试用例设计

5.1 单元测试用例设计

要求，就是对每个controller、service、dao组件的每个方法，都进行单元测试

5.2 冒烟测试用例设计

要求，是系统在本地运行起来，直接依赖了数据库之后，对controller层所有的接口访问都可以正常工作

6、日志设计

要求的是每一层，每一个类都捕获自己的异常，然后对异常要求必须打印详细的日志

##### 04_电商系统v1.0版本商品中心详细设计文档

1、数据架构

实际上，这个电商系统，他的这个整个数据库的表结构，可能是很复杂的。但是呢，业界也有一些已经完成的比较好的电商的数据库的建模。我不会说上来，带着大家把100%完美的数据库给建模好，这个是不可能的。到了后期，随着你的整个系统架构的演进，数据库的设计，可能也是不断的在变化的。 

不要上来就想着万年以后的事情，所有的系统设计，都是一步一步来的。可能我们现在设计的这个电商的商品中心的表，评论中心的，订单中心的，可能有不完美的地方，可能存在一些缺陷，这个都没关系。 

我们纯粹就是按照现在当前的这个阶段，就是v1.0内测版的阶段，没有任何的压力，现在的需求相对来说，还是简单一些，后面的很多复杂的业务需求还没上。所以这个数据库的表设计我们就按照现在的需求来就可以了。 

然后，可能未来我们的数据库的设计，会不断的迭代和演进，所以说，大家如果感觉现在的这个表有些设计的问题，都很正常，不用太过于担心，到了一定的阶段，比如说你的系统架构本身在往2.0，3.0去演进，那么我们对应的数据库模型也会不断的演进，很正常的。

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 属性管理

2.1.1 查询属性列表 

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/property/ 

（3）接口描述 

查询属性列表 

（4）输入 

{

  "offset": 0,

  "size": 20,

  "property_name": "测试属性"

} 

（5）输出 

[

  {

​    "id": 1,

​    "propertyName": "测试属性01",

​    "propertyDesc": "测试属性01",

​    "inputType": 1,

​    "inputValues": "值1,值2,值3",

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "propertyName": "测试属性01",

​    "propertyDesc": "测试属性01",

​    "inputType": 1,

​    "inputValues": "值1,值2,值3",

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  }

]

2.1.2 新增属性

（1）接口类 

（2）接口名称 

POST /api/v1.0/commodity/property/ 

（3）接口描述 

新增属性 

（5）输入 

{

  "propertyName": "测试属性01",

  "propertyDesc": "测试属性01",

"inputType": 1,

"propertyDesc": "黑色,白色"

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.1.3 根据ID查询属性

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/property/{id} 

（3）接口描述 

根据ID查询属性 

（6）输入 

属性ID 

（5）输出 

  {

​    "id": 1,

​    "propertyName": "测试属性01",

​    "propertyDesc": "测试属性01",

​    "inputType": 1,

​    "inputValues": "值1,值2,值3",

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  }

2.1.4 更新属性

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/property/{id} 

（3）接口描述 

新增属性 

（7）输入 

{

"id": 1,

  "propertyDesc": "测试属性01"

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.1.5 删除属性

（1）接口类 

（2）接口名称 

DELETE /api/v1.0/commodity/property/{id} 

（3）接口描述 

新增属性 

（8）输入 

睡醒ID 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2 类目管理

2.2.1 查询根类目列表

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/category/root 

（3）接口描述 

查询根类目列表 

（9）输入 

无 

（5）输出

 [

  {

​    "id": 1,

​    "categoryName": "测试属性01",

​    "categoryDesc": "测试属性01",

​    "leaf": 0,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "categoryName": "测试属性01",

​    "categoryDesc": "测试属性01",

​    "leaf": 0,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  }

] 

2.2.2 查询子类目列表

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/category/children/{id} 

（3）接口描述 

查询子类目列表 

（10）输入 

类目ID 

（5）输出 

[

  {

​    "id": 1,

​    "categoryName": "测试属性01",

​    "categoryDesc": "测试属性01",

​    "leaf": 0,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "categoryName": "测试属性01",

​    "categoryDesc": "测试属性01",

​    "leaf": 0,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  }

]

2.2.3 新增类目

（1）接口类 

（2）接口名称 

POST /api/v1.0/commodity/category/ 

（3）接口描述 

新增类目 

（11）输入 

{

"categoryName": "测试类目01",

"categoryDesc": "测试类目01",

"leaf": 0,

"parentId": 1,
    "properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

],

"propertyGroups": [

{

"propertyName": "属性分组01",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

},{

"propertyName": "属性分组02",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

}

]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.2.4 根据ID查询类目

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/category/{id} 

（3）接口描述 

根据ID查询类目 

（12）输入 

类目ID 

（5）输出 

{

"id": 1,

"categoryName": "测试属性01",

"categoryDesc": "测试属性01",

"leaf": 0,

"gmt_create": "2017-01-01 10:00:00",

"gmt_modified": "2017-01-01 10:05:00",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

],

"propertyGroups": [

{

"propertyName": "属性分组01",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

},{

"propertyName": "属性分组02",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

}

] 

}

2.2.5 更新类目

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/category/{id} 

（3）接口描述 

更新类目 

（13）输入 

{

"id": 1,

"categoryName": "测试类目01",

"categoryDesc": "测试类目01",

"leaf": 0,

"parentId": 1,
    "properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

],

"propertyGroups": [

{

"propertyName": "属性分组01",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

},{

"propertyName": "属性分组02",

"properties": [

{

"propertyId": 1,

"required": 1,

"propertyType": 1

},{

"propertyId": 2,

"required": 1,

"propertyType": 1

}

]

}

]

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.2.6 删除类目

（1）接口类 

（2）接口名称 

DELETE /api/v1.0/commodity/category/{id} 

（3）接口描述 

删除类目

 （14）输入 

类目ID 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.3 品牌管理

2.3.1 查询品牌列表

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/brand/

 （3）接口描述 

查询品牌列表 

（15）输入 

{

  "offset": 0,

  "size": 20,

"brandChineseName": "中文名",

"brandEnglishName": "英文名",

"brandAliasName": "别名",

"enabled": 1

} 

（5）输出 

[

  {

​    "id": 1,

​    "brandChineseName": "中文名",

​    "brandEnglishName": "英文名",

​    "brandAliasName": "别名",

​    "brandIntro": "品牌介绍",

​    "location": "品牌所在地",

​    "brandComment": "品牌说明备注",

​    "enabled": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "brandChineseName": "中文名",

​    "brandEnglishName": "英文名",

​    "brandAliasName": "别名",

​    "brandIntro": "品牌介绍",

​    "location": "品牌所在地",

​    "brandComment": "品牌说明备注",

​    "enabled": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  }

] 

2.3.2 新增品牌

（1）接口类 

（2）接口名称 

POST /api/v1.0/commodity/brand/ 

（3）接口描述 

新增品牌s 

（16）输入 

{

​    "brandChineseName": "中文名",

​    "brandEnglishName": "英文名",

​    "brandAliasName": "别名",

​    "brandIntro": "品牌介绍",

​    "location": "品牌所在地",

​    "brandComment": "品牌说明备注",

​    "enabled": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  } 

再加上两张图片的上传，logo，brandAuthorizationVoucher 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.3.3 根据ID查询品牌

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/brand/{id} 

（3）接口描述 

根据ID查询品牌 

（4）输入 

品牌ID 

（5）输出

{

"brandChineseName": 1,

​    "brandChineseName": "中文名",

​    "brandEnglishName": "英文名",

​    "brandAliasName": "别名",

​    "brandIntro": "品牌介绍",

​    "location": "品牌所在地",

​    "brandComment": "品牌说明备注",

​    "enabled": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

} 

2.3.4 根据ID下载logo图片

GET /api/v1.0/commodity/brand/logo/{id}，回返回图片流，给下载

2.3.5 根据ID下载品牌授权证明图片

GET /api/v1.0/commodity/brand/authorization/{id}，回返回图片流，给下载

2.3.6 编辑品牌

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/brand/{id} 

（3）接口描述 

编辑品牌 

（4）输入 

{

"id": 1,

​    "brandChineseName": "中文名",

​    "brandEnglishName": "英文名",

​    "brandAliasName": "别名",

​    "brandIntro": "品牌介绍",

​    "location": "品牌所在地",

​    "brandComment": "品牌说明备注",

​    "enabled": 1,

​    "gmtCreate": "2017-01-01 10:00:00",

​    "gmtModified": "2017-01-01 10:05:00"

  } 

再加上两张图片的上传，logo，brandAuthorizationVoucher 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.3.7 删除品牌

（1）接口类 

（2）接口名称 

DELETE /api/v1.0/commodity/brand/{id} 

（3）接口描述 

删除品牌 

（4）输入 

品牌ID 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.3.8 启用/停用品牌

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/brand/enabled/{id} 

（3）接口描述 

更新品牌的启用状态 

（4）输入 

{

  "id": 1,

  "enabled": 1

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.4 商品管理

2.4.1 查询商品列表

（1）接口类  

（2）接口名称 

GET /api/v1.0/commodity/goods/ 

（3）接口描述 

查询商品列表 

（17）输入 

{

  "offset": 0,

  "size": 20,

"categoryId": 1,

"brandId": 1,

"goodsCode": "商品编号",

"goodsName": "商品名称"

} 

（5）输出 

[

  {

​    "id": 1,

​    "categoryId": 1,

​    "brandId": 1,

​    "goodsCode": "商品编号",

​    "goodsName": "商品名称",

​    "goodsSubName": "商品副名称",

​    "grossWeight": 43.6,

​    "goodsLength": 20.3,

​    "goodsWidth": 25.6,

​    "goodsHeight": 38.9,

​    "goodsStatus": 2,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  },{

​    "id": 1,

​    "categoryId": 1,

​    "brandId": 1,

​    "goodsCode": "商品编号",

​    "goodsName": "商品名称",

​    "goodsSubName": "商品副名称",

​    "grossWeight": 43.6,

​    "goodsLength": 20.3,

​    "goodsWidth": 25.6,

​    "goodsHeight": 38.9,

​    "goodsStatus": 2,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00"

  }

]

2.4.2 新增商品

（1）接口类 

（2）接口名称 

POST /api/v1.0/commodity/goods/ 

（3）接口描述 

新增类目 

（18）输入 

{

"categoryId": 1,

"brandId": 1,

"goodsCode": "商品编号",

"goodsName": "商品名称",

"goodsSubName": "商品副名称",

"grossWeight": 43.6,

  "goodsLength": 20.3,

  "goodsWidth": 25.6,

  "goodsHeight": 38.9,

"serviceGuarantees": “服务保证”

“packageList”: “包装清单”,

“freightTemplateId”: 1,

“goodsDesc”: “一大段详情内容文本”,
    "properties": [

{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

},{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

}

],

"propertyGroups": [

{

"PropertyGroupRelationshipId": 1,

"propertyValue": 1

},{

"propertyGroupRelationshipId": 1,

"propertyValue": 1

}

],

"goodsSku": [

{

"skuCode": 1,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

},{

"skuCode": 2s,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

}

], 

} 

会上传一些图片列表，goodsPictures

会上传一些详情内容里面的各个图片 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.2.4 根据ID查询商品

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/goods/{id} 

（3）接口描述 

根据ID查询类目 

（19）输入 

类目ID 

（5）输出 

（1）接口类  

（2）接口名称 

GET /api/v1.0/commodity/goods/ 

（3）接口描述 

查询商品列表 

（20）输入 

{

  "offset": 0,

  "size": 20,

"categoryId": 1,

"brandId": 1,

"goodsCode": "商品编号",

"goodsName": "商品名称"

} 

（5）输出 

  {

​    "id": 1,

​    "categoryId": 1,

​    "brandId": 1,

​    "goodsCode": "商品编号",

​    "goodsName": "商品名称",

​    "goodsSubName": "商品副名称",

​    "grossWeight": 43.6,

​    "goodsLength": 20.3,

​    "goodsWidth": 25.6,

​    "goodsHeight": 38.9,

​    "goodsStatus": 2,

​    "gmt_create": "2017-01-01 10:00:00",

​    "gmt_modified": "2017-01-01 10:05:00",

“goodsDesc”: “一大段详情内容文本”,
    "properties": [

{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

},{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

}

],

"propertyGroups": [

{

"PropertyGroupRelationshipId": 1,

"propertyValue": 1

},{

"propertyGroupRelationshipId": 1,

"propertyValue": 1

}

],

"goodsSku": [

{

"skuCode": 1,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

},{

"skuCode": 2s,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

}

], 

  }

2.2.5 更新商品

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/goods/{id} 

（3）接口描述 

更新商品 

（21）输入 

{

“id”: 1,

"categoryId": 1,

"brandId": 1,

"goodsCode": "商品编号",

"goodsName": "商品名称",

"goodsSubName": "商品副名称",

"grossWeight": 43.6,

  "goodsLength": 20.3,

  "goodsWidth": 25.6,

  "goodsHeight": 38.9,

"serviceGuarantees": “服务保证”

“packageList”: “包装清单”,

“freightTemplateId”: 1,

“goodsDesc”: “一大段详情内容文本”,
    "properties": [

{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

},{

"categoryPropertyRelationshipId": 1,

"propertyValue": 1

}

],

"propertyGroups": [

{

"PropertyGroupRelationshipId": 1,

"propertyValue": 1

},{

"propertyGroupRelationshipId": 1,

"propertyValue": 1

}

],

"goodsSku": [

{

"skuCode": 1,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

},{

"skuCode": 2s,

"purcahsePrice": 1,

“salePrice”: 1,

“discountPrice”: 1

}

], 

} 

会上传一些图片列表，goodsPictures

会上传一些详情内容里面的各个图片 

（5）输出 

{

  "status": "success",

  "message": "成功"

} 

2.2.6 删除商品

（1）接口类 

（2）接口名称 

DELETE /api/v1.0/commodity/goods/{id} 

（3）接口描述 

删除商品 

（22）输入 

类目ID 

（5）输出

{

  "status": "success",

  "message": "成功"

}

2.2.7 审核商品

（1）接口类 

（2）接口名称 

PUT /api/v1.0/commodity/goods/approve/{id} 

（3）接口描述 

更新品牌的启用状态 

（4）输入 

{

  "id": 1,

  "approved": 1 // 1是通过，0是未通过

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.2.8 上下架商品

（1）接口类  

（2）接口名称 

PUT /api/v1.0/commodity/goods/shelves/{id} 

（3）接口描述 

上下架商品 

（4）输入 

{

  "id": 1,

  "shelvesStatus": 1 // 1是上架，0是下架

} 

（5）输出 

{

  "status": "success",

  "message": "成功"

}

2.5 商品查询

2.5.1 搜索商品

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/goods/search?keyword=iphone 

（3）接口描述 

搜索商品 

（23）输入 

搜索关键词 

（5）输出 

[

  {

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  },{

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  }

]

2.5.2 品类筛选

（1）接口类  

（2）接口名称 

GET /api/v1.0/commodity/goods/category/{categoryId} 

（3）接口描述 

根据品类筛选商品 

（24）输入 

品类ID 

（5）输出 

[

  {

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  },{

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  }

]

2.5.3 商品列表

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/goods/list?keyword=iphone&offset=0&size=20

GET /api/v1.0/commodity/goods/list?categoryId=1&offset=0&size=20 

（3）接口描述 

查询商品列表 

（25）输入 

搜索词或者是品类ID 

（5）输出 

[

  {

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  },{

​    "goodsId": 1,

“goodsSkuId”: 1,

​    "goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

]

​    "salePrice": 8388.00,

​    "goodsName": "商品名称"

  }

]

2.5.4 商品详情页

（1）接口类 

（2）接口名称 

GET /api/v1.0/commodity/goods/detail/{id} 

（3）接口描述 

查询商品详情页 

（26）输入 

商品ID 

（5）输出 

 {

​    "id": 1,

"goodsPictures": [

“<img src=’/api/v1.0/commodity/goods/picture/1’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/2’ />”,

“<img src=’/api/v1.0/commodity/goods/picture/3’ />”

],

​    "categoryId": 1,

​    "brandId": 1,

​    "goodsCode": "商品编号",

​    "goodsName": "商品名称",

​    "goodsSubName": "商品副名称",

“promotions”: [

{

“id”: 1,

“promotionType”: 1,

“promotionName”: “满100元减5元”

},

{

“id”: 2,

“promotionType”: 2,

“promotionName”: “买手机送耳机”

}

],
    "saleProperties": [

{

"propertyId": 1,

“propertyName”: “机身颜色”,

"propertyValue": “银色,深空灰色”

},{

"propertyId": 2,

“propertyName”: “机身容量”

"propertyValue": “64G,256G”

}

],

“goodsDesc”: “文本+<img src=’/api/v1.0/commodity/goods/desc/picture/1’>+文本+<img src=’’>”,

"propertyGroups": [

{

“propertyGroupName”: “主体”,

“properties”: {

"propertyName": “上市年份”,

"propertyValue": “2017年”

}

},{

“propertyGroupName”: “主体”,

“properties”: {

"propertyName": “上市年份”,

"propertyValue": “2017年”

}

}

],

“packageList”: “”,

“serviceGuarantees”: “”,

}

2.6 对外接口

2.6.1 根据ID查询商品sku

GoodsFacadeService 

GoodsSkuDTO getGoodsSkuById(Long goodsSkuId)

2.6.2 查询商品sku列表

采购中心新建采购单的时候，会来查询商品sku列表，来选择要采购哪个商品 

GoodsFacadeService 

List<GoodsSkuDTO> listGoodsSku(GoodsSkuQuery goodsSkuQuery)

3、开发架构

3.1 实现类图

[商品中心实现类图](https://www.processon.com/diagraming/5a7d4775e4b0615ac053ed39) 

构造器模式来负责构造商品数据

原型模式 

刚从DAO中查询出来一个GoodsDO，包含了15个字段 

然后接着在service中处理完之后，需要返回一个GoodsDTO，包含20个字段，此时你总不能new GoodsDTO，set..，set... 

原型模式，将GoodsDO直接里面的数据拷贝到GoodsDTO中去 

3.2 包设计

com.zhss.eshop.commdoity.mapper

com.zhss.eshop.commdoity.dao

com.zhss.eshop.commdoity.service

com.zhss.eshop.commdoity.web

com.zhss.eshop.commdoity.vo

com.zhss.eshop.commdoity.dto

com.zhss.eshop.commdoity.do

com.zhss.eshop.commdoity.state

com.zhss.eshop.commdoity.visitor

com.zhss.eshop.commdoity.composite 

4、运行流程

4.1 属性管理

4.1.1 查询属性列表

按照筛选条件，以分页的形式来查询属性列表即可

4.1.2 新增属性

将页面上传递过来的属性信息保存到数据库的表中即可

4.1.3 根据ID查询属性

根据传递过来的ID将属性的信息查询出来即可

4.1.4 更新属性

将页面上传递过来的属性信息保存到数据库的表中即可，这里只有属性的说明备注是可以修改的，其他的字段不让修改。

4.1.5 删除属性

删除之前需要先检查一下，如果有类目或者是属性组还关联着这个属性，那么是不能够将这个属性给删除的。如果没有任何类目或者是属性分组还关联这个属性，那么就可以删除。

4.2 类目管理

4.2.1 查询根类目列表

将所有parent_id字段为NULL的类目给查询出来，这就是根类目列表

4.2.2 查询子类目列表

根据parent_id查询某个父类目下的子类目的列表

4.2.3 新增类目

将页面上传递过来的数据保存到数据库中即可，但是这里的数据较为复杂的，需要分成以下几个步骤来执行，因为类目是关联着属性和属性分组的： 

（1）保存类目的基本信息

（2）对于那些直接将类目关联的属性，将关联的数据保存到类目和属性关联关系表中即可

（3）对于那些类目关联的属性分组，首先将类目对应的属性分组保存到属性分组表中

（4）然后将属性分组跟属性的关联关系，保存到对应的关联关系表中即可

4.2.4 根据ID查询类目

（1）查询类目的基本信息

（2）查询类目直接关联的属性信息

（3）查询类目关联的属性分组以及属性分组关联的属性信息

4.2.5 更新类目

（1）如果类目被已经上架的商品关联了，那么就不能随意更新类目的信息了；但是如果关联类目的商品不是上架状态，就可以更新类目

（2）更新类目的基本信息

（3）将类目直接关联的属性的关联关系，给删除

（4）重新插入类目和最新的关联的属性的关联关系到数据库中

（5）将类目关联的属性分组与属性的关联关系给删除

（6）删除类目所有的属性分组

（7）重新插入类目的属性分组，以及属性分组与属性的关联关系

4.2.6 删除类目

（1）如果类目已经被商品给关联了，就不能删除类目

（2）删除类目与直接关联的属性之间的关联关系

（3）删除类目关联的属性分组与属性之间的关联关系

（4）删除类目关联的属性分组

（5）删除类目自己本身的信息就可以了 

上面的步骤仅仅是删除一个类目，但是实际上删除一个父类目的时候，是要将这个父类目名下的所有子类目都按照上述的这个思路给删除的 

所以这里采用组合模式+访问者模式的设计模式 

（1）首先对类目树进行是否有任何一个类目是被商品给关联着的，其实就是可以传入一个visitor，由这个visitor从当前类目开始，无限递子类目，对每个子类目都判断一下是否被某个商品在关联着，只要当前要删除的这个类目有任何一个子类目，是被商品给关联了，那么就不让删除了

（2）如果上面的visitor判断发现ok，可以删除，那么执行删除的逻辑

（3）再传入一个visitor，该visitor也是动态查询每一个类目的子类目，然后对这个类目去执行上面的整套删除逻辑，直到将这个类目树给完全删除掉

4.3 品牌管理

4.3.1 查询品牌列表

按照筛选条件来分页查询数据即可

4.3.2 新增品牌

将页面传递过来的数据保存到数据库即可，可能稍微特殊一点点的就是那个图片的上传，这个接收到页面过来的二进制流数据以后直接存入数据库即可

4.3.3 根据ID查询品牌

将品牌的数据查询出来，支持品牌的两个图片的下载即可

4.3.4 编辑品牌

对页面上传递过来的数据保存到数据库即可，两个图片也是一样的

4.3.5 删除品牌

如果有商品关联着这个品牌，不允许删除品牌，否则的话，就是直接删除品牌自己即可

4.3.6 启用/停用品牌

如果有商品关联着这个品牌，不允许启用/停用品牌，否则的话，就是直接更新品牌的is_enabled字段即可

4.4 商品管理

4.4.1 查询商品列表

按照筛选条件来筛选，同时分页查询即可 

这个查询的时候，有一个特殊的逻辑，实际上是按照spus粒度去查询出来的一个一个的商品

4.4.2 新建商品

维护好了基础数据，包括属性，类目，品牌，就可以编辑商品了 

商品从创建到上架可以售卖，是有一个流程的 

商品新增编辑，就是在商品列表的上面，有一个按钮，点击后进入商品新增/编辑的界面 

商品信息 

类目：弹出来一颗类目树，在一颗类目树中去选择一个对应的叶子类目，商品只能是属于叶子类目的，非叶子类目下是不能挂商品的 

品牌：弹出来一个品牌列表，在一个列表框中，可以去选择一个品牌，Apple。支持对列表分页，支持筛选（中文名、英文名、别名、所在地、状态（默认是启用，可选全部/停用）） 

商品编号：每个商品都有一个编号 

商品名称：输入，苹果X【6期免息/当天发】送壳膜Apple/苹果 iPhone X 全网通手机 

商品副名称：输入，当天发 送壳膜 咨询客服不分期价格直降 

毛重：输入，100g 

商品状态：选择下拉框，核待审、待上架、审核未通过、已上架、已删除 

外包装长：50cm

外包装宽：100cm

外包装高：200cm 

服务保障：这里其实是可以去选择的。但是我们简化一下，就直接输入。碎屏无忧，全国联保，正品保证，极速退款，赠运费险，7天无理由退换，可开发票 

商品图片：上传商品的一些图片 

商品描述：一般是富文本编辑框，图文混排，插入图片，插入文字。图文混排，有大段大段的文本，也有很多张图片。将商品描述里的图片单独存放在一个表里面，将商品描述中的图片都给替换为一个<image src="访问一个后台接口">，然后在显示商品描述的时候，到<image>那儿，会动态请求后台，后台从数据库中读取出来那张图片给显示出来。 

一大段文本

图片1

一大段文本

图片2

一大段文本 

图片1和图片2，给写到一个单独的表中 

然后对商品详情内容做一个替换： 

一大段文本

图片1的<image src=”/image/235”>

一大段文本

图片2的<image src=”iamge/236”>

一大段文本 

就会存储到一个表中，存储到一个clob字段里面去，大文本的 

包装清单： 

采用 Lightning 接头的 EarPods  1 件

iPhone  1 件

Lightning 至 USB 连接线  1 件

5W USB 电源适配器  1 件

Lightning 至 3.5 毫米耳机插孔转换器  1 件 

类目属性值（输入选择的类目的各个属性的值，注意，这里实际就是输入关键属性值和非关键属性值，是一个SPU共享的，但是SKU的销售属性是对每个属性都选择多个值，比如有哪集中颜色，哪几种内存大小） 

输入关键属性：品牌（Apple），型号（iPhone 7 Plus） 

输入销售属性：销售属性不输入，因为在商品详情页上展示的时候，是展示SPU，但是这里要选择每个销售属性可选的值。颜色（白色、土豪金），存储容量（16G，32G，64G） 

机身颜色，提供的可选值范围是：红色、蓝色、白色、黑色、金色 

你此时需要选择你的这个商品在这个属性中，可选的值是哪些？白色、黑色 

非关键属性：输入所有属性的值，拍照功能（摄像头像素 -> 双1200万，摄像头类型 -> 三摄像头，视频显示格式 -> 4k），显示（屏幕尺寸 -> 5.8英寸，触摸屏类型 -> 电容屏，分辨率 -> 2436 * 1124像素），网络（网络类型 -> 无需合约版，网络模式 -> 无需合约版） 

换一个角度，反过来去想一下，如果是编辑商品的时候，回显这个商品对应的所有属性的值，如何回显呢？肯定是去查商品关联的那个品类，查那个品类直接关联的属性，查这个品类关联的那个属性对应的值。 

运费模板（选择物流运费模板，比如是包邮/按重量/按件，后面下订单计算运费的时候都是根据运费模板来计算的），从物流中心加载出来的一个运费模板的下拉框 

机身颜色：黑色，白色

内存容量：64G，128G，256G 

这两个销售属性就已经输入好了可选的值 

sku1：黑色，64G

sku2：黑色，128G

sku3：黑色，256G

sku4：白色，64G

sku5：白色，128G

sku6，白色，256G 

此时一旦选择好了所有的销售属性，会自动出来一个SKU的列表，每个SKU的列表，就显示每个销售属性的值，你可以手动删除某一个SKU（比如有白色+64G，但是实际上可能并没有这个东西，你可以手动删除这个SKUs）。针对SKU级别去设置下面几个属性。 

sku编号 

库存（所属仓库（石家庄仓库，无）、库存数量（0件）、库存状态（是否有库存，无库存）、最低预警库存（1000件）） 

每个sku的库存数据，会被保存到库存中心去，不会保存在商品中心的表中，商品和库存会分开，库存是不断变化，而且是快速变化，所以这块要放到单独的库存中心去。但是商品本身的数据变化是比较少的，放在商品中心。 

商品价格（采购价（8000元）、参考价（8500元）、售价（关联会员体系，不用的会员级别不同的价格，1级会员是8500元，2级会员是8450元，3级会员是8400元，4级会员是8350元，5级会员是8300元）、促销价格（8100元）） 

所有信息全部填好之后，就会保存商品数据；如果是编辑的话，要回显所有的数据，提供我们来编辑，编辑过后更新数据。 

特别说明：在选择好销售属性的值之后，会自动出来各个销售属性排列组合出来的SKU，对每个SKU，可以具体设置对应的SKU编码、价格和库存；但是也可以对这个SPU设置统一的库存和价格（一期简单一点，就做统一SPU设置库存和价格） 

商品每次新增和编辑完之后，状态会变为待审核。 

只有商品处于待审核、已下架、审核不通过的状态，可以进行编辑。 

（1）保存商品自己的基本信息

（2）保存商品的图片列表

（3）保存商品的商品详情介绍内容

（4）保存商品对类目直接关联的属性的值是什么，将商品关联的那个叶子类目上面所有层级的父类目的直接关联属性需要全部拿出来，给这个商品来填写的

（5）保存商品对类目关联的属性分组对应的属性的值是什么，将商品关联的那个叶子类目上面所有层级的父类目的关联的那些属性分组都拿出来，给这个商品来填写

（6）保存商品对应的每个sku的数据，包括了sku对应的每个销售属性的值

（7）保存商品的sku的库存数据到库存中心去

（8）新建完商品之后，商品的状态是：待审核 

商品这里比较有技术含量的，就是这个状态的处理以及状态的这个流转，这块我们就可以考虑用这个状态模式。如果我们不用状态模式，直接就是在每个service的增删改查或者其他的一些方法中来处理这个状态模式的一些流转逻辑，会导致一个商品数据的状态相关的操作以及流转的逻辑分散在了很多个地方和方法中。 

未来如果要对商品的状态流转的逻辑进行维护，比如调整状态流转的策略，可能会导致比较难以维护，因为状态相关的逻辑太分散了。 

所以如果采取状态模式的思路，也就是说，在一个地方维护这个商品数据所有的状态相关的流转的逻辑，然后就可以将状态的相关操作集中维护和管理，对后续的维护是很有好处的。 

调用状态管理组件的一个方法，那个方法就是支持新建商品的状态维护，此时这个方法可以创建一个ApprovingState状态组件，执行里面的方法，完成待审核状态的一些操作，比如说最简单的就是将商品的状态给设置成待审核。

4.4.3 根据ID查询商品

（1）查询商品自己的基本信息

（2）查询商品的图片列表

（3）查询商品的详情内容介绍

（4）查询商品对类目直接关联的属性的值

（5）查询商品对类目关联的每个属性分组的值

（6）查询商品的每个sku对应的数据，包括销售属性的值，包括价格的数据，同时从库存中心查询这个sku对应的库存数据

4.4.4 编辑商品

（1）保存商品自己的基本信息

（2）保存商品的图片列表

（3）保存商品的商品详情介绍内容

（4）保存商品对类目直接关联的属性的值是什么

（5）保存商品对类目关联的属性分组对应的属性的值是什么

（6）保存商品对应的每个sku的数据，包括了sku对应的每个销售属性的值

（7）保存商品的sku的库存数据到库存中心去

（8）在商品编辑之前，总是要考虑一下，当前是否能够编辑这个商品。只有待审核、审核未通过两种状态下，是可以对商品进行编辑的。 

编辑商品之前，可以走一下状态管理组件，调用一个准备编辑的方法，状态管理组件根据当前商品所处的这个状态，根据这个状态创建一个对应的state组件，然后调用这个组件中的某个方法，判断一下当前状态能否执行编辑操作 

去执行编辑 

创建一个ApprovingState的一个状态组件，完成状态流转到待审核的这么一个操作

4.4.5 审核商品

（1）根据ID查询商品，显示出商品所有的数据

（2）点击审核通过/未通过

（3）在后台处理的时候，实际上就还是要通过一个唯一的状态管理组件去管理这次状态的流转，商品的状态会流转到待上架，或者是审核未通过

（4）在审核之前，还要做一个校验，就是说只有待审核状态的商品，是可以进行审核的 

在审核之前，先根据当前的状态创建一个state组件，然后调用一个准备审核的方法，判断一下当前这个状态能否执行审核操作，如果可以的话，就执行审核操作，会根据审核的结果，创建不同的state组件，PuttingOnShelvesState，通过这个state完成状态流转到待上架的这么个一个操作；如果审核不通过，ApproveRejectedState，通过这个state完成状态流转到审核不通过的状态

4.4.6 上下架商品

（1）只有是待上架状态的商品，可以执行上架操作；只有是已上架状态的商品可以执行下架操作

（2）就到一个唯一的状态流转的管理组件中去，负责去将商品的状态进行流转 

思路同上，先创建一个当前state组件，判断能否执行某个操作，如果可以就执行，然后创建下一个状态的state组件，完成状态流转的逻辑

4.4.7 删除商品

（1）只有待审核、审核未通过、待上架，这三种状态的商品是可以进行删除的；商品必须是没有被任何采购单给关联的时候，我们才可以删除这个

（2）删除商品的图片列表

（3）删除商品的详情内容数据

（4）删除商品对属性关联的值

（5）删除商品关联的sku的数据，包括了sku的属性值，以及sku的库存数据

（6）删除商品自己的数据 

创建一个当前的状态组件，调用一下准备删除的方法，判断能否执行删除操作

4.5 商品查询

4.5.1 搜索商品

用全模糊匹配的方式，来搜索对应的商品的名称，然后支持分页，搜索完以后直接返回第一页的数据即可。 

这里要强调的一点是，在这一块，都是针对sku级别去搜索的，所以需要将spu与sku都关联在一起，然后根据商品名称去搜索，返回的都是sku级别的数据。

4.2.5 品类筛选

我们的商品是只能挂在叶子类目下，不能挂在父类目下面的，所以我们要求的是首页进行品类筛选的时候，只能点击这个叶子类目。 

后台直接根据叶子类目筛选出来对应的商品，然后支持分页查询即可。 

4.2.6 查询商品列表

搜索商品或者是品类筛选，都会进入一个商品列表，在这个列表里，分不同的情况来支持查询： 

（1）如果是搜索之后进入的商品列表页面，仅仅能支持分页查询，不支持条件筛选。每次翻页的时候，都会将这个搜索词给传递过来，查的是那个搜索词下的第几页。

（2）如果是品类筛选之后进入的商品列表页面，仅仅支持分页查询，不支持条件筛选，每次翻页的时候，都会将这个品类的ID传递过来，查的都是那个品类下的第几页

4.2.7 商品详情页

点击某个商品进入商品详情页，直接根据商品ID将商品详情页中的所有数据给展示出来。需要从库存中心加载库存数据，从促销中心加载促销活动数据。这一块，我们初期一开始，采取的一个思路是，商品中心在接收到这个查询请求之后，商品中心跟库存中心以及促销中心去通信，或者数据，封装到一个VO中统一返回给前端页面去显示。 

库存的查询，只能是ajax异步加载的，因为一开始进入页面，是一个spu，还没有去选择销售属性的组合，没有办法定位出来一个sku。等到你选择好一个sku之后，会直接ajax异步加载出来这个sku的库存。 

促销数据，是商品中心跟促销中心直接通信，获取到这个商品spu关联的促销活动，给封装到一个VO中，展示出来即可

5、测试用例设计

5.1 单元测试用例设计

要求的是所有的包下的所有的类的每一个public方法都要执行单元测试

5.2 冒烟测试用例设计

要求的是对每个controller接口都要执行冒烟测试

6、日志设计

要求的是对每个类都在自己这一层try catch异常，在catch异常的时候打印出完整的异常信息1627098499

##### 05_电商系统v1.0版本采购中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 系统内部接口

2.1.1 是否有采购单关联商品

PurchaseOrderService 

Boolean existRelatedPurchaseOrder(Long goodsSkuId) 

商品中心在删除商品的时候，就给你一个sku id，你采购中心来给我判断一下，是否有采购单关联我指定的这个商品，如果有关联，就返回true；如果没有采购单关联这个商品，就返回false

2.1.2 更新采购单状态

如果你直接就提供一个接口，谁想要把这个采购单更新为什么状态，让别人来决定，这样的话，别人就会很麻烦。实际上这样子就会破坏了子系统自己的高内聚的一个原则。所以我们采取的策略，是让别人简单调用我们一个有业务含义的一个接口方法，具体对应这个业务操作，我们要将采购单更新为什么状态，我们自己来决定。 

Boolean updatePurcaseOrderStatus(Integer purchaseOrderStatus) 

这个接口行吗？当然不行了，其他子系统的开发同学还要去维护你的采购单有哪些状态？WMS系统，财务系统，根本就不care你这个东西。 

如何通过MQ来让这些子系统解耦，一般来说我们设计整套系统的时候，都不是这么玩儿 

2.1.3 创建采购入库单通知

PurchaseOrderService 

Boolean createPurchaseWarehouseEntryOrder(Long purcaseOrderId)

2.1.4 完成采购入库单通知

PurchaseOrderService 

Boolean finishPurchaseWarehouseEntryOrder(Long purcaseOrderId)

2.1.5 创建采购结算单通知

PurchaseOrderService 

Boolean createPurchaseSettlementOrder(Long purcaseOrderId)

2.1.6 完成采购结算单通知

PurchaseOrderService 

Boolean finishPurchaseSettlementOrder(Long purchaseOrderId)

3、开发架构 

3.1 实现类图

没有什么新鲜东西，但是我给大家提点一句，我们要用的设计模式。只要是涉及到有较为复杂的状态流转的业务场景，立即想到用状态模式，用一个StateContext封装所有的这个数据有关的状态判断、状态流转的操作；用各种State来封装每个状态要执行的一些操作。 

复杂的状态变化相关的东西全部集中到一个地方来，非常便于我们后续维护这个数据的状态变更的逻辑。 

如果不用这个状态模式来处理这种较为复杂的状态流转，大家想象一下，跟状态相关的逻辑，全部分散在各个service接口中，比如新建的时候有一点逻辑；编辑的时候有一点逻辑；审核的时候有一点逻辑。后面要维护这个状态相关的逻辑，会很麻烦的。 

我们这里对采购中心用的唯一的一个设计模式，就是状态模式，用来维护采购单的状态流转，核心思路跟商品中心的状态模式几乎类似，一样的，大家参考即可。 

构造器模式来构造采购单

3.2 包设计

我们在这里就不写了，直接参考之前的模块即可s

4、运行流程

4.1 供应商管理

4.1.1 查询供应商列表

按照筛选条件来筛选，支持分页查询

4.1.2 新增供应商

将页面上提交过来的数据保存到数据库中即可

4.1.3 根据ID查询供应商

根据ID将供应商的数据从数据库中查询出来即可

4.2 采购单管理

4.2.1 查询采购单列表

按照筛选条件去筛选，同时支持分页查询

4.2.2 新建采购单

将采购单信息以及采购单商品条目信息，都保存到数据库中即可。新建之后，这个采购单的状态是编辑中。

4.2.3 根据ID查询采购单

实际上是要将采购单自己的数据查询出来，同时也要将采购单商品条目对应的一些数据从商品中心查询出来的（包括商品名称、类目、品牌、sku编码，等等）。

4.2.4 编辑采购单

（1）先判断一下，只有编辑中状态的采购单，才可以执行编辑操作

（2）编辑的时候，会进入一个页面，根据ID查询出来采购单的数据，回显，可以编辑

（3）编辑完采购单的数据之后，可以保存

（4）更新采购单自己的基本数据

（5）删除采购单对应的所有商品条目数据

（6）重新插入采购单对应的所有商品条目数据

（7）编辑完了过后，采购单的状态还是处于编辑中

4.2.5 采购单提交审核

（1）先判断一下，只有编辑中状态的采购单，才可以执行提交审核的操作

（2）提交审核之后，会将采购单的状态流转到待审核

4.2.6 审核采购单

（1）先判断一下，只有待审核状态的采购单，才可以执行审核操作

（2）点击审核按钮之后，会进入这个审核采购单的一个页面，里面会显示采购单完整的数据

（3）可以选择是审核通过/审核不通过

（4）根据审核通过或者是不通过，将采购单的状态流转到下一个状态

（5）如果审核不通过，那么采购单的状态流转到编辑中；如果审核通过，那么采购单的状态流转到已审核

（6）如果审核通过，那么会调用调度中心的接口，执行调度采购入库的操作

4.2.7 更新采购单状态

（1）采购入库单为待审核状态时，会将采购单的状态更新为待入库

（2）采购入库单为已入库状态时，会将采购单的状态更新为已入库

（3）采购结算单为待审核状态时，会将采购单的状态更新为待结算

（4）采购结算单为已完成状态时，会将采购单的状态更新为已完成

5、测试用例设计

5.1 单元测试用例设计

5.2 冒烟测试用例设计

6、日志设计

##### 06_电商系统v1.0版本WMS中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 创建采购入库单

WmsFacadeService 

Boolean createPurchaseInputOrder(PurchaseInputOrderDTO purchaseInputOrderDTO )

2.2 创建销售出库单

WmsFacadeService 

Boolean createSaleDeliveryOrder(SaleDeliveryOrderDTO saleDeliveryOrderDTO)

2.3 创建退货入库单

WmsFacadeService 

Boolean createReturnGoodsInputOrder(ReturnGoodsInputOrderDTO returnGoodsInputOrder)

2.4 提交订单

WmsFacadeService 

Boolean submitOrder(OrderDTO orderDTO)

2.5 支付订单

WmsFacadeService 

Boolean payOrder(OrderDTO orderDTO)

2.6 取消订单

WmsFacadeService 

Boolean cancelOrder(OrderDTO orderDTO)

3、开发架构

3.1 实现类图

（1）采购入库单的状态管理，可以用状态模式的，统一集中式管理状态的逻辑，参考之前的讲解 

（2）库存管理这一块，大家都是要去更新库存，只不过不同的方法下，更新库存的逻辑不同，那么大家来考虑一下，这块可以用什么设计模式呢？命令模式，你其实是站在库存管理的角度，针对库存管理，去发出一条一条的命令。 

StockUpdaterCommand 

AbstractStockUpdaterCommand：定义了更新库存的几个步骤，每个步骤都留空，给每个command自己去实现 

SubmitOrderStockUpdaterCommand

PayOrderStockUpdaterCommand

CancelOrderStockUpdaterCommand 

StockUpdaterInvoker 

不同的命令就是具体的逻辑不同，但是可以用同一个执行类来执行这个command，用这个StockUpdaterInvoker来执行这个不同的command 

工厂方法模式来创建出这些command 

StockUpdaterCommandFactory，里面包含了一个创建命令的方法，这个方法中会完成创建命令的一些通用的逻辑代码，比如说从OrderDTO中解析出来需要的一些数据。具体的创建出来这个命令的逻辑，由子工厂来完成 

SubmitOrderStockUpdaterCommandFactory

PayOrderStockUpdaterCommandFactory

CancelOrderStockUpdaterCommandFactory 

将命令模式+工厂方法模式+模板方法模式，结合起来使用 

[WMS中心实现类图](https://www.processon.com/diagraming/5a7ecf61e4b059c41abf0d6f) 

用构造器模式来构造采购入库单、销售出库单、退货入库单 

原型模式，创建采购入库单的时候，获取到的是一个采购单，此时你可能需要将采购单的数据拷贝一份到采购入库单中去 

责任链模式，可以运用到wms中心的采购入库单完成审核的业务流程中去，形成一个业务处理流程的链条，后面我们如果要对这个业务流程做增加一个环节，删除一个环节，修改一个环节，重新组装一个业务流程，都很方便

3.2 包设计

4、运行流程

4.1 货位管理

4.1.1 查询货位列表

直接查询货位列表即可，支持按照货位编号筛选，支持分页查询

4.1.2 新增货位

直接填入一个货位编号和备注说明，将货位信息保存到数据库中即可

4.1.3 根据ID查询货位

根据ID将货位信息查询出来即可

4.1.4 更新货位

将页面提交的货位编号和备注说明，保存到数据库中即可。其实货位编号一旦创建就不允许变更了。

4.1.5 删除货位

采购入库单，销售出库单，都是关联着这个货位的，其实最好是不允许删除这个货位

4.2 采购入库单管理

4.2.1 创建采购入库单

接收到采购单的数据，基于采购单的数据去创建这个采购入库单。创建之后，采购入库单的状态是编辑中。

4.2.2 查询采购入库单列表

按照对应的筛选条件，支持分页查询即可

4.2.3 根据ID查询采购入库单

根据ID将采购入库单的数据都查询出来即可，但是这里要将每个商品sku的数据从商品中心那里查询出来

4.2.4 编辑采购入库单

更新采购入库单中的实际到货时间，以及每个采购入库单商品条目的合格产品数量以及到货产品数量；在线下完成到货商品上架的过程中，会录入很多个商品上架条目，哪个商品在哪个货位上了多少个。 

编辑之前要检查，只有编辑中状态的采购入库单，才可以执行编辑操作；编辑过后，采购入库单的状态是编辑中。

4.2.5 采购入库单提交审核

提交审核之前要检查，只有处于编辑中状态的采购入库单，才可以执行提交审核的操作；实际点击提交审核的按钮之后，会将采购入库单的状态变为待审核。

4.2.6 审核采购入库单

审核之前要检查，只有待审核状态的采购入库单，才可以执行审核的操作 

实际点击审核按钮之后，会进入一个审核界面，上面会展示出来三块数据：采购入库单数据；采购入库单商品条目数据；采购入库单商品上架条目数据。可以选择通过/不通过。 

如果不通过的话，状态回到编辑中 

如果通过的话： 

更新状态

（1）将采购入库单的状态变为已入库

（2）同时通知采购中心，将采购单的状态变为已入库 

更新库存

（1）更新自己本地仓库商品的可用库存，从采购入库单的商品上架条目表中去获取每个商品上架的数量，给累加到对应的库存表中去

（2）更新自己本地每个货位每个商品的可用库存，从采购入库单的商品上架条目表中获取每个商品上架的数量，给累加到对应的库存表中去

（3）通知调度中心，更新商品库存和货位商品库存，将自己刚刚累加的数据都发送给调度中心 

创建采购结算单

（1）创建这个采购结算单，这里的话呢，就是直接根据采购入库单的所有数据，但是剔除掉商品上架数据，但是要包含这里的3个额外数据

（2）将采购结算单，同步到财务中心去 

[审核采购入库单活动图](https://www.processon.com/diagraming/5a7ec669e4b0615ac0554730)

4.3 WMS中心库存管理

4.3.1 提交订单

提交订单之后，订单中心通知调度中心操作库存，调度中心通知WMS操作库存。调度中心会直接通知WMS，仓库中商品的可用库存减1，锁定库存加1，仓库货位中商品的可用库存减1，锁定库存加1。

4.3.2 支付订单

用户支付订单之后，订单中心会通知库存中心更新库存，库存中心通知调度中心更新库存，调度中心通知WMS更新库存。此时将仓库商品的锁定库存减1，仓库商品的已出库库存加1；将仓库货位商品的锁定库存减1，将仓库货位商品的已出库库存加1。

4.3.3 取消订单

将仓库商品的锁定库存减1，将仓库商品的可用库存加1；将仓库货位商品的锁定库存减1，将仓库货位商品的可用库存加1。

4.4 销售出库单管理

4.4.1 线下商品出库流程

一个用户下了一个订单，这个订单的不同的商品会被调度中心，调度到一些仓库里去发货，此时仓库工作人员会收到一个销售出库单，调度中心也标识出了，哪些商品从哪个货位上面去出库，发货 

1、调度 

锁定库位，跟物流公司进行通信，申请发货物流单号，然后为订单分配一个物流单号。库位锁定的原则是先进先出，商品入库上架的时候也是先进先出的，这样可以保证商品发货的顺序性。这里是什么意思，假如说我们2017-01-01进了1万件衣服；2017-02-01又进了1万件衣服；发货的时候，先进先出，优先发2017-01-01进的衣服。这里锁定的是货位库存，就是每个货位这个商品有多少库存 

这块其实是在调度中心做的，这个信息已经设置在销售出库单中了 

2、打单 

打印发货单、物流单。你平时网上购物的时候会发现有2个单子。发货单是放在包裹里面的，告诉你本次发货了哪些东西；物流单是贴在包裹上面的。 

发货单，实际上是调度中心直接就给创建好了 

物流单，是调度中心跟第三方物流厂商的系统进行通信，直接申请了一个物流单 

调度中心，发货单（发了哪些商品，商品清单），物流单（哪个物流商，运送到哪儿），商品出库单（调度，从哪个仓库，发送哪些商品，从哪些货位去拣货，物流商是谁） 

3、捡货 

根据销售出库单中调度好的哪些商品从哪个货位发货s 

女士羊毛衫，从货位A01-2-05，去拿2件

男士袜子，从货位A05-5-09，去拿10件 

就是工作人员推着捡货车去捡货，然后捡货之后会扣减锁定的货位库存 

4、复核 

对捡货完成的订单进行核对，确保发货单、实物商品、物流单的统一 

5、包装 

对复核完的商品进行打包和称重，发货单放包裹里面，物流单贴包裹上面，发货单放包裹里面 

6、交接发货 

根据物流单将打包好的商品推送到仓库里面，仓库外面，跟物流公司的交接区，接着物流公司会按照物流单去进行发货。在线下的一个销售出库的这么一个过程

。我们这次，第一个版本，重点做WMS的仓库管理、货位管理、采购入库、销售出库、退货入库

4.4.2 创建销售出库单

WMS系统接收到调度中心发送过来的销售出库单、发货单、物流单，然后全部保存到本地，状态是编辑中欧。接着其实，仓库的工作人员，只要在系统里查看到有心的销售出库单，就需要去按照销售出库中的指示，去完成一整套线下的出库流程。物流厂商就开始发货了。 

唯一的一点区别，就是销售出库单包含了每个商品的出库条目，另外销售出库单新增了一个字段：发货时间。

4.4.3 销售出库单列表

每一行，每个销售出库单，显示的是一个汇总的数据：订单编号、收货人信息、配送信息、付款信息、发票信息、商品数量、商品总金额。还要在包含一些执行销售出库的线下流程中对应的一些数据：创建时间、操作人、最近一次操作时间、审核人、审核时间、复核人、物流单号、发货时间、销售出库单的状态。 

显示的列表内容基本跟订单列表保持一致即可，订单列表是如何显示的，我们这里销售出库单列表页如何显示就可以了，只不过新增一个字段，发货时间。而且销售出库单列表要加上商品出库条目，货位 -> 商品 -> 多少件。

4.4.4 编辑销售出库单

在走完线下流程之后，负责出库的人，需要在销售出库单中编辑一下对应的验货复核人、发货时间。列表页的右侧操作栏中，有一个编辑按钮，只能对编辑中的销售出库单进行编辑。

4.4.5 提交审核

然后线下的商品出库流程走完之后，完成了销售出库单的编辑，里面加入了谁负责验货的复核，发货的时间，就会提交审核的按钮。在列表页的右侧操作栏中有一个提交审核的按钮。执行之后，将销售出库单的状态变为待审核。

4.4.6 审核销售出库单

只有对待审核的状态的销售出库单，可以点击列表页右侧操作栏中的审核按钮，进入一个审核界面。包含了销售出库单、发货单、物流单，所有的信息和数据。可以去执行审核操作：通过/不通过。 

审核通过后 

（1）销售出库单的状态变为：已完成

（2）通知财务中心给物流商打款，这次的一个物流费用。其实这块也可以做成跟供应商一样的，那种定期打款，但是我们这里简化一下，就做成审核后直接打款。

（3）通知订单中心，将订单的状态修改为待收货

4.5 退货入库单管理

4.5.1 创建退货入库单

调度中心将退货入库单发送过来，此时退货入库单基本包含了订单所有的数据，同时包含退货工单的部分数据（退货的原因和备注），总的到货时间，每个商品条目有一个合格数量、到货数量，退货商品的上架条目。同时有自己独有的一些字段：创建时间、操作人、最近一次操作时间、审核人、审核时间、状态 

此时状态：编辑中

4.5.2 退货入库单列表

退货入库单列表显示哪些字段：其实跟订单列表保持基本一致即可，同时包含退货原因。同时包含退货入库单自己特有的一些数据：创建时间、操作人、最近一次操作时间、审核人、审核时间、状态。此外， 

此外，还包含了一些特殊的数据：一个是总的一个到货时间；每个商品，都有良品率，比如说一个订单中，有用户购买了5个iphone，此时要检查一下，iphone中质量过关的有几个；收到了几个商品，比如说购买了5个iphone，此时收到了4个？5个？ 

上面说的那3个额外的数据，也是需要在退货入库单列表中要显示的

4.5.3 编辑退货入库单

仓库的工作人员，接收到了退货入库单之后，会等待这个退货商品寄送到仓库里来。接收到商品之后，就会去执行质量检查，执行完之后会填写上面说的那些数据。另外一个就是工作人员此时会执行一个线下的上架流程，他会自己根据先入先出的原则，将退回来的商品，上到对应的货架中去。 

此时工作人员，还需要退货入库单中填写商品上架的数据：哪个商品，商品名称，上了几件，到哪个货位中去。 

综上所述，工作人员一边执行线下的操作，一边线上填写退货入库单

4.5.4 提交审核

线下执行完了退货入库的操作，同时编辑完了线上的退货入库单之后，在退货入库单列表页的右侧操作栏中，可以点击“提交审核”。此时退货入库单的状态变为：待审核。 

4.5.5 审核退货入库单

可以有人去审核退货入库单，在退货入库单列表页的右侧操作栏中，如果状态是待审核，可以点击审核按钮，进入一个审核页面中，会显示退货入库单完整的一个记录。可以选择通过/不通过。 

如果审核通过： 

（1）将退货入库单的状态修改为：已完成

（2）通知客服中心，将退货工单的状态，修改为：已完成

（3）通知财务中心，进行退货打款，将订单支付的金额退还到用户的账户中

（4）更新仓库本地的仓库商品的已出库库存减1，可用库存加1；仓库货位中的商品库存，已出库库存减1，可用库存加1

（5）通知调度中心更新库存

（6）通知会员中心，将会员成长值减去对应的一个订单金额*10%的成长值，扣减积分

5、测试用例设计 

5.1 单元测试用例设计

5.2 冒烟测试用例设计

6、日志设计

##### 07_电商系统v1.0版本会员中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口 

（1）DO：Data Object，数据对象，一个DO一般是对应于一张表，或者是Mapper查询接口中的返回类型，mapper和dao返回的都是DO

（2）DTO：Data Transfer Object，数据传输对象，service组件需要将dao组件返回的DO对象给封装成DTO对象，再返回给controller组件，或者是别的service组件。service必须将数据封装为DTO，返回给其他的controller或者是service来使用

（3）VO：view object，其实就是将页面中需要展示的数据封装在VO里面，然后在以前是将VO给传输给页面模板，比如JSP（JSTL标签语法，可以将VO中的数据给展示出来），freemarker，velocity，thymeleaf。restful接口，在接口中可以将一个接口要返回的数据，封装在VO里面，从接口返回即可。

（4）Query：查询条件，controller里面接收的页面发送过来的查条件，哪怕是service层对外暴露的接口，也可以用query来接收复杂的一些查询条件

（5）PO：就是将DO不是作为data object，而是作为domain object，然后将PO作为persistence object，一个PO对应一张表，DO就是我们平时放在domain包中的领域模型对象

（6）BO：service组件对外可以返回这个BO，这个BO的话呢是包含业务逻辑的，不光是包含一堆数据和getter和setter方法，还包括了这个很多的业务逻辑方法

（7）AO：application object，就是跟展示层相关的一些数据 

大家有没有发现迄今为止，我们耗费了大量的精力在设计这个接口文档。但是其实接口怎么设计，设计的怎么样，不是什么技术问题。接口只不过是两套系统之间互相交互的一个协议。 

所以，我是这么想的，如果咱们继续耗费大量的精力在接口设计这块，可能会导致我们的课程进度较为缓慢。学习的价值不是特别大。 

就是说，如果是那种面向前端的接口，controller里面的接口，我们就不在这里设计了。写很多json格式的输入和输出，很麻烦，耗费的时间太大了。咱们这块直接在详细设计这个环节给省略掉。当然了，如果你们做项目，一定要按照我之前几讲的示范，所有的接口都在详细设计文档里来写。 

但是我们这里，就是说对前端的接口，我们在这里不写了，后面写代码的时候，咱们直接就把接口定义出来，然后就直接写代码。 

但是，有一点很重要的是，这个模块与模块之间的交互的接口，比如说采购中心和调度中心之间的交互，都是需要依靠接口的，而且我们需要在整个工程初始化的时候，就将这个接口给定义出来。所以模块与模块之间的交互的接口，必须是要设计的。s

2.1 用户当天第一次登录

MembershipFacadeService 

Boolean firstLoginDaily(Long userAccountId)

2.2 用户支付订单

MembershipFacadeService 

Boolean payOrder(Long userAccountId, Long totalOrderAmount) 

Boolean updateMemberLevel(Long userAccountId, Long updatedGrowthValue) -> 废了，订单中心居然要来care，我完成了一个订单，我要记住是把订单金额的10%？20%？来累加在用户成长值中？还有完成了成长值的一个累加之后，我还得去care多少分~多少分是什么级别？ 

我是不是对会员等级的service调用了一次payOrder接口之后，还要对这个会员积分的service再调用一次payOrder接口，先通知你更新会员等级，再通知你更新会员积分 

订单中心的同学，居然要去care说，会员中心由会员等级，会员积分，会员白条，会员账户余额，会员抵用券 

相当于是MembershipFacadeService，就作为会员中心唯一一个对外的门面接口类，在这个门面接口类里面，会调用会员中心自己的大量的service组件、设计模式的comand组件、dao组件，反正都不用你来care了 

而且你通知我有个用户支付了这个订单之后，我就知道了，剩余要干什么事儿，我自己来care，不用你管 

其实，到了后面的课程，高并发，大家会发现，这种业务场景可以大量的使用MQ来解耦。我们阶段一干出来这一整套的电商业务系统，到了后面还会不断慢慢完善更多更加细致和更加复杂的电商业务。 

这个真的是很棒，大量的MQ、缓存、高并发架构、高可用架构，全部有复杂的业务系统在这里支撑着，非常棒，非常好玩儿

2.3 用户完成退货

MembershipFacadeService 

Boolean finishReturnGoods(Long userAccountId, Long totalOrderAmount)

2.4 用户发表评论

MembershipFacadeService 

Boolean publishComment(Long userAccountId, Boolean showPictures)

2.5 删除用户评论

MembershipFacadeService 

Boolean removeComment(Long userAccountId, Boolean showPictures)

3、开发架构 

3.1 实现类图

设计模式的最高境界，其实就是无招胜有招，刚开始学会的人，总是在考虑，模式怎么套进去使用。当你彻底领悟了设计模式的思想真谛之后，你在设计系统的时候，详细设计的时候，一边脑子里思考业务需求，一边考虑系统设计，一边就可能就是条件反射式的就会想到可以综合起来运用某些某些设计模式，来设计某个业务，让这个业务后续的一些扩展非常的好。

3.1.1 门面模式 

facade门面模式，其实在这里，就是我们每个子系统对外暴露接口的，统一都是用一个叫做facade的设计模式就可以了，大家应该还记得我之前设计那些对外暴露的接口的service，都是叫什么service。 

但是其实那些service包括咱们本讲的service，你都可以在service前加一个facade。因为这些service其实不是我们传统意义上的service，传统意义上的service可能就是给我们的自己的controller调用的，完成内部的一些业务逻辑 

但是设计的这些对其他子系统的service，相当于是本系统对其他系统的一个门面service，封装了大量的内部的细节，对外就暴露一些含有业务意义的简单方法。 

我们这里提一句，我们在这个系统中，所有的对外的service，全部是facade模式

3.1.2 命令模式+模板方法模式

在这里更新会员等级和会员积分，天然可以用命令模式+模板方法模式 

上面的那些接口 

首先，模板方法模式，这个是肯定要用的。因为按照抽象的思路来想象一下，如果不用模板方法模式，会导致每个接口里都写了相同的更新步骤（5个步骤），还有一些步骤的代码是一样的。 

如果不用模板方法模式，相同的更新步骤，不同的地方都定义了，但是可能不同的人写，定义的一些每个步骤的方法名称都不一样，都是有可能的。甚至每个步骤干嘛可能都不一样，甚至有的人还把两个步骤合并为了一个步骤。 

有人把更新成长值和更新会员等级放一个方法，有人把更新成长值和更新会员等级放两个方法。那些接口里面的执行步骤本质是一样，结果看起来是不一样的，维护成本很高。 

所以说用模板方法模式限定了通用的统一的执行步骤，那么每个接口对应的command的执行步骤看起来都是一样的，维护成本就很低。 

用模板方法模式，还可以将一些通用的逻辑，比如说会员等级的计算，放到抽象父command里面去，就可以实现相同逻辑放一个地方 

命令模式 

如果不用命令模式，会怎么样呢？其实就是说按照一个比较简单的思路，就是单纯用模板方法模式抽象出一套类来。比如我们后续要对每个操作做一些特殊的处理，到了后面，比如对会员积分的更新，要做成异步的操作。 

比如说通过纯内存队列来执行，我们可能是需要将不同类型的接口对对应的操作发送到不同的内存队列中去排队，甚至我们可能还需要对每个命令设计一套撤销这个命令的逻辑。比如说我们现在执行这个命令，这个命令有多个步骤，其中某个步骤失败了，此时可以察觉到之后对这个命令执行反向操作。 

比如某个步骤增加growth_value，那么反向操作就是减少；某个步骤是插入明细数据到数据库，反向操作就是删除这条明细数据。 

也就是说，我们如果将这个更新的操作封装成命令的概念，后续就可以对这个命令做各种副复杂的高级的操作，排队，撤销。其实就是说，命令模式真正的真谛，就在于说将某个操作封装成一个命令的概念，在后面可以对这些命令做一些复杂的操作，排队、撤销。

3.1.3 单例模式

实际上，单例模式，就是在大量的工厂模式中来使用，工厂一般都做成单例的

3.2 包设计

4、运行流程

4.1 用户账号注册与登录

4.1.1 用户注册

输入用户名和密码，在后台校验一下是否已经有这个用户名了，如果有就不允许注册这个账号；如果没有这个用户名，就可以注册这个账号

4.1.2 用户登录

（1）根据用户提交的用户名和密码，去账号表里查是否有，是否正确，如果正确，那么就允许登录

（2）登录之后将用户账号信息放在session中，代表已经登录了

4.1.3 用户登录过滤

所有的请求，都要走一个用户是否登录的过滤器，看一下当前session中是否有对应的账号信息，如果没有，代表还没登录，返回一个异常值，让前端同学给跳转到登录界面；如果session中有账号，代表就已经登录了

4.2 个人信息管理

4.2.1 个人信息查询

上来可以将用户的个人信息都给查询出来，包括了账号名、收货地址（多个）、会员个人详细信息、成长值、会员等级、会员积分。

4.2.2 个人信息设置

可以设置自己的详细的个人信息

4.2.3 收货地址管理

可以查询收货地址列表，新增收货地址，编辑收货地址，删除收货地址

4.2.4 修改密码

要求的是输入以前的旧密码，再输入两遍这个新密码就可以了

4.2.5 查询会员等级变更明细

点击自己的会员等级，可以进入一个明细列表页面，显示了明细的所有数据，可以分页查询，不支持条件筛选。

4.2.6 查询会员积分变更明细

点击自己的会员积分，可以进入一个明细列表页面，显示了明细的所有数据，可以分页查询，不支持条件筛选

4.3 会员等级变更

每天的第一次登录：获得成长值奖励，+5分

购物：订单金额 * 成长系数，算出来一个成长值奖励，10%，100元的商品 * 10% = +10分

退货：扣减成长值，商品金额 * 10%，扣减你的成长值

评价：发表一个评论，可以积累成长值，+10分

晒单：进行晒单，可以积累成长值，+10分

评论被投诉后删除了：扣减成长值，扣减你的评论的成长值 

100分以下：铜牌会员，1

100分~500分：银牌会员，2

500分~1000分：金牌会员，3

1000分以上：钻石会员，4 

在对应的操作发生的时候，需要过来调用会员中心的接口，需要根据上面的算法完成会员成长值的变更，同时完成会员等级的变更，同时同时会员等级变更明细的记录。

4.4 会员积分变更

每天的第一次登录：获得成长值奖励，+5分

购物：订单金额 * 成长系数，算出来一个成长值奖励，10%，100元的商品 * 10% = +10分

退货：扣减成长值，商品金额 * 10%，扣减你的成长值

评价：发表一个评论，可以积累成长值，+10分

晒单：进行晒单，可以积累成长值，+10分

评论被投诉后删除了：扣减成长值，扣减你的评论的成长值 

在对应的操作发生的时候，需要过来调用会员中心的接口，需要根据上面的算法完成会员积分的变更，同时完成会员积分变更明细的记录。

5、测试用例设计

6、日志设计

##### 08_电商系统v1.0版本购物车详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

3、开发架构

3.1 实现类图

3.2 包设计

4、运行流程

4.1 加入购物车

得给前端提供一个接口，这个不是给其他系统提供的接口，商品sku ID，选择的购买数量，发送过来。 

在购物车的接口中，需要获取当前登录的用户，然后就可以定位到这个用户的购物车了，然后在购物车的购物车item里面，去找一下有没有加入这个商品，如果之前加入过，那么对这个商品的购买数量进行累加；如果之前没有加入过这个商品，那么就新增一条购物车item记录。

4.2 查看购物车

（1）显示出来购物车的每个item，对每个item都要去商品中心查询那个sku的数据

（2）每个item，显示一个购买的数量，但是这个在前端界面是可以调节的

（3）查询商品的库存数据，从库存中心去查询

（4）每个商品可以使用的促销活动的列表，从促销中心去查询

4.3 调节商品购买数量

在购物车的界面中，是可以对每个商品购买的数量进行调节的，调节之后需要后台ajax过来更新到数据库中去，购物车是离线的

4.4 删除商品条目

将某个商品条目直接删除过后，也需要ajax到后端数据库中去删除的

4.5 结算购物车

点击结算按钮之后，直接在前端之间进行跳转，这个过程是不需要后台的。前端也很强大了，可以用node.js，也有一定的服务端的逻辑和功能的。直接跳转到一个前端页面，将购物车中的当前数据直接给显示到订单确认页面中了，但是订单确认页面中的其他数据，都需要从订单中心去走。

5、测试用例设计

6、日志设计

##### 09_电商系统v1.0版本支付中心详细设计文档 

支付中心到了后面，是我们的重头戏，业务迭代，支付中心我们会迭代的非常复杂和完善，复杂100倍，1000倍的支付架构出来。媲美任何一个企业级，商用级的支付架构。

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

到了实际开发的时候，给大家讲讲怎么对接第三方支付之后，我们再定接口

3、开发架构

3.1 实现类图

在后面我们实际做到跟第三方支付对接的时候，我们需要实现代理模式，这是代理模式一个经典的使用场景，就是我们在本地可以实现一套支付接口service，然后实际的service实现类，就是每个支付方式一个实际的service实现类 

然后每个service实现类，实际上就是一个代理类，代理了对远程的第三方支付接口的访问

3.2 包设计

4、运行流程

4.1 第三方支付对接

4.1.1 支付宝对接

4.1.2 微信对接

4.2 支付交易流水管理

4.2.1 保存支付交易流水

每次完成一次支付之后，就保存一条交易流水

4.2.2 查询支付交易流水

支持一些筛选条件，分页查询支付交易流水

5、测试用例设计

6、日志设计

##### 10_电商系统v1.0版本订单中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 订单完成发货

OrderFacadeService 

Boolean goodsDeliveryFinished(Long orderId)

2.2 退货工单审核不通过

OrderFacadeService 

Boolean returnGoodsWorksheetRejected(Long orderId)

2.3 退货工单审核通过

OrderFacadeService 

Boolean returnGoodsWorsheetApproved(Long orderId, 

String returnGoodsConsignee,

String returnGoodsDeliveryAddress,

String returnGoodsConsigneeCellPhoneNumber)

2.4 确认收到退货商品

OrderFacadeService 

Boolean returnGoodsReceived(Long orderId)

2.5 退货入库单审核通过

OrderFacadeService 

Boolean returnGoodsWarehouseEntryOrderApproved(Long orderId)

2.6 财务中心完成退货打款

OrderFacadeService 

Boolean refundFinished(Long orderId)

3、开发架构

3.1 实现类图

3.1.1 订单状态管理（状态模式）

订单每次执行一个业务操作，会需要进行状态的流转，每次流转到一个状态，都同样需要执行3个操作： 

（1）更新订单自己的状态

（2）更新订单退货记录的状态（可能）

（3）新增一条订单的操作日志 

定义一个state接口，里面定义好这么3个方法，定义一个context，对订单的状态流转，全部调用context的业务方法，context业务方法中决定，在执行这个业务操作的时候，订单的状态流转到哪个state，创建那个state的实例，然后执行那个state的3个方法，完成那个状态下的逻辑处理。 

这不就是典型的状态模式吗？context决定数据的状态如何流转 -> 通过state来执行流转到那个状态之后要执行的一些操作。 

实现类图，我们不画了，之前给大家已经画过了，这个大家可以自己去画一下，我们就直接写代码了。当然在公司里，肯定是像这种重要的实现类图，都是需要去画出来的。

3.1.2 异步调用（中介者模式+观察者模式+备忘录模式）

（1）订单中心对库存中心的库存操作调用，以及对调度中心的调度发货的调用，都通过内存队列做成异步的方式，来让订单中心跟库存中心以及调度中心来解耦，异步，可以让订单中心的操作非常的快速。中介者模式的思想 

（2）观察者模式，订单中心执行了异步的操作之后，他要去对其他的中心注册一个观察者，等待其他中心完成操作之后，将结果通知给订单中心 

（3）备忘录模式，一旦订单中心发现说内存队列满了，写不进去了，那么此时就需要通过备忘录将数据离线存储到磁盘上去。等后面内存队列恢复了，就可以通过备忘录将数据给恢复回来。 

3.1.3 价格计算（策略模式+抽象工厂模式）

大体上来说，在订单确认的页面： 

（1）将每个商品的促销活动以及当前订单的优惠券给发送到后台去

（2）由后台，完成促销活动折扣金额的计算，完成赠品附加到订单中去，优惠券对整个订单的金额的折扣的计算，还要完成运费的计算

（3）在这里有这么一个思考，就是不同的促销活动如何计算，完全就是不同的策略

（4）如果不用策略模式的话，那么就会出现一大坨的if else，屎一样的代码，策略模式。

（5）运费的计算，实际上是找物流中心去现场计算的 

策略模式+抽象工厂模式 

每个商品都是有一个运费模板的，每个商品都绑定了促销活动，现在要做的事情，就是先遍历每个商品，对每个商品都计算出来对应的运费以及促销活动的折扣金额（可能不是计算折扣金额，而是附加赠品） 

可以拿到一个总的，每个商品的促销活动折扣金额，同时赠品也处理完了，总的运费 

也是对优惠券使用策略模式，获取优惠券类型对应的策略，然后计算出优惠券的抵扣金额 

促销活动的金额、优惠券的金额、运费，商品总金额，本来就有 

每个商品对应的赠品也处理好了

3.1.4 构造器模式

构造这个订单数据

3.1.5 装饰器模式

装饰器模式，就是给某个目标类动态增加一些功能，可能会做一个装饰类包装那个目标类，然后在目标类的方法执行的前后，都完成一些增强的功能 

咱们平时业务开发中，经典的用法，spring aop，动态代理包装目标类，然后可以织入我们想要的额外的增强功能： 

（1）事务

（2）订单操作日志，记录一条订单操作日志，适合用装饰器模式来实现，spring aop，订单service织入一层增强，对我们指定的方法就可以自动插入一条订单操作日志

3.2 包设计

4、运行流程

4.1 提交订单

4.1.1 订单确认

在提交订单的确认页面中，需要显示一些数据 

（1）收货人列表，可以选择一个收货人+收货地址+联系电话（从会员中心去查询的）

（2）选择一个支付方式：仅仅支持支付宝/微信（写死的）

（3）商品列表：选择使用的促销活动、商品缩略图、sku编号、商品名称、销售属性、商品价格、商品毛重、商品长宽高、购买数量、库存数量、库存是否充足（从购物车点击结算的时候，将界面上的购物车数据，直接给带到了这个页面中来）

（4）赠品处理：还需要走订单系统的后台接口，去附加这个赠品信息，给订单补充一些赠品的数据，只不过将赠品的价格设置为0即可（走后台接口，去处理赠品信息）

（5）可以填写订单备注

（6）可以填写发票信息，填写发票的类型、抬头、纳税人识别号、内容

（7）可以选择是否使用优惠券（从促销中心加载这个会员领取的优惠券列表）

（8）显示价格明细：总价、运费、促销折扣、优惠券折扣 -> 最终算出一个总价格（商品总金额 - 促销折扣 - 优惠券折扣 + 运费） 

点击提交订单按钮，就可以提交订单

4.1.2 创建订单

（1）接收到生成订单的请求之后，需要去在保存订单数据之前，需要去检查库存是否足够。这里是直接检查库存中心的可销售库存是否足够，因为库存中心、调度中心、WMS三层的库存理论上是一模一样的，所以此时就检查一个库存中心的库存即可。如果可销售库存充足，则进入下面的流程。 

（2）如果库存校验ok，就执行创建订单的流程；如果库存校验不ok，那么就给前端返回一个异常的说明，告诉他订单中的某些商品库存不充足。 

（2）保存订单的数据，生成订单号，订单状态：待付款 

（3）执行锁定库存的操作：那么首先是订单中心要通知库存中心，商品的可销售库存减1，商品的锁定库存加1 

如果将这一块做成同步的操作，那么会变成订单中心等待着库存中心，库存中心等待着wms中心。等到wms中心库存锁定之后，调度中心才会返回，然后订单中心的这个请求才算是结束。 

库存锁定这一块，我们如果这样子给硬生生做成同步的话，可能会导致面向用户而言，他可能会觉得说等待的时间太长了。实际上用户创建订单，他是不care底层的库存锁定的逻辑的。他只要是订单创建完成就可以了。 

是不是说可以做成异步的，做成异步的之后，肯定要考虑这块库存锁定以及别人在下单的时候，要去检查库存中心的库存，会不会出现一些数据不一致的情况。 

但是刚开始的时候，内测，并发很少的，如果并发很小，那么出现库存数据不一致的情况，会比较少。所以我们前期就不去考虑这个问题了。但是，以后，一定会去考虑这个问题。 

电商系统的库存中心，到了后面是重点中的重点，非常的重要，迭代演进这个库存中的价格。 

我这边给大家一个思路，订单中心可以去调用库存中心，但是库存中心直接接收到请求之后，就给订单中心返回了；对于库存中心的库存锁定 -> 调度中心的库存锁定 -> wms中心的库存锁定，就走异步的这么一个策略了。 

这边参照上面说的那套异步的思路，这块，我们直接将订单中心对于非订单核心逻辑的一些东西，全部做成订单中心跟其他中心是异步通信执行这个操作的。 

订单中心会发送一条消息（包含了数据）到一个内存队列里去，由这个库存中心去消费，消费到之后，库存中心去完成后续的库存的锁定操作。 

（4）保存一条订单操作日志，类型：生成订单

4.2 查询订单列表

直接查询用户的订单列表即可，支持分页查询 

下单时间、订单号 

订单中包含的商品列表：缩略图、sku编号、商品名称、销售属性、购买数量、商品价格、商品毛重、商品长宽高 

收货人姓名 

总金额、促销折扣金额、优惠券抵扣金额、运费、应付金额 

支付方式 

订单状态（未付款的时候，叫做待付款） 

跟踪物流 

查看订单详情 

操作栏（取消订单、付款）

4.3 查询订单详情

（1）订单号、订单状态（等待付款）

（2）订单的操作日志记录：你对订单做的所有的操作，都会记录订单操作日志流水 

（3）收货人信息（收货人、地址、手机号码）、配送信息（配送方式、运费）、付款信息（支付方式、总金额、促销活动抵扣、优惠券抵扣、应付金额）、发票信息（发票类型、发票抬头、纳税人识别号） 

（4）商品列表：缩略图、sku编号、商品名称、销售属性、商品售价、购买数量、商品长宽高 

（5）订单总金额、运费、促销活动折扣、优惠券折扣、应付总金额

4.4 取消订单

4.4.1 手动取消订单

（1）更新订单状态，点击按钮后，选择一个取消原因，订单状态变为：已取消 

（2）释放锁定库存，无论是哪种情况，进行了订单的取消之后，就需要将订单对应的之前的库存进行释放。订单中心需要去通知库存中心，让库存中心释放库存。 

订单中心发送一条消息到内存队列中去，然后由这个库存中心去消费，消费到之后去异步的执行锁定库存的释放即可 

（3）新增一条订单操作日志，类型：手动取消订单

4.4.2 自动取消订单

（1）系统后台线程，自动追踪每个订单，如果是超过24小时没支付的订单，系统直接自动取消 

（2）更新订单状态，状态变为：已取消 

（3）释放锁定库存，无论是哪种情况，进行了订单的取消之后，就需要将订单对应的之前的库存进行释放。订单中心需要去通知库存中心，让库存中心释放库存。 

订单中心发送一条消息到内存队列中去，然后由这个库存中心去消费，消费到之后去异步的执行锁定库存的释放即可 

（4）新增一条订单操作日志，类型：自动取消订单

4.5 支付订单

（1）完成支付本身的事情，用户需要支付订单金额到我们的账号里去。先显示出来第三方支付的页面（二维码），完成支付操作，支付中心会去记录支付交易流水

（2）更新订单的状态：待发货

（3）更新订单中的商品相关的库存：通知库存中心，更新商品的库存 

订单中心发送一条消息到内存队列，库存中心消费之后，异步去完成库存相关的更新操作。 

（4）接着将订单同步到调度中心，由调度中心去调度订单中的商品的发货。 

这块必须是得做成异步的操作，订单中心也是发送一条消息到内存队列，调度中心来消费这条消息，然后调度中心自己后台完成调度发货的逻辑 

三种设计模式结合起来：中介者模式+观察者模式+备忘录模式 

（5）将订单支付金额*10%，累加到会员的成长值以及积分，同步调用会员中心的接口

（6）新增一条订单操作日志，类型：支付订单

4.6 更新订单状态

4.6.1 订单完成发货

WMS系统那边，确认订单完成发货之后，就会发送通知过来，通知订单中心： 

（1）将订单状态修改为：待收货

（2）新增一条订单操作日志，类型：商品发货。

4.6.2 退货工单审核不通过

如果退货工单审核不太通过的话，会通知订单中心：

（1）将订单状态变为：交易关闭（退货审核不通过）

（2）新增一条订单操作日志，类型：退货审核不通过

（3）更新订单退货记录的状态：审核不通过。

4.6.3 退货工单审核通过

如果退货工单审核通过了，那么会通知订单中心： 

（1）将退货记录的状态变为：待寄送退货商品

（2）在退货记录中更新对应的退货收货人，退货收货地址，退货收货人的联系方式

（3）新增一条订单操作日志：退货审核通过

（4）将订单状态更新为：交易中（待寄送退货商品）

4.6.4 确认收到退货商品

客服中心的客服收到退货商品之后，会做一个初步的检查，如果确认ok，会点击确认收到退货商品，此时会通知订单中心： 

（1）将退货记录的状态更新为：退货待入库

（2）新增一条订单操作日志：确认收到退货

（3）将订单的状态更新为：售后中（退货待入库）

4.6.5 退货入库单审核通过

wms中心完成退货入库，同时退货入库单审核通过之后： 

（1）需要将订单的状态修改为：售后中（退货已入库）

（2）新增一条订单操作日志，类型：退货已入库。

（3）将订单退货记录的状态更新为：退货已入库

4.6.6 财务中心完成退货打款

财务中心在接收到wms中心的退货入库的通知，同时完成退货打款之后，会来通知订单中心： 

（1）将退货记录的状态更新为：完成退款

（2）新增一条订单操作日志：完成退款

（3）将订单的状态更新为：交易关闭（完成退款）

4.7 查看物流进度

订单中心去调用物流中心提供的接口，然后返回和显示物流的进度即可

4.8 确认收货

4.8.1 手动确认收货

用户收到货之后，拆包满意，那么可以在订单列表中自己手动点击确认收货，此时：

（1）就会将订单的状态改变为：已完成。

（2）新增一条订单操作日志，类型：手动确认收货。

4.8.2 自动确认收货

系统对处于待收货状态的订单，会自动定期检查每个待收货订单是否签收，如果第三方物流商的反馈状态是已经签收了，然后超过7天用户没点击确认收货，系统自动确认收货。

（1）订单状态变为：已完成。

（2）新增一条订单操作日志，类型：自动确认收货。

4.9 申请退货

4.9.1 执行申请退货

在订单列表页面，如果是处于已完成状态的订单，可以点击申请退货的按钮。然后会进入一个界面： 

（1）要求你选择退货原因

（2）输入退货的备注

（3）后台新增一条订单退货记录，状态为：待审核

（4）订单状态变为：售后中（退货申请待审核）

（5）通知客服中心创建一个售后工单

（6）新增一条订单操作日志，类型：申请退货

4.9.2 查看退货进度

用户肯定时不时过来看看的，此时如果状态为售后中，可以点击状态进入一个页面，在页面里，会显示：

（1）当时用户选择的那个退货原因，以及填写的退货备注

（2）同时给出一个审批结果

（3）如果是审批通过的状态，此时会显示出来需要用户将商品寄送到公司的某个地址（地址、收件人、联系方式）

4.9.3 填写退货物流单号

用户在寄出之后，需要在这个页面里填写对应的物流单号 

（1）在退货记录中保存快递单号

（2）将快递单号同步到客服中心的退货工单中

（3）将退货记录的状态修改为：退货商品待收货

（4）新增一条订单操作日志：已寄送退货商品

（5）将订单的状态更新为：退货商品待收货

4.10 订单价格计算

4.10.1 价格计算说明

这块，主要是在商品进入订单确认页面的时候，根据当前使用的优惠券，或者是促销活动，进行订单最终价格的一个计算

在订单确认页面，需要走一个价格计算的服务，动态的根据当前的促销信息，计算出每个商品实际要支付的价格 

先判断订单里每个商品是否参加了促销，然后看下本地订单中是否满足了促销条件，最后根据促销规则计算出商品的最终价格 

1、订单中心会将整个订单，发到商品中心的价格服务里，让它去完成订单以及其中各个商品的价格的计算 

（1）价格服务，会从促销中心中，将所有的促销活动的数据查询过来，然后进行统一的计算 

4.10.2 促销活动和赠品处理 

满减促销：满100减10、满300减50、满500减80

满赠促销：满300元送自拍杆，满500送充电宝，满1000送高端耳机 

单品促销：促销期间商品售价直接打折，比如6折

套装促销：A商品50元，B商品80元，一起购买只要120元，便宜10元

多买优惠促销：买2件9折，买3件8折，买4件7折

赠品促销：购买某个商品可以赠送别的商品 

一共买了3个商品：A商品是100元，B商品是300元，C商品是250元，650元 

如果某个商品选择了单品促销 

直接对这个商品的价格进行折扣，打指定的一个折扣，比如说某个商品，B商品，8折，240元 

A商品是100元，B商品是240元，C商品是250元，590元 

如果某个商品选择了套装促销 

此时需要对订单中结成套装的商品，看一下，如果组成了一个套装的话，此时可以给一个总的优惠价格，A + B = 300元，比如A原来是100，B原来是240，套装是300 => 优惠分摊，40块钱，按照比例分摊优惠，扣减金额。100 - 100 / 440 * 40 = 90.91，A商品；340 - 340 / 400 * 40 = 309.09，B商品 

如果某个商品选择的是多买优惠促销 

会看一下，这个商品一共购买了多少件，如果达到了指定的件数，说可以打折，看一下具体按照规则，可以打几折 

这个时候，每个商品的价格都降低了，有上面3种促销活动的商品价格，都降低了 

满减促销，看一下选择满减促销的某个商品，这个商品的金额是否达到了一个满X元的条件，如果达到了，就对商品的价格减去Y元。比如C商品是180元，选择了满300件50的活动，C商品一共购买了2件，360元 - 50元 = 310元。 

假设这个时候，A商品是90.91，B商品是309.09，C商品是180，加起来的总和 = 580元 

满500减80，580 - 80 = 500元，省了80元钱，按照比例分摊 

到此为止。。。。价格就算完了，总的优惠价，每个商品的优惠分摊价格，都出来了 

（3）赠品的处理 

然后就是处理促销 

看一下，如果有某个商品选择的是买赠，此时会在订单中加入一个商品，只不过金额是0元，很多电商，多出来一个商品，只不过金额是0元 

满赠，满多少元赠一个赠品，看一下此时单个商品的金额，如果达到一定的金额，可以赠送商品，在订单里再加入对应的赠品。比如说某个商品是100元，选择的是满180赠一个小耳机的活动，买了2件，200元，就给赠送一个商品。 

4.10.3 优惠券计算 

如果这个用户有一个有效的优惠券，在订单确认页面下面可以显示一个优惠券下拉框，你可以选择这个订单要使用一个优惠券 

进来会直接去计算，在计算完促销活动的基础之上，会自动给你去应用那个券，折上折。现金券，直接抵扣；满减券，看整个订单满多少元，给减多少元。 

还有一个，在购物车每个商品的下拉框中，单品折扣优惠券，跟其他的那些促销活动互斥，只能选择一种 

5、测试用例

6、日志设计

##### 11_电商系统v1.0版本物流中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

到了后面工程初始化的时候，我会给大家演示的，如果在开发过程中需要调节或者是新增这个接口，应该怎么弄。 

刚开始拉分支的时候，单独拉一个common-api的分支出来，就是包含所有的公共接口和api的。然后如果互相之间调用的接口要修改或者是新增接口库，那么可以在common-api分支里面调整接口，然后将common-api分支合并到每个人的feature分支上即可。

2.1 运费计算

LogisticsFacadeServcie 

Double calculateFreight(OrderGoodsSkuDTO OrdergoodsSkuDTO)

3、开发架构

3.1 实现类图

设计模式这块，必须使用策略模式来开发运费计算这块；用代理模式，来代理远程的第三方物流接口

3.2 包设计

4、运行流程

4.1 运费模板管理

4.1.1 查询运费模板列表

支持筛选条件，可以分页查询

4.1.2 新增运费模板

在列表页的上面，有一个新增按钮，点击之后进入一个界面。 

这个界面里，可以输入运费模板名称，然后选择运费模板类型，这里会根据选择不同的类型，下面给你显示出来不一样的操作UI组件。 

比如说，如果选择了固定运费：让你设置一个固定运费是多少元，固定运费20元。 

{“fixed_freigt”: 20} 

比如说，选择了满X元包邮：让你设置一个满多少元可以包邮，没达到这么多钱的话，固定运费就是多少钱。 

{“threshold”: 100, “less_than_threshold”: 10} 

比如说，选择了自定义规则之后：就是下面会出来多个UI组件，你可以加多个规则，每个规则：加一个规则，选择发货到哪些哪些省份，多少重量以内是多少钱；每增加多少g，增加多少钱。 

[

{

“provinces”: “山西,陕西,甘肃,辽宁,黑龙江,吉林”,

“threshold”: “100g”,

“threshold_freight”: 10,

“incr_step”: “2g”,

“incr_freight”: 2

},

{

“provinces”: “云南,广西,湖南,江西”,

“threshold”: “100g”,

“threshold_freight”: 5,

“incr_step”: “1g”,

“incr_freight”: 1

}

] 

输入一个备注

4.1.3 根据ID查询运费模板

根据ID将运费模板的数据查询出来在界面上回显即可

4.1.4 编辑运费模板

可以调整和修改运费模板的名称、类型、规则、备注，就ok了

4.2 运费计算

准备提交订单的确认页面上，就会根据每个商品的运费模板，计算出来每个商品对应的一个运费 

订单中心会将订单的数据传送过来，然后这里会根据每个商品绑定的运费模板，计算出来每个商品对应的一个运费。包括一个订单的总运费。 

如果是自定义规则这种比较复杂的形式，那么在用户选择了商品数量和目的地之后，就可以参照目的地的计算规则，然后算出来重量，根据重量就可以算出来对应的运费 

运费的计算公式=首重费用+（实际邮寄重量-首重）/续重*续重费用。以江浙沪皖同省跨市件为例，首重1kg，首重费用为10元，在50kg内，每增加1kg，则需要增加2元的运费。那么快递3.5kg的物品的运费=10+（3.5-1）/1*2=16（运费需要向上取整，3.5Kg按4kg计算) 

接收到一个请求之后，一个商品+运费模板ID，我们就可以获取到这个商品购买了几件，商品的单价是多少，这个商品的总价是多少，这个商品的单个毛重是多少，商品总毛重是多少。根据运费模板的规则，就可以将运费给计算出来。

4.3 获取物流单

在调度中心调度销售出库的时候，会针对这个订单中的商品，去跟第三方物流厂商的接口进行通信，告诉第三方物流厂商，我们要从哪个仓库里，发送哪些商品，每个商品的重量，长宽高的一些数据，下一个订单，让物流厂商自己去我们的仓库里，取货；或者是，我们是告诉物流厂商，下这么一个物流的订单，然后在仓库里，拣货打包之后，将物流单贴在包裹上，接着将贴了物流单的包裹交给仓库里跟物流厂商的对接人员，物流厂商的人就根据这个物流单号的信息，去进行发货了。 

后面实际开发的时候再说，选用一个快递api的免费接口，带着大家来下电子面单就可以了

4.4 物流追踪

在物流发货之后，会自动将订单锁定一个物流单号，然后之后就是查看物流进度的时候，就会调用物流公司的接口，进行物流状态的查询 

用快递api的免费接口，可以查询物流单号对应的快递的进度

5、测试用例

6、日志设计

##### 12_电商系统v1.0版本评论中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

3、开发架构

3.1 实现类图

3.2 包设计

4、运行流程

4.1 发表评论

4.1.1 手动发表评论

在订单列表页，对已经完成的订单，可以点击按钮，发表评论，此时会进入发表评论的这么一个界面中 

（1）打分：几颗五角星，一般会对多个维度去打分，商品，客服，物流，我们合并为一个打分

（2）输入评论内容

（3）晒图：支持上传图片

（4）打标签：用已有的评论标签，也可以自己新建一个标签

（5）发表一个评论，会员成长值加5分，积分加5分；如果晒图了，成长值再加5分，积分加5分

4.1.2 自动发表评论

如果一个订单确认收货后超过30天没有发表评论，则系统自动打一个好评，总评和所有的维度都是5颗星，评论内容就是默认写非常不错的商品，晒图是无，标签是自动打上好评的内置标签

4.2 评论管理

4.2.1 评论列表

专门有运营人员，会负责对不断发表的那些新的评论，进行审核，看一下文字、图片有没有违法，有没有涉黄的 

评论列表包含哪些字段：用户名、评论时间、分数、评论内容前多少个文字的截取、打的标签、状态（待审核、审核不通过、已审核、已删除）、好评/中评/差评（4星以上是好评，3星是中评，3星以下是差评）、是否晒图、是否追评、是否默认评价 

支持分页查询 

支持筛选条件：用户名、评论时间范围去查、分数、状态、评价类型、是否晒图、是否默认评价

4.2.2 评论详情

对某一条评论可以点击查看详情，进入一个界面，里面可以看到评论完整的数据

4.2.3 审核评论

先校验一下，只有待审核状态的评论，可以执行审核的操作 

然后可以对评论进行审核，点击一个审核按钮，可以进入一个审核界面，显示评论所有的数据，点击审核通过/审核不通过 

如果审核评论不通过，那么评论对应的成长值和积分会扣减掉 

如果审核通过：评论状态变为已审核；会员成长值加5分，积分加5分；如果晒图了，成长值再加5分，积分加5分 

如果审核不通过，评论状态变为审核不通过 

维护评论汇总数据

4.2.4 删除评论

待审核/已审核/审核不通过，三种类型的评论，都可以执行删除评论的操作 

如果后续发现有评论不太合理，可以将这个评论删除，点击一个删除按钮之后，将状态变为：已删除就可以了 

维护评论汇总数据s

4.3 评论前台列表

审核通过的评论，会在商品详情页的评论列表中显示出来 

根据goods_id，将一个spu的所有的评论都查询出来 

（1）好评率

（2）热门标签的评价数量s

（3）评论总数、晒图评论数、追评评论数、好评评论数、中评评论数、差评评论数

（4）评论列表：用户名（保留收尾两个字符，中间的是星号），分数，评论内容，晒图，购买的sku的销售属性值，评论时间

（5）评论支持分页，按照标签来筛选，按照晒图/追评/好评/中评/差评来筛选

5、测试用例设计

6、日志设计

##### 13_电商系统v1.0版本促销中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 查询商品的促销活动

PromotionFacadeService 

List<PromotionActivityDTO> listPromotionActivitiesByGoodsId(Long goodsId)

2.2 查询用户领取的优惠券

订单确认页面中，会ajax异步加载用户领取的有效的还未使用的优惠券列表 

这个是走controller接口

3、开发架构

3.1 实现类图

3.2 包设计

4、运行流程

4.1 促销活动

4.1.1 促销活动列表

促销活动的数据包含了哪些字段： 

（1）ID

（2）促销活动名称

（3）促销开始时间

（4）促销结束时间

（5）针对会员级别

（6）活动备注

（7）创建时间

（8）创建人

（9）状态：待审核、已审核，不是手动控制的，是根据你制定的一个促销开始时间和促销结束时间，自动启用/停用，促销开始时间到了就启用，促销结束时间到了就停用

（10）促销规则 

列表显示的字段包含了：ID、促销活动名称、促销开始时间、促销结束时间、针对会员级别、创建时间、创建人、状态 

支持分页查询 

支持筛选条件：促销活动名称，促销开始时间，促销结束时间，状态（默认是启用，可选全部/停用） 

4.1.2 新建促销活动 

那些促销活动实际上大同小异，主要是分为活动基本信息、促销规则、主商品信息、赠品信息 

（1）活动基本信息 

促销活动名称、促销开始时间、促销结束时间、会员级别（全员/某等级会员）、活动备注 

（2）促销规则 

活动规则，选择6种活动里面的某一种，先通过下拉框进行选择，然后根据选择的活动规则，输入具体的活动规则明细 

满减促销，那么就要输入一系列的细则，满多少减多少 

[

{

“threshold_amount”: 300,

“reduce_amount”: 100

},

{

“threshold_amount”: 200,

“reduce_amount”: 50

}

] 

多买优惠，输入一系列的细则，就是买几件打几折 

[

{

“threshold_count”: 2,

“discount_rate”: 0.9

},

{

“threshold_count”: 3,

“discount_rate”: 0.8s

}

] 

单品促销，输入一个折扣 

{

“discount_rate”: 0.7

} 

套装促销，输入一个折扣 

{

“discount_rate”: 0.6

} 

赠品促销 

{

“gift_goods_sku_ids”: [2, 340, 590]

} 

满赠促销，要输入满多少元赠送一些赠品 

{

“threshold_amount”: 550,

“gift_goods_sku_ids”: [2, 340, 590]

} 

（2）主商品信息 

根据sku编码、商品名称、商品状态、价格范围、商品分类、上架时间，等几个条件，来进行商品的筛选。筛选出来的商品列表的字段包括：SKU编码、商品名称、价格、优惠内容。 

满减促销：不要选择商品了，默认就只能范围是全部商品，就是说无论买什么商品，满多少钱就可以立减多少钱，选择一个或者是多个品，就是代表着针对这些商品有这个优惠；也可以选择全部商品 

单品促销：就是要选择一个或者多个商品，也可以选择全部商品，直接会关联上面的那个折扣的 

套装促销：要求选择超过1个商品，多个商品，不可以选择全部商品的，最多选择10个以内的商品。如果同时一个订单中出现这多个商品的话，那么就会对这些商品走上面的一个折扣价格 

赠品促销：只能选择一个商品或者多个商品，也可以选择全部商品，买这个商品的时候，每个商品都会给一份赠品，赠品在下面设置 

满赠促销：默认就是不要选择商品，强制是全部范围的商品，可以选择一个或者多个商品，也可以选择全部商品，就是针对这个商品买满多少钱就赠送一个赠品 

多买优惠：可以选择一个或者多个商品，也可以选择全部商品，这个商品买满几件打几折 

我说一点，大家看到这里，不知道能不能理解我为什么不愿意去画原型图，原型图太复杂了，不能的情况下，前端界面是各种变化的 

刚开始新建完的时候，促销活动的状态根据开始时间来判断一下，如果开始时间是早于当前时间，那么促销活动就直接启用；如果开始时间是晚于当前时间，那么促销活动就处于停用状态 

（3）赠品信息 

选择赠品其实也是选择商品，跟上面是一样的 

赠品促销，可以挂一个或者多个赠品，赠品最多挂10个

满赠促销，也可以挂一个或者多个赠品，赠品最多挂10个 

刚新建完一个促销活动，待审核；只有待审核、停用的状态，可以进行编辑，编辑完了以后还是待审核

4.1.3 根据ID查询促销活动

根据ID将促销活动的数据查询出来在页面上回显即可

4.1.4 编辑促销活动

对促销活动的数据进行编辑即可 

4.1.5 审核促销活动

对每个促销活动都可以进行审核，在促销活动列表页的右侧操作栏中，有一个审核按钮，如果是待审核状态，可以点击审核按钮。进入一个审核页面，此时会显示促销活动完整的一个信息。然后执行审核，通过/不通过。如果通过审核，就变成已审核。 

4.1.6 删除促销活动

只有处于停用状态的促销活动可以删除。

4.1.7 促销活动的启用/停用

新建一个促销活动之后，到时间就会自动启用这个活动，需要有一个程序在后台去监控每个促销活动的开始和截止的时间，看到到了开始时间，就开始自动将那些促销活动的状态修改为启用即可，监控所有促销活动的截止时间，到时间之后，就自动将促销活动的状态修改为停用。

4.1.8 促销活动的前台展示

（1）在商品详情页，需要展示出来促销活动

（2）在购物车页面，也需要同时展示商品的促销活动，要求你手动去选择一个促销活动，每个商品支持可以挂多个促销活动的。此时需要我们手动去下拉列表中选择 

一般来说，都是对一个spu去设置这个对应的促销活动的

4.2 优惠券

很多种优惠券：现金券（无限制直接用）、满减券、折扣券（购买指定商品时打折），实际上是在提交订单的确认页面里，针对整个订单去使用的，不是针对某个商品的

4.2.1 优惠券列表

（1）优惠券数据 

优惠券信息：优惠券名称、类型（现金券、满减券）、使用条件规则（多少钱的现金券、满减券有一系列细则）、有效时间（范围，开始~结束）、发行量、商品范围 

推广信息：发放方式（可发放可领取、仅可发放、仅可领取），推广范围（免费领取、积分兑换），限领数量，会员等级 

状态：发放中、发放完、过期 

（1）列表页显示的字段 

优惠券名称、类型、有效时间、发行量、发放方式、推广范围、限领数量、创建时间、状态 

支持分页查询 

支持条件筛选：优惠券名称、类型、有效时间、发放方式、状态、推广范围

4.2.2 优惠券新建/编辑

新建/编辑，其实就是显示一个表单出来，可以对优惠券所有的数据进行输入和编辑

4.2.3 删除优惠券

优惠券的删除，不好随意删除的，你要是删除了以后，就得把发出去的所有的券都给删除了，这个会很麻烦

4.2.4 用户领取优惠券

就是在一个领券页面里，可以点击按钮来领取，这里系统需要记录好，当前领了多少张券了，券给了谁。根据发券的数量，维护券的状态。 

领取的时候，需要做一些校验：优惠券是否处于有效期内；优惠券的状态：发放中；优惠券的领取方式是否支持用户来领取 

领券的逻辑： 

（1）插入一条用户领取这个优惠券的记录

（2）对优惠券表中的已经领取的数量，给增加1

（3）维护优惠券的状态，如果券已经领完了，那么就将状态设置成：发放完

14.3.5 平台发放优惠券 

那就是平台直接发放给所有用户了，在优惠券的列表页的右侧，有一个按钮，就是发放优惠券。随机性发放，根据优惠券有多杀张，随机选择指定的用户来一人一张来发放 

这个版本，默认就是给每个用户都发放一张优惠券，这个模式下，不care优惠券的发行数量了，就是给每个用户都强行推送一张优惠券就可以了 

发券的逻辑： 

（1）给每个用户都插入一个优惠券的领取记录，就很麻烦，而且如果你的用户数量有上百万呢？插入上百万条记录

（2）就是在用户领取券的记录表中插入一条记录，user_account_id设置成-1就可以了，就代表着这个优惠券所有的用户都可以使用

（3）将优惠券表中的领取的数量设置成跟发行量是一样的

优惠券的状态变为：发放完

5、测试用例设计

6、日志设计

##### 14_电商系统v1.0版本客服中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 创建退货工单

CustomerFacadeService 

中心与中心之间的交互，尽量尽量就是提供一个接口类，里面可以提供各种各样，五花八门，几百种，上千种的接口。但是接口类尽量就是一个。否则的话，如果我要调用你的客服中心的接口，我还要记住多达几十个客服中心的接口类，很麻烦。 

Boolean createReturnGoodsWorksheet(Long orderId, String orderNo, 

String returnGoodsReason, String returnGoodsComment)

2.2 同步退货物流单号

CustomerFacadeService 

Boolean syncReturnGoodsCourierNumber(Long orderId, String returnGoodsCourierNumber)

2.3 完成退货入库

CustomerFacadeService 

Boolean finishReturnGoodsWarehouseEntry(Long returnGoodsWorksheetId)

2.4 完成退货打款

CustomerFacadeService 

Boolean finishReturnGoodsRefund(Long returnGoodsWorkwheetId)

3、开发架构

3.1 实现类图

要用到状态模式，因为退货工单也是有比较复杂的状态要流转的

3.2 包设计

4、运行流程

4.1 退货工单管理
这块主要是在用户进行售后的时候，比如说退货，或者是退款，要走售后工单模块

4.1.1 创建退货工单

一般来说，如果做到纯粹的前后端分离之后，这边一般是从订单列表页，申请退货，此时会直接跳转到另外一个客服中心的发起退货申请的页面上去，此时页面上会带着需要订单的数据，比如订单ID和订单编号 

发起退货申请，应该是走的订单中心的退货的申请界面，用户填写完之后，应该是在订单中心里先创建一个退货的记录，然后订单中心跟客服中心来通信，让客服中心来创建一个退货工单。 

用户对已经收到货的商品不太满意，申请退货，此时订单中心会通知客服中心，发起一个售后工单。这个售后工单包含了哪些数据呢？ 

（1）ID

（2）订单编号

（3）创建时间

（4）状态

（5）审核人

（6）审核时间

（7）退货原因

（8）退货备注

（9）退货物流单号 

刚开始创建这个售后工单的时候，应该是状态是：待审核 

在创建售后工单的时候，不采取随机分配给客服的方式。就是创建出来一个售后工单，要求的是每个售后客服人员，自己关注一下出来的售后工单，如果看到一单，那么就去处理一单。一开始就做的简单一些。内测，跑通流程，还不需要那么复杂的一些东西。 

4.1.2 退货工单列表 

包含的数据有哪些？跟订单的数据是差不多的。具体包含了一个订单中要退货的一些商品的列表。直接就参照订单列表即可： 

（1）下单时间、订单编号

（2）订单中的商品列表：缩略图、商品名称、购买数量

（3）收货人、总金额、应付金额、支付方式

（4）订单状态

（5）退货物流单号

（6）退货工单状态

（7）退货原因 

筛选条件：可以支持根据退后物流单号、退货工单状态、退货原因去进行筛选 

支持分页查询

4.1.3 退货工单详情

不是进入订单详情，而是有一个按钮，可以点击后进入退货工单详情页：这个详情页里面，就包含订单所有的详情页数据，同时包含退货工单自己的所有数据，尤其是包括了退货的原因

但是给每个退货工单，加入一些额外的字段：退货工单创建时间、退货工单状态、审核人、审核时间。 

4.1.4 审核退货工单

在退货工单列表页的右侧操作栏中，有一个审核的按钮，只有退货工单的状态是待审核的时候，才可以点击这个按钮。点击这个按钮之后，也会进入退货工单的详情页面，但是可以进行审核操作，选择通过/不通过。 

如果审核不通过： 

（1）退货工单的状态为：审核不通过

（2）需要通知订单中心，直接将订单的状态设置为交易关闭（退货审核不通过）。 

如果审核通过： 

（1）此时同样需要将退货工单的状态设置为：待寄送退货商品

（2）通知订单中心，将订单的状态设置为：售后中（待寄送退货商品）

4.1.5 同步退货物流单号

（1）将退货物流单号保存到退货工单中去

（2）将退货工单的状态设置为：退货商品待收货

4.1.6 确认收到退货

（1）收到货之后，根据包裹上的物流单号去查询退货工单，进行一个比对，如果是那个物流单号，那就是收到了退的货品

（2）同时需要拆包，对货品进行一个初步的质量检查、是否足够的数量检查

（3）走线下物流，将商品退还到之前的发货的仓库中去，默认就一个仓库，所以无所谓了，就直接寄回仅有的一个仓库即可

（4）在退货工单列表页的右侧操作栏中，此时如果退货工单的状态是待收货，会显示一个按钮，可以在这里点击确认收货的按钮，此时就会将退货工单的状态修改为：退货待入库

（5）通知订单中心去更新订单的状态为：退货待入库

（5）将售后工单同步到调度中心里面去，由调度中心去执行一个退货入库的调度操作

4.1.7 更新退货工单状态

1、退货入库单完成审核 

如果退货入库单完成审核之后，就会通知客服中心： 

（1）将退货工单的状态修改为：退货已入库

（2）同时客服中心需要通知订单中心，将订单的状态也修改为：售后中（退货已入库）。 

2、完成退货打款 

wms中心会去通知财务中心进行退货打款，完成打款之后，财务中心会通知客服中心已经完成退货打款 

（1）将退货工单的状态设置为：完成退款

（2）通知订单中心，将订单的状态设置为：交易关闭（完成退款）

5、测试用例设计

6、日志设计

##### 15_电商系统v1.0版本财务中心详细设计文档

 1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 创建采购结算单

FinanceFacadeService 

Boolean createPurchaseSettlementOrder(

PurchaseWarehouseEntryOrderDTO purchaseWarehouseEntryOrderDTO)

2.2 进行物流公司打款

FinanceFacadeService 

Boolean payForLogisticsCompany(SaleDeliveryOrderDTO saleDeliveryOrderDTO)

2.3 退货打款

FinanceFacadeService 

Boolean executeReturnGoodsRefund(ReturnGoodsWarehouseEntryOrderDTO 

returnGoodsWarehouseEntryOrderDTO )

3、开发架构

3.1 实现类图

要用到状态模式，因为退货工单也是有比较复杂的状态要流转的

3.2 包设计

4、运行流程

4.1 采购结算单管理

4.1.1 创建采购结算单

接收WMS系统的通知，将采购结算的数据进行保存，此时状态为编辑中

4.1.2 采购结算单列表

菜单：财务中心-采购结算单管理 

显示哪些字段？跟采购入库单列表保持一致就可以了，状态那里，显示采购结算单自己的状态就可以了。采购入库单的3个核心数据，都是需要的，总的交货时间，每个商品的良品率和交货数量。 

额外加一个字段，计算出来一个这个采购结算单要支付的总金额（自动根据每个商品的采购价格，以及实际到货的数量，自动推算出来）。 

支持分页，支持筛选 

创建时间、操作人、最近一次操作时间、审核人、审核时间

4.1.3 编辑采购结算单

在列表页的右侧操作栏，有一个编辑按钮，只有对编辑中状态的单子才可以进行编辑。此时可以对采购结算单进行编辑，唯一能编辑的一个字段，就是采购结算单待支付的总金额。

4.1.4 提交审核

在列表页的右侧操作栏中，有一个提交审核按钮，只有对编辑中状态的单子才可以进行提交审核。此时点击之后，将单子的状态修改为待审核。 

同时，需要通知WMS系统将这个采购入库单的状态修改为待结算 

4.1.5 审核采购结算单

在列表页的右侧操作栏中，有一个审核按钮，只有带审核状态的采购结算单可以点击这个按钮。点击过后，进入一个审核页面，此时会显示这个采购结算单所有的数据，然后负责审核的人，可以完成审核，执行通过/不通过两个选项即可。 

如果说通过了以后 

（1）采购结算单的状态变为已完成

（2）通知WMS系统，将采购入库单的状态变为已完成

4.2 供应商结算管理

4.2.1 周期性打款结算

这块的话，主要是对于采购时，与供应商之间的结算提供财务管理功能 

根据供应商的结算周期，周期性的统一对所有供应商进行结算和打款，每周/周月/每季度，都要定时触发打款的逻辑，每次触发，要去看看哪些供应商是这个结算周期的，对这个周期内的供应商的财务结算单，去执行打款操作 

（1）走银行的接口，去进行财务打款

（2）需要记录下来每次财务结算打款的一个记录和流水，包含：供应商的基本信息，供应商的结算信息，打款具体时间，打款的总金额。还应该将这个流水跟本次打款对应的多个采购结算单关联起来。

4.2.2 采购结算流水管理

菜单：财务中心-供应商结算-采购结算流水 

这里就可以看到每条流水完整的一个记录，包含了供应商的基本信息，供应商的结算信息，打款时间，打款金额。点击右侧操作栏的一个按钮，查看采购结算单，可以进入一个列表页面，包含了这次打款关联的一些采购结算单（列表如何显示，跟采购结算单列表一样的），可以点击查看每个采购结算单的详细信息。

4.3 物流公司打款管理

（1）每次审核完一个销售出库单之后，WMS系统就会通知财务中心打款

（2）系统直接基于银行的接口，完成两个账户之间的打款，根据这个订单中的运费来打款即可

（3）每次给物流公司打款，都会记录一条交易流水：订单编号、打款的总金额、哪个物流公司、哪个银行账号、打款的时间。

4.4 退货打款管理

如果退货入库审核通过之后，就会通知财务中心： 

（1）将订单对应的付款退还到用户的账户中

（2）新增一条退货打款的流水

5、测试用例设计

6、日志设计

##### 16_电商系统v1.0版本库存中心详细设计文档

 1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 采购入库

InventoryFacadeService 

Boolean finishPurchaseWarehouseEntry(PurchaseWarehouseEntryOrderDTO

purchaseWarehouseEntryOrderDTO)

2.2 提交订单

InventoryFacadeService 

Boolean submitOrder(OrderDTO orderDTO)

2.3 支付订单

InventoryFacadeService 

Boolean payOrder(OrderDTO orderDTO)

2.4 取消订单

InventoryFacadeService 

Boolean cancelOrder(OrderDTO orderDTO) 

2.5 退货入库

InventoryFacadeService 

Boolean finishReturnGoodsWarehouseEntry(ReturnGoodsWarehouseEntryOrderDTO

returnGoodsWarehouseEntryOrderDTO)

2.6 查询商品库存

（1） 商品详情页中需要显示商品库存，选择好sku的销售属性之后，ajax异步来加载controller中的接口

（2） 购物车中，在显示购物车数据的时候，购物车的后台，会去调用商品中心获取sku数据，也会调用库存中心来查找这个sku的库存数据 

InventoryFacadeService 

Long getSaleStockQuantity(Long goodsSkuId)

3、开发架构

3.1 实现类图   

命令模式，工厂模式，模板方法模式

3.2 包设计

4、运行流程

4.1 库存管理

4.1.1 采购入库

库存中心，是不care仓库和货位层面的东西，一旦有采购入库之后 

将某个商品的销售库存累加上对应的值 

如果这个商品之前的所属仓库是无，同时销售库存是0，库存状态是无库存，那么此时加入新库存之后，除了更新销售库存，同时会更新一下商品的所属仓库，还会去更新库存状态为有库存

4.1.2 提交订单

用户提交订单之后，订单中心会来通知库存中心，将商品的可销售库存扣减1，同时将商品的锁定库存加1。接着库存中心，需要去通知调度中心，去更新这个库存。

4.1.3 支付订单

用户支付了订单之后，订单中心会来通知库存中心，将商品的锁定库存减1，将商品的已销售库存加1。接着库存中心需要通知这个调度中心，将调度中心的库存也进行更新操作。

4.1.4 取消订单

将商品的锁定库存减1，将商品的可销售库存加1。接着通知调度中心更新库存。

4.1.5 退货入库

商品的可销售库存加1，已销售库存减1 

5、测试用例设计

6、日志设计

##### 17_电商系统v1.0版本调度中心详细设计文档

1、数据架构

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口

2.1 完成采购入库

ScheduleFacadeService 

Boolean finishPurchaseWarehouseEntry(PurchaseWarehouseEntryOrderDTO

purchaseWarehouseEntryOrderDTO)

2.2 提交订单

ScheduleFacadeService 

Boolean submitOrder(OrderDTO orderDTO)

2.3 支付订单

ScheduleFacadeService 

Boolean payOrder(OrderDTO orderDTO)

2.4 取消订单

ScheduleFacadeService 

Boolean cancelOrder(OrderDTO orderDTO) 

2.5 完成退货入库

ScheduleFacadeService 

Boolean finishReturnGoodsWarehouseEntry(ReturnGoodsWarehouseEntryOrderDTO

returnGoodsWarehouseEntryOrderDTO)

2.6 调度采购入库

采购中心的采购单通过审核之后，会来调用这个接口，调度采购入库 

ScheduleFacadeService 

Boolean schedulePurchaseInput(PurchaseOrderDTO purchaseOrderDTO)

2.7 调度销售出库

订单中心的订单完成支付之后，订单中心会来调用这个接口，调度销售出库 

ScheduleFacadeService 

Boolean scheduleSaleOutput(OrderDTO orderDTO)

2.8 调度退货入库

ScheduleFacadeService 

Boolean scheduleReturnGoodsInput(OrderDTO orderDTO, 

ReturnGoodsWorksheetDTO returnGoodsWorksheetDTO)

3、开发架构

3.1 实现类图   

命令模式，工厂模式，模板方法模式

3.2 包设计

4、运行流程

4.1 调度采购入库

接收一个采购单，然后根据这个采购单中的数据，创建一个采购入库单。此时大家可以想象一下，这个采购入库单的数据，首先是需要保留采购单中所有的数据。此时这些数据是不够的。 

三个数据：采购入库单里，要保留3个数据，交货时间、良品率、到货比例，比如说iphone8 plus 银灰色 64G，sku，采购的是100件，结果发过来了99件，此时到货比例就是99%。 

采购入库单中，需要根据仓库中的每个货位的剩余容量，然后根据商品的采购件数，将每个商品的采购关联分配到对应的货位上去。这个其实是蛮复杂的。每个货位，看一下承载的体积，每个商品长宽高是多少，根据当前每个货位中有多少件商品，来判断说，剩余的货位体积可以放多少件商品。这套其实很复杂的。

在这里不由调度中心代码去做，直接就是将采购入库单，创建好了之后，同步到WMS系统里面去了。

4.2 调度销售出库

1、业务知识 

（1）调度销售出库的基本概念 

调度中心负责在订单支付之后，对接WMS系统，让WMS系统创建销售出库单，包括其他的出入库单 

电商后台将一个订单，购买哪些商品，收货地址，告诉调度中心；然后调度中心负责根据仓库的信息，选择那些商品分别在哪个仓库里进行调度，用什么物流发货，多久可以到 

有几个核心的信息：每个商品购买了几件，每个商品自己的毛重是多少，一个商品的总毛重是多少，收货地址是哪里 

（2）管理仓库基础数据 

维护仓库信息以及物流公司信息 

仓库信息：仓库名称、地址、联系信息、仓库类型（自营中心仓、自营区域仓）、配送区域 

广州仓库的一级配送区域是广州，二级配送区域是广西、福建、湖南，三级配送区域是其他地方 

每个仓库关联了一些物流公司 

（3）选择发货仓 

根据调度规则，按照一定的调度逻辑，来进行商品发货的调度，找到对应的发货仓 

设计一个较为简化的发货调度的方法 

（1）不同的仓库，对不同的区域，是有发货的分级的，越近的地方，分级是越近的。有些太偏远的地方，是不支持发货的。同一个省份，可能多个仓库都可以发货，但是一定是有一个仓库是优先级最高的，比如说湖南发货，杭州仓库对湖南就是二级区域；但是广州仓库，可能对湖南就是一级区域 

（2）根据收货地址所在省份，优先找一下，自己是一级区域的仓库，是否有库存，优先从这个仓库发货；如果一级区域不行，可以找自己是二级区域的仓库，也可以发货；如果二级区域不行，直接不支持对这个地区发货这个商品了 

（3）调度这个仓库中用来发货的货位，首先按照商品上架的时间顺序排序，按照先进先出的原则，有这个商品的货位，按照时间先进先出排序，最早上架的商品排在最前面，先发货 

（4）比如找到一个货位，上面有5件商品，如果你要购买一件这个商品，那么就从这个货位去发货就可以了；如果你要购买10件这个商品，会将你的商品，拆分成两个发货条目，先从一个货位取5个商品，再从下一个货位取5个商品 

（5）最终将订单中的每个商品，都直接绑定到一个仓库的一个货位上去 

2、创建销售出库单 

销售出库单，包含了订单中的几乎所有的数据，然后还包含了自己对仓库和货位的一个调度，一个商品购买10件，可能会被拆分为两个发货条目，但是每个发货条目，都会将商品关联到一个货位上去。然后同步到WMS系统。 

最重要的还是要包含一个订单中的商品如何发货的信息，这里其实就是要将商品关联到对应的货位上去。 

这里大家思考，不知道大家还记得不记得，我们之前用户提交订单的时候，实际上调度中心，就已经将订单中的商品跟某个货位中的库存进行了绑定了，甚至都提前锁定了那个货位中这个商品的库存了。商品->货位的调度，已经做好了，而且都已经记录下来了。 

此时实际上去创建销售出库单的时候，就是要将之前完成的调度数据，绑定到销售出库单中去，知道从仓库中哪个货位去发哪些商品。 

大概的格式：仓库、货位、商品、多少件。 

3、创建发货单 

发货单，其实放在包裹里面的，告诉用户他买了哪些东西，本次给他发了哪些货。我们可以想象一下，和简化一下。就是平时拿到的这个发货单，基本上可以认为是订单的一个纸质版。 

包含的内容如下： 

（1）收货人信息（收货人、地址、手机号码）、配送信息（配送方式、运费）、付款信息（支付方式、总金额、促销活动抵扣、优惠券抵扣、应付金额）、发票信息（发票类型、发票抬头、发票内容） 

（2）商品列表：缩略图、商品名称、销售属性、商品编号、商品售价、购买数量 

（3）订单总金额、运费、促销活动折扣、优惠券折扣、应付总金额 

4、创建物流单 

跟第三方物流商进行通信，获取一个物流单号。但是这里不是调度中心直接去做这个操作的。调度中心，去跟物流中心进行通信，获取一个物流单。 

5、同步到WMS系统 

接着将创建好的销售出库单、发货单、物流单，一次性同步到WMS系统去。发货单和物流单，其实是作为销售出库单的一个附属，绑定到销售出库单上的。

4.3 调度退货入库

（1）调度退货入库 

其实调度采购入库，对售后工单中包含的这些退货商品，进行一个调度，将这些商品调度放入一个仓库里，需要根据仓库中的每个货位的剩余容量，然后根据商品的退货件数，将每个商品的退货关联分配到对应的货位上去 

（2）创建退货入库单

创建退货入库单，此时退货入库单基本包含了订单所有的数据，同时有自己独有的一些字段：创建时间、操作人、最近一次操作时间、审核人、审核时间、状态 

（3）将退货入库单同步到WMS系统

4.4 调度中心库存管理

4.4.1 采购入库

采购入库之后，WMS系统，会将最新的库存数据发送过来，此时需要更新调度中心本地的仓库中某个商品的可用库存，更新仓库中某个货位某个商品的可用库存。 

同时，调度中心更新完自己本地的库存之后，还会继续去调用库存中心，将库存同步过去 

4.4.2 提交订单

用户提交订单之后，订单中心会通知库存中心更新库存，库存中心会通知调度中心更新库存 

调度中心，仓库中商品的可用库存减1，仓库货位中的商品库存减1，还要将仓库中商品的锁定库存加1，仓库货位中的商品锁定库存加1 

但是这里有一个问题，就是说，调度中心，需要去做一个将本次订单中的每个商品，都需要去调度和关联到某个或者某些货位上去了。 

原则，是先进先出的一个原则，就是说首先来看一下，入库的时候，仓库管理员，一定是尽量将商品放到最近的货位上去的，所以出库的时候，调度中心是可以根据采购入库单中的数据记录，判断出来说，哪些货位有这个商品，然后看一下，这个商品按照上架时间，先进先出的原则，做一个排序。 

这个商品最先上到哪个货架上面去，优先从那个货位上去锁定库存。比如假设A-01-1-03货位，有iphone 8 plus 银灰色 64G，100件。而且这个货位是最早上架这个商品的。其实就可以将这个货位的库存进行扣减和锁定。而且这里要记录下来，这个订单每个商品是对应锁定到哪些货位上的库存的。 

我们要购买的iphone 8 plus 银灰色 64G，5台。就给关联到了A-01-1-03货位了，此时这个货位的这个商品的可用库存就变成了95件，这个货位的这个商品的锁定库存就变成了5件了。 

接着，调度中心，就需要将库存的操作，同步到WMS系统中去，调度这个事情是调度中心去干的，所以直接就通知WMS系统，怎么更新库存即可。

4.4.3 支付订单

用户支付之后，订单中心会通知库存中心更新库存，库存中心会通知调度中心，更新库存。此时需要将之前仓库商品的锁定库存减1，仓库商品的已出库库存加1；将仓库货位商品的锁定库存减1，仓库货位商品的已出库库存加1。急着会去通知WMS系统，更新库存。

4.4.4 取消订单

将仓库商品的锁定库存减1，仓库商品的可用库存加1；将仓库货位商品的锁定库存减1，仓库货位商品的可用库存加1。接着通知WMS系统，更新库存

4.4.5 退货入库

仓库商品的可用库存加1，已出库库存减1；货位商品的可用库存加1，已出库库存减1。继续通知库存中心。 

5、测试用例设计

6、日志设计

##### 18_电商系统v1.0版本详细设计文档技术评审

软件工程的所有的环节和步骤，都是有其对应的意义的，至少我讲的这个流程里是这样的。如果是那些比较老旧，虚头巴脑的一些东西，不好落地的，过于复杂一些东西，现在暂时这个阶段用不着的一些东西，我都没讲。 

概要设计 -> 架构师必备能力，设计出来一套系统长什么样子的，跑起来大概是什么样子的 

概要设计评审 -> 让前天team的架构师来把一下关，尽量避免你犯了什么大错 

详细设计 -> 是你手下的小弟必备的能力，小弟必须得去对自己负责的那个模块或者子系统，完成对应的一个详细设计。 

P7技术专家，架构师的角色，概要设计；P6高工，带1~3人的小团队，负责一个独立子系统的详细设计，也可能是某个子系统的概要设计；P5初中级的工程师，一般就是干活儿的主力，他们负责对某个小型子系统或者是子系统中的一些模块，完成对应的详细设计 

你必须强力push你手下的小弟，把系统设计的非常详细，参照我们的详细设计规范来。详细设计文档，需要详细到什么程度呢？照着文档就可以写代码。 

数据库、缓存、MQ -> 设计好；接口 -> 设计好；实现类图（面向对象设计的功底，设计模式运用的功底）-> 设计好；完成上面3个步骤之后，将每个功能的运行流程都设计出来，写一些文字，复杂的画一些活动图 

当然，如果你的小弟水平很low，可能刚开始还是得你自己来设计详细设计文档，让小弟参照着文档来做。但是你必须得培养小弟可以独立完成一些模块的详细设计。 

详细设计评审 -> 就是你作为架构师，你手下的小弟完成了所有的详细设计之后，你就需要开会，评审会议，你仔细看你每个小弟的设计文档，你需要结合着那个模块对应的业务需求，来仔细反复思考，他们的详细设计有没有什么地方会有问题的 

1、数据库设计 

你要重点看一看数据库里面的索引设计 

我们在这里，因为是讲课，没必要将一些CRUD的一些东西讲的太细，可能耗时太长了，大量的时间可能带着大家在设计CRUD的一些东西 

所以说我这里之前给大家讲过了，就是我们对数据库设计这块，就给出了ER模型，数据库的物理设计，没搞，索引，主键，外键，还没弄。因为现阶段比较简单，所以我们可以到一边开发的时候，一边根据我们写了什么SQL，来现场设计和增加索引。 

但是在实际的项目中，必须要求你的小弟在这一块，在完成了数据库ER模型、接口、实现类、运行流程的设计之后，必须要结合自己要执行的SQL操作，完成数据库的物理索引的设计。

数据库的设计这块，一方面你是看一看表名、字段名的命名，备注，你是否看得懂；数据库ER实体之间的关系是否正确；数据库整个设计，凭自己的感觉去看看，有没有什么问题；看看每个表都建立了哪些索引，让召开评审的同学说一说每个索引的用处。 

2、接口设计 

主要不是架构师看的，同一个团队内部有互相调用关系的几个同学，互相之间要去看看对方的接口设计，能否满足自己的需求。包括，针对前端的接口，需要前端同学过来参加这个评审，让前端看看这个接口能否满足他的需求 

我们之前为了讲课方便，所以对面向前端的接口，都没有设计，主要是面向前端的接口，大多数都是CRUD的一些操作，设计接口，需要耗费大量的精力来编写输入输出对的json格式。很麻烦，很浪费时间。 

但是，在实际的项目中，肯定是要求你手下的小弟，必须将所有的接口都给设计好的。然后让要调用他的接口的同学来评审，看接口是否ok 

3、开发架构 

实现类图，你作为一个架构师，你需要去review你手下的小弟的类设计。 

（1）面向对象的设计 

也就是说，我们现在还都是一些比较简单的CRUD的一些操作，没有太多所谓的面向对象的设计，大多数可能给都是一些controller、service、dao、mapper的设计。 

但是到了我们课程的项目后期，大量的复杂技术架构出来，面向对象的设计，就很重要。 

如果这块没有做良好的面向对象的设计，最后写出来的代码基本上就是一坨屎。面向过程去设计，最后可能一个复杂的模块，就两三个类，每个类里面就几个方法，大量的业务逻辑耦合在了一个方法里面。最后一眼看过去，就是一个方法里面一坨屎。 

面向对象是很重要的，如果你设计的好的话，那么你的代码的结构是很清晰的，代码是面向对象的，比如老鹰类，翅膀类，鸟巢类，天空类 -> 老鹰类组合了翅膀类，基于翅膀类去飞，平时基于鸟巢类去休息，可以飞到天空类里面去 -> 老鹰类里面有十几个方法，飞，休息 

（2）设计模式的运用 

跟面向对象的设计有关系的，很多时候你为了面向对象去设计，让代码有清晰的结构，就可能会用这个设计模式。 

如果我们不用任何的设计模式，看起来就是一个类，这个类里有一堆的方法，每个方法有一堆恶心的逻辑。 

命令模式+模板方法模式+工厂方法模式，在对应的操作过来的时候，我们就是去找对应的工厂创建一个对应的库存更新命令出来，执行这个库存更新的命令，这个库存更新命令会按照模板方法定义的模板，来依次执行多个步骤逻辑 

我觉得很多同学所在的团队，或者是公司，哪怕有这一些流程，执行的也不一定很好。设计，不是写文档，设计就是设计，体现的是你的系统设计的功力，文档只不过记录设计的载体。不要说我在写文档，公司里有规范，我必须得写，硬生生凑一堆没有生气的死板的文档出来，这个文档都不好好写，就是满足公司的规范。 

你绝对是不可能成为一个架构师的，我这次讲解的这些流程，都是架构师必须要掌握的东西。而且大家要理解你做的每件事情背后的意义。 

实现类图的设计，我们之前做了一点简化，就是对于那些CRUD相关的，或者是业务逻辑相关的类，我们都没有去设计对应的类图。这个在实际的应用中，是可以接受的，哪怕是在公司的实际工作环境中，这个是ok的。controller -> service -> dao -> mapper。 

但是我们对那些重要的实现类图，体现出有一定面向对象设计含量的，和设计模式运用含量的相关的东西，我们都给出了实现了类图 

我们通常而言，建议说，对于CRUD，也可以设计类图，只不过是设计简单类图。但凡有一定复杂程度的业务流程和业务场景，建议给出详细的面向对象的设计类图；只要能用设计模式的，就给出设计模式的实现类图。 

4、运行流程 

实现类图和运行流程，是我在详细设计里面，最最最最重视的两块东西 

很多同学之前做详细设计，可能主要就是做数据库设计，接口设计 -> 恰恰相反，我不觉得这两块会有很大的问题，数据库设计和接口设计，重要 -> 这两块一般来说不是系统设计真正出问题的一个重灾区 

哪怕你手下的小弟写的有问题，数据库表设计的一塌糊涂，接口设计的一塌糊涂；一般来说都能给指正出来，让他去修改的 

很多公司，很多团队，尤其是一些中小型公司，创业型公司，流程和规范不完善的公司，他们做详细设计文档，只写数据库设计和接口设计 -> 类设计，运行流程的设计，基本是泛泛而过，或者根本就不做 

实现类图不设计，代码是一坨屎 -> 运行流程不设计，你的小弟的详细设计文档就是对你来说是个黑盒，你根本不知道他要写哪些类，这些类之间的协作和运行流程是什么 -> 可能会导致最后你的小弟写出来的代码跟你想象的不太一样 

运行流程不设计好的话，那么你作为一个架构师，根本是无法把控你的系统 

哪怕你的概要设计做的再好，根本没法落地，到你的小弟落地的时候，写一坨屎出来，最后功能可以跑通，但是他那个可悲的代码，完全没有办法呗别人理解。甚至可能他写出来的业务流程是错的。直到你集成测试，code review的时候，才会去发现。 

对那些重要的，复杂的流程，我要求必须是要活动图 

对于一些不复杂的流程，可以手写文字版本的运行流程就可以了 

但是对于一些核心的，复杂的，重要的业务流程，我们需要去画活动图，通过活动图体现出来一个正确的，清晰的系统运行的流程 

5、详细设计的重要性总结 

重中之重，一句话，你务必确保说，你作为一个架构师，看了你手下的小弟设计出来的详细设计文档，连你都知道怎么写代码，可能那个代码不用你去写，但是你看着这个文档，绝对知道怎么去写这个代码 

做到这个程度，详细设计文档就成功了

#### 07_项目管理

##### 01_项目进度计划

02_电商系统v1.0版本网络图

![](C:\Users\zy199005\Desktop\中华石杉\images\java\04\0422.png)

##### 02_每周工作计划

##### 03_个人周报

##### 04_项目周报

#### 08_编码开发

#### 09_单元测试

#### 10_冒烟测试

#### 11_集成测试

#### 12_系统测试

#### 13_验收测试

#### 14_系统上线

##### 系统上线checklist

1、RD自测报告 

1.1 小C的自测报告 

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果 

1.2 小D的自测报告 

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果 

1.3 老A的自测报告 

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果 

1.4 老B的自测报告 

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果 

1.5 老K的自测报告 

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果 

2、系统测试报告 

2.1 集成测试报告 

（1）第一轮集成测试报告

（2）第二轮集成测试报告

（3）第三轮集成测试报告

2.2 系统测试报告 

（1）第一轮系统测试报告

（2）第二轮系统测试报告

（3）第三轮系统测试报告 

2.3 验收测试报告 

（1）验收测试报告 

这份文档，需要由项目的架构师/leader，来在上线之前，收拢好，编写好，里面应该包含所有的报告，发给技术总监。技术总监是不负责一线的带项目，一线带项目的一般都是所谓的架构师，或者是技术经理。

#####  系统上线步骤

1、数据库初始化 

（1）小C和小D负责建库建表，建立对应的prod profile

（2）老A和老B负责检查所有的SQL语句是否使用了对应的表的索引

（3）老K负责最后确认 

2、部署系统到线上机器 

（1）先对master分支打一个tag，标注我们的这个v1.0.0的版本

（2）基于master分支的代码和prod profile将完整的代码，打成jar包

（3）然后用scp将jar包上传到zhss-eshop-prod机器上去

（4）使用java -jar命令启动线上系统 

3、线上验证 

（1）观察系统是否将日志打印到了我们指定的日志文件中去

（2）观察系统是否打印出了我们指定的系统初始化的日志

（3）PM负责在线上系统，使用测试账号，将核心主流程执行一遍，确认无误，上线成功 

git tag -d <tagname>
git push origin :refs/tags/<tagname>

