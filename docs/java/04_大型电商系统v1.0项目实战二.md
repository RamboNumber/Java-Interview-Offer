# 04_大型电商系统v1.0项目实战

## 10万行代码的大型电商系统v1.0版本开发实战

### 105_工程初始化：完成单块系统工程的搭建

### 106_工程初始化：完成内部模块调用接口的定义

### 107_工程初始化：将工程上传到码云以及创建分支

如果说我们在自己的虚拟机上去搭建gitlab的话，可以是可以，之前都给大家演示过了，但是有个问题，那样的话，就会导致我们光是一个代码仓库，都会耗费很多的宝贵的笔记本电脑的内存资源。 

码云，很流行的，很多公司，可以直接基于码云来做代码管理。码云本身就是基于gitlab来开发和定制的，所以使用起来跟我们之前讲解的gitlab几乎是一样的。 

码云ssh key 

git init

git remote add origin https://gitee.com/ZhongHuaShiShan/eshop.git

git fetch origin

git branch --set-upstream-to=origin/master master

git pull origin master --allow-unrelated-histories

git push -u origin master

 

git clone

 

git fetch origin

git checkout -b 本地分支 origin/远程分支

git pull 

老A，老B，小C，小D，老K 

每个人都负责了一些的模块，你可以对每个模块的开发都拉一个feature分支出来 

采购中心，就是一个feature/purchase

wms中心，就是一个feature/wms 

这样子的话会导致feature分支太多了 

给每个人都建立一个feature分支，总共就只需要5个feature分支就可以了 

feature/A

feature/B

feature/C

feature/D

feature/K 

develop 

feature/common-api 

老A，只要将自己需要的feature分支弄下来就可以了，他只需要develop，feature/A，feature/common_api，不需要feature/B 

老B，同理 

但是我们这里因为是一人扮演了5个角色，所以的话呢，我们是需要将所有的分支都拉取到我们本地来的

### 108_工程初始化：完成开发环境的数据库初始化

### 109_项目管理：制定第一周的工作计划

### 110_完成权限管理模块的代码骨架的搭建

### 111_基于原型模式和享元模式完成不同分层POJO之间的数据拷贝

### 112_完成权限管理模块的CRUD功能的代码编写

### 113_基于组合模式与访问者模式完成权限删除功能的开发

### 114_发表评论模块：梳理相关技术问题

1、spring boot对多文件上传的支持 

新建main/webapp目录 

```
<dependency>  
    <groupId>commons-fileupload</groupId>  
    <artifactId>commons-fileupload</artifactId>  
    <version>1.3.2</version>  
</dependency>  
```

```
@PostMapping("/uploads")
public Sgtring uploads(MultipartFile[] files) {
    try {   
        File uploadDir = new File(uploadDirPath);
        if(!uploadDir.exists()) {
            uploadDir.mkdir();
        }
        
        for(MultipartFile file : files) {
            if(file != null) {
                String targetFilePath = uploadDirPath + file.getOriginalFilename();
                File targetFile = new File(targetFilePath);
                if(targetFile.exists()) {
                    targetFile.remove();
                }
                file.transferTo(targetFile);
            }
        }
    } catch(Exception e) {
    
    }    
} 
```

2、spring boot对定时调度的支持 

```
@SpringBootApplication
// 加入这个注解，启用定时调度机制
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
} 
```

```
@Component
public class ScheduleTask {
    // 每隔5秒执行一次
    @Scheduled(fixedRate = 5000)
    public void execute() {       
    }
}
```

### 115_发表评论模块：完成手动发表评论的代码编写

### 116_发表评论模块：完成自动发表评论的代码编写

### 117_完成商品中心的属性管理模块的代码编写

### 118_完成加入购物车功能的代码编写

### 119_完成加入购物车功能的单元测试以及冒烟测试（一）

### 120_完成加入购物车功能的单元测试以及冒烟测试（二）

### 121_结合模板方法模式、命令模式、工厂方法模式开发库存管理功能

### 122_完成第一周第二天的站立会

### 123_完成权限管理模块的单元测试和冒烟测试（一）

### 124_完成权限管理模块的单元测试和冒烟测试（二）

### 125_完成权限管理模块的单元测试和冒烟测试（三）

### 126_完成权限管理模块的单元测试和冒烟测试（四）

### 127_完成发表评论模块的单元测试和冒烟测试（一）

### 128_完成发表评论模块的单元测试和冒烟测试（二）

### 129_完成发表评论模块的单元测试和冒烟测试（三）

### 130_完成属性管理模块的单元测试和冒烟测试

### 131_完成查看购物车模块的开发

### 132_完成库存管理模块剩余功能的开发

### 133_基于中介者模式异步通知调度中心更新库存

### 134_基于观察者模式获取调度中心的异步处理结果

### 135_基于备忘录模式完成队列阻塞时的数据离线存储

### 136_完成角色管理模块的代码编写

### 137_完成评论管理模块的部分功能开发

### 138_完成类目管理模块的代码编写（一）

### 139_完成类目管理模块的代码编写（二）

### 140_完成查看购物车功能的单元测试和冒烟测试

### 141_完成库存管理模块的单元测试和冒烟测试（一）

### 142_完成库存管理模块的单元测试和冒烟测试（二）

### 143_完成库存管理模块的单元测试和冒烟测试（三）

### 144_完成角色管理模块的单元测试和冒烟测试

### 145_完成评论管理模块剩余功能的开发

### 146_开发类目管理模块以及对原型模式完善深度克隆功能

### 147_完成操作购物车功能的开发以及测试

### 148_完成调度中心的调度采购入库功能的开发

### 149_完成账号管理模块的代码编写

### 150_完成评论管理模块的单元测试和冒烟测试 

### 151_完成编辑类目功能的代码编写

### 152_基于优化后的组合模式与访问者模式完成删除类目功能

### 153_完成类目管理模块的单元测试和冒烟测试（一）

### 154_完成类目管理模块的单元测试和冒烟测试（二）

### 155_关于生成订单功能delay到下周开发的说明

### 156_完成调度采购入库功能的单元测试和冒烟测试

### 157_编写第一周的周报以及进行第一周的周会

### 158_完成账号管理模块的单元测试和冒烟测试

### 159_完成评论前台列表查看功能的代码编写

### 160_完成商品中心的品牌管理模块的代码编写

### 161_基于策略模式与抽象工厂模式完成订单价格计算功能

### 162_完成销售出库功能的开发思路梳理

### 163_将误提交到码云的eclipse文件和target目录删除

### 164_基于访问者模式完成权限控制模块的代码编写

### 165_基于享元模式实现权限数据的缓存与刷新

### 166_完成评论列表查看功能的单元测试和冒烟测试

### 167_完成品牌管理模块的单元测试和冒烟测试

### 168_完成订单确认页相关的剩余代码的编写

### 169_完成创建订单功能的代码编写

### 170_完成调度销售出库需要的wms中心接口的定义

### 171_完成调度销售出库核心逻辑的代码编写

### 172_基于构造器模式完成销售出库单创建的代码编写

### 173_对学员反馈的2个遗漏bug进行修复

### 174_完成权限控制模块的单元测试和冒烟测试

### 175_完成促销管理模块的代码编写

### 176_完成商品管理模块部分代码的编写（一）

### 177_完成商品管理模块部分代码的编写（二）

### 178_完成提交订单模块的单元测试和冒烟测试

### 179_完成调度销售出库模块的单元测试

### 180_完成用户注册与登录模块的代码编写

### 181_完成促销活动管理模块剩余功能的开发

### 182_完成商品管理模块部分代码的编写（三）

### 183_完成商品管理模块部分代码的编写（四）

### 184_完成订单查询功能的代码编写

### 185_关于退货入库功能开发delay一天的说明

### 186_完成用户注册与登录功能的单元测试和冒烟测试

### 187_完成促销活动管理模块的单元测试和冒烟测试（一）

### 188_完成促销活动管理模块的单元测试和冒烟测试（二）

### 189_基于访问者模式完成类目属性继承功能的实现

### 190_基于状态模式完成商品管理模块的状态流转逻辑封装

### 191_完成订单查询功能的单元测试和冒烟测试

### 192_完成调度退货入库功能的开发和测试

### 193_第二周周会总结以及第三周工作计划制定

### 194_完成会员中心的个人信息模块的开发

### 195_完成促销中心的优惠券管理模块的开发

### 196_完成商品中心的商品管理模块的单元测试

### 197_完成订单中心的取消订单模块的开发

### 198_完成调度中心的库存管理模块的50%功能的开发

### 199_关于调度中心的库存管理模块的开发进度调整的说明

### 200_完成会员中心的个人信息管理模块的单元测试和冒烟测试

### 201_完成促销中心的优惠券的领取、发放和使用功能的开发

### 202_完成商品中心的商品管理模块的冒烟测试

### 203_完成订单中心的取消订单模块的单元测试和冒烟测试

### 204_对调度中心的库存管理模块的已写好的代码优化

### 205_基于设计模式完成会员等级积分更新模块

### 206_完成优惠券管理模块的单元测试和冒烟测试

### 207_完成商品查询模块和对外接口的开发开发

### 208_支付宝和微信扫码支付接入流程介绍

### 209_库存的锁定、扣减以及释放相关流程再次梳理

### 210_完成调度中心的库存管理模块的剩余代码的开发

### 211_完成会员等级积分更新模块的测试

### 212_完成退货工单管理模块的50%功能开发

### 213_完成商品中心对外接口的测试

### 214_完成订单中心的支付订单模块的开发

### 215_继续进行调度中心的库存管理模块的开发（一）

### 216_继续进行调度中心的库存管理模块的开发（二）

### 217_完成wms中心的货位管理模块的开发

### 218_完成退货工单管理模块剩余50%代码的开发

### 219_完成采购入库单管理模块50%功能的开发

### 220_完成订单中心的支付订单模块的测试

### 221_完成调度中心的库存管理模块的测试

### 222_第三周周会总结以及第四周工作计划制定

### 223_完成wms中心的货位管理模块的测试

### 224_完成退货工单管理模块的单元测试

### 225_基于设计模式完成采购入库单审核功能的开发

### 226_完成订单中心剩余功能的开发（一）

### 227_修复内存队列离线存储方案中的一个bug

### 228_完成采购中心的供应商管理模块的开发

### 229_完成物流中心的运费模板管理模块的开发

### 230_完成退货工单管理模块的冒烟测试

### 231_完成wms中心的采购单管理模块的测试

### 232_完成订单中心的确认收货功能的开发

### 233_完成采购中心的供应商管理模块的测试

### 234_完成物流中心的运费模板管理模块的测试

### 235_完成财务中心的采购结算单管理模块的开发

### 236_完成wms中心的销售出库单管理模块50%功能的开发

### 237_完成订单中心剩余功能的开发（二）

### 238_完成采购中心的采购单管理模块50%功能的开发

### 239_基于策略模式完成物流中心的运费计算模块的开发

### 240_完成财务中心的供应商结算模块的开发

### 241_完成wms中心的销售出库单管理模块剩余50%功能的开发

### 242_完成订单中心剩余功能的开发（三）

### 243_结合模板方法模式对订单中心的状态模式进行优化

### 244_完成采购中心的采购单管理模块剩余50%功能的开发

### 245_完成物流中心的运费计算模块的测试

### 246_完成财务中心的采购结算单管理模块的测试

### 247_完成wms中心的销售出库单管理模块的测试

### 248_完成订单中心最后几个接口的开发

### 249_完成采购中心的采购单管理模块的测试

### 250_基于解释器模式与组合模式重构规则解析代码

### 251_基于装饰模式重构订单状态管理器和订单操作日志

### 252_基于适配器模式重构文件操作API接口

### 253_基于迭代器模式重构离线存储数据恢复代码

### 254_对第四周工作进行总结以及制定第五周的工作计划

### 255_基于代理模式完成物流中心剩余功能的开发

### 256_完成财务中心的物流公司打款功能的开发

### 257_完成wms中心的退货入库单管理模块50%功能的开发

### 258_完成订单中心剩余功能50%的单元测试

### 259_基于代理模式完成支付中心的第三方支付对接的开发

### 260_完成物流中心剩余两个功能的测试

### 261_完成财务中心剩余50%功能的测试

### 262_完成wms中心的退货入库单管理模块剩余50%功能的开发

### 263_完成订单中心剩余功能的单元测试（二）

### 264_完成支付中心的退款功能的开发

### 265_完成wms中心的库存管理模块的开发

### 266_完成财务中心剩余功能的开发（二）

### 267_完成wms中心的退货入库单管理模块的测试

### 268_完成订单中心剩余功能的冒烟测试

### 269_完成支付中心的支付交易流水管理模块的测试

### 270_基于阿里编码规范eclipse插件进行静态代码扫描（一）

就是说到269讲为止，咱们已经完全搞完了电商系统v1.0雏形版的开发，开发过程是包含了编码、单元测试、冒烟测试，按照一个一个的模块，每个模块一开发完，就写单元测试全部跑通，然后立马就是冒烟测试，串起来跑通主流程

静态代码扫描，用阿里编码规范eclipse插件，这个插件会按照阿里的编码规范，给我们扫描一遍，告诉你哪儿代码不如何规范的。非常好，代码规范，说白了，你写再多，都是很难落地的，为什么呢？如果你没有一个通过机器去检查你的代码是否符合规范的一个过程，光靠人肉去保证，几乎不太可能。 

必须依靠静态代码扫描的工具，去确保你的代码一定是符合公司的编码规范的。刚开始你写代码很多地方会不符合这个规范，但是每次扫描过后，让你改，你重复改几次之后，其实这个编码就已经融入你的血液中了。然后以后你就会发现自己的编码风格越来越标准，每次静态代码扫描之后要修改的地方越来越少。 

1、要求JDK 1.8

2、Help -> Install New Software

3、Add -> https://p3c.alibaba.com/plugin/eclipse/update -> 安装

4、重启eclipse

5、右击项目 -> Alibaba Code Guidelines 

演示了一把用阿里编码规范插件，扫描spring boot-demo工程，示范了修复所有的问题，代码真的变得规范了很多

### 271_基于阿里编码规范eclipse插件进行静态代码扫描（二）

### 272_基于阿里编码规范eclipse插件进行静态代码扫描（三）

### 273_基于阿里编码规范eclipse插件进行静态代码扫描（四）

### 274_基于阿里编码规范eclipse插件进行静态代码扫描（五）

### 275_基于阿里编码规范eclipse插件进行静态代码扫描（六）

### 276_基于maven corbertura插件生成单元测试覆盖率报告

1、编码+单元测试+冒烟测试
2、阿里编码规范插件，静态代码扫描，扫描出来了代码里不符合规范的部分，修复了编码规范问题
3、生成一个单元测试覆盖率的报告

你作为一个程序员，你跟你老大说，老大，没问题，我这个代码写的很棒，单元测试都写好了

我作为老大，我有一个疑问，你总共写了多少行代码，1万行吧。你写的单元测试把这1万行代码中的多少行给测到了？仅仅测了1000行代码，剩下9000行代码，可能根本就没测试。我作为老大，要求的是，你不要空口白牙跟我说你单元测试写的很棒。你给我一个单元测试覆盖率的报告，会去运行你所有的单元测试，然后会检查你的单元测试测试了百分之多少的代码。

我作为老大，看到了这份单元测试的报告之后，我才能确定说，ok，你的单元测试基本上是把你写好的代码都给覆盖到了。

我们课程里，因为课程是授课的原因，不可能花费大量的精力写单元测试覆盖率那么的高，排期，你们不要觉得是瞎排的。就咱们这个项目阶段一的这个业务复杂度、技术难度，5个人，干1个多月，很正常。雏形版本出来，很正常的。

创业的经历，一般呢一个创业公司，一个技术团队，就四五个人，老K那个角色甚至可能就是CTO的角色。亲手撸代码。1个多月，就是做出来一个雏形版本，是给谁看的？是给不懂技术不懂产品只懂市场的CEO看的，吭哧吭哧干6个月出不来东西，CEO着急了。

CEO，是给投资人看，种子轮，200万资金。你先启动起来，做点儿东西，做点原型，做点雏形，我先看一下，你别空口白牙光在那儿。CEO这个时候是很着急，特别是那些不懂技术的CEO，2个月只能，1个月之内，出来个雏形版，给他们先看一下，投资人。

5个人，假设老K作为后端团队负责人，5万；老A和老B，一般是老K的多年的老下属，老朋友，绝对信得过，3万~4万；小C和小D，一般是老K的朋友推荐，或者是市场上招聘的一些刚培训出来的生瓜蛋子，1万~1万5。

5个人，光是一个技术团队，一个月工资是13万。

前端，3个。一个前端老大（4万），带着2个前端小弟（1万）。6万。

QA，1个。高级QA，3万。

UI，1个。高级UI，3万。

产品，1个。高级产品，4万。

CEO，1个。5万。

CTO，1个。5万。

运营，2个。资深运营，中级运营，3万+1万。

职能，全能型选手，包括了HR、行政、财务（找外面的兼职财务，代理记账）：1个，资深职能，2万。

办公费用（场地租金+水电+补贴+福利）：5万。

每个月的成本，是50万。200万的种子轮，可以让你支撑4个月。2个月就必须融资下一轮了。倒排期，1个月，给我干出来雏形版，v1.0.0版本。1个半月。2个月，融资下一轮。

天使轮，500万资金。开始扩张团队，撸起袖子，干。

一般来说，这500万资金，要让你花个3~6个月。你要出来一个可以用的可以推广的产品版本。可以开始大规模使用的这么一个版本。

整个所有的技术+产品+设计+运营+职能：扩张1倍。

后端团队，你是作为后端负责人，你现在加你一共是5个人，你手下小弟是4个人，你这个团队扩张到11人。你手下带10个人。项目阶段二的一个标配。

作为我一个人，授课，所以我可能为了进度，得做一些简化，controller、service等组件没写单元测试，我就写dao的单元测试。少壮不努力，老大徒伤悲。前期不写单测，后期不敢上线。

<plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>cobertura-maven-plugin</artifactId>
        <version>2.7</version>
</plugin>

mvn cobertura:cobertura

target/site/cobertura/index.html

### 277_基于码云Pull Request完成code review

每个人都在自己本地静态代码扫描也结束了，单元测试覆盖率报告也都出来了 

每个人提交Pull Request给其他同事，或者是leader，来review这个代码，leader review代码的时候，主要看4样东西： 

1、他会去看每个人的每一行代码，3个目的 

作为一个leader，或者是团队里其他的高工，你有责任和义务去仔细看其他人的代码，如果出问题，你作为leader或者高工有责任去帮低级别的人解决问题。 

code review，就是一个完美的时机，你作为一个leader或者高工，去仔细看手下写好的代码，你这样才可以把控全局，控制所有的东西。别让自己掉队。万一你手下小弟刚写好代码，外面拿到个offer，薪资暴涨50%，人跑了。 

code review，你或者其他高工看懂别人的代码，就代表你成为了那个人的一个backup。如果那个人跑了，你可以直接顶上去。 

1）帮低级别的人解决问题

2）backup

3）掌控系统的全局，每一块代码大概是怎么写的，心里有数 

2、你作为一个检查机制，检查在code review之前的规范，有没有执行 

别人给你给你提交PR的时候，你必须得让他同步提交三样东西： 

1）静态代码扫描的结果：blocker和critical级别的问题是否都解决了，major问题遗留了多少个

2）单元测试覆盖率的报告：你去检查他负责的那几个模块，单元测试的覆盖率是否达标

3）冒烟测试报告：他对他负责的模块的核心流程都进行了冒烟测试，确保他负责的模块的核心流程都可以跑通 

你要作为一个leader，去检查他都做了这几件事情 

3、以你的技术能力和经验，去发别人代码中的不合理之处，指导低级别的工程师去修缮和完善自己的代码 

优秀的code review，code review的时候，要注意哪些事情，1,2,3,4,5, 

我曾经有一段时间再我的团队里也推行了类似的这种code review的机制，我写了好几千字的code review规范。谁能记住？ 

连我自己都记不住。谁会在review代码的时候，一边review代码，一边对照着规范来检查。傻乎乎的，有时间、有耐心来干这种事情。 

落不了地，落地很麻烦，也许有少数几个人可以做到，但是全面推广到一个大型的，20人，30人，50人，100人，200人的技术团队。很难的。 

无招胜有招，没有什么所谓的code review的规范。 

就是负责review的一定是高工及以上的人，高工至少是工作好几年了，少则工作3~5年，多则工作5~8年。技术专家，8年+。架构师，10年+。 

你就以你的角度，和你当前的技术经验，技术的能力，对技术的掌握和把控，站在你的角度来审视别人的代码，如果你发现这哥儿们代码有些的烂的地方，你就给他提出code review的一些建议。 

比如说你作为一个资深高工，你对23种设计模式怎么使用都有很深的体会。你看别人的代码的时候，突然发现有一段代码是一坨屎： 

if() {

// 100行代码

} else if() {

// 200行代码

} else {

// 150行代码

} 

方法长达500行代码 

用策略模式+模板方法模式。。。。。。 

你就可以找到那哥儿们跟他说，你该怎么怎么优化一下你的代码 

代码一旦修改，同步的单元测试和冒烟测试，自己全部对应的做一下调整 

静态代码扫描、单元测试覆盖率报告，全部重新做一遍 

Pull Request再次提交到高工的手中，你再看一下当时让他修改的那些代码，发现，很好

### 278_基于develop分支和多环境配置完成集成测试（一）

因为我们接下来要换一个环境基于develop分支的代码在本地打包，打成一个jar包，然后将这个jar可以用scp从本地拷贝到集成测试环境的机器上去，然后在集成测试机器上，直接java -jar启动系统，就可以了 

在集成测试环境的机器上，其实是应该让这个系统去连接集成测试环境的mysql数据库的，所以这个配置呢就跟在开发环境连接的那个数据是不一样的。 

所以这个问题需要用maven profile支持多环境的配置文件的适配 

我本来是想用阿里云的机器，来演示多个环境的机器，集成测试机器，系统测试机器，验收测试机器，线上生产机器。项目阶段一采取的是最简单的一种技术架构，单块应用+3大框架整合+mysql。 

部署，就是打一个jar包，在各个环境下启动，就ok了。而且初期，雏形版，其实就是给CEO和投资人看看的。就团队内部几个人，有几个账号，各个RD，各个前端，各个产品，运用，去试用一下。其实几乎可以认为就没什么用户。根本也没什么所谓的并发量和这个压力。 

尽快结束项目阶段一，就是在我的本地windows机器，模仿成是各个环境的机器就可以了。然后各个环境的数据库，我就用本地mysql里的不同的库名就可以了。 

spring boot也可以支持多profile。我个人不用spring boot profile，慎用。如果你以后系统变得很复杂了，我自己之前设计过一个系统，他就是要自己搞一个针对自己系统的复杂的xml文件，此时你用spring boot profile是不太合适的。 

很多大公司里，是用公司统一的部署框架去部署的，要求的是你的系统针对不同的环境可以提供不同的指定的文件，META-INF/boot.properties。 

所以还是用我之前讲解的maven profile多环境支持，可以解决所有的问题，扩展性很好 

dev：开发环境

beta：集成测试/联调测试的环境 

src/main/profiles/dev

src/main/profiles/beta 

<profiles>

<profile>

<id>dev</id>

<build>

​             <resources>

​                  <resource>

​                     <directory>src/main/profiles/dev</directory>

​                     <includes>

​                          <include>**/*.xml</include>

​                          <include>**/*.properties</include>

​                     </includes>

​                     <filtering>true</filtering>

​                 </resource>

​             </resources>

​         </build>

</profile>

<profile>

<id>beta</id>

<build>

​             <resources>

​                  <resource>

​                     <directory>src/main/profiles/beta</directory>

​                     <includes>

​                          <include>**/*.xml</include>

​                          <include>**/*.properties</include>

​                     </includes>

​                     <filtering>true</filtering>

​                 </resource>

​             </resources>

​         </build>

</profile>

</profiles> 

mvn clean pakcage -Pbeta 

java -jar target\eshop-1.0.0.jar  

修改windows上的mysql的my.ini配置文件 

在C:\ProgramData\MySQL\MySQL Server 5.7中，有my.ini，里面可以各种配置 

max_connections = 1000 

重启mysql服务

### 279_基于develop分支和多环境配置完成集成测试（二）

上一讲咱们已经搭建好了集成测试的一些基础性的一些东西，比如说maven profiles，集成起来以后发现有一些问题，所以我们也给顺手解决了一下

其实我们正经的在公司里的集成测试，我们应该此时就是使用develop分支的代码，使用beta profile（连接的都是集成测试环境的一些基础设施，mysql），去打一个包。然后将这个jar包，用scp给上传到集成测试服务器上去，然后java -jar就可以在集成测试环境启动我们的系统。然后QA，就可以对集成测试环境的系统进行测试。

一般来说，在企业中，mysql这块，基础设施这块，都是分成两个环境。测试环境，生产环境。测试环境比如说会搞一个mysql服务器，但是里面会建不同环境的数据库，eshop-dev，eshop-beta，eshop-test。用master分支的代码，在验收测试服务器上部署，然后连接的直接就是eshop-prod库，使用的是生产环境的mysql服务器；master分支代码，在生产机器上部署，直接连接eshop-prod库。 

我肯定是要用完整的阿里云服务器去演示生产环境的一些部署 

集成测试，我不说太细的，这块其实是QA（测试工程师的领域），不是我们的领域，是配合。开发、单元测试、冒烟测试，工程、部署。构造测试用例，如何细细的去测试这个东西，是测试工程师的活儿。 

集成测试，测试用例不会太多，一般来说就是构建一些能让系统核心主流程跑通即可。 

系统测试，正儿八经，往死里测，一般好的测试工程师，丰富的测试经验，丰富的测试用例构造的经验，构造出来大量的测试用例，下订单 

各种测试用例，A商品绑定了促销活动1，B商品绑定了促销活动2 -> 订单，看看怎么样；A商品绑定了促销活动2，B商品绑定了促销活动1 -> 订单。实验出来几乎所有的线上用户可能进行的操作，全部给你覆盖到。一般来说 ，都要3~5轮测试。起码3轮。测到最后，所有的测试用例跑过去，没什么bug。 

验收测试之前，也会有其他的环节，压力测试（模拟比如瞬间10万人，100万并发过来，看系统的响应速度和能不能抗住）；性能测试（精细的去测试你的每个主流程，每个操作，响应时间一般在多久）；可用性测试（比如说，给你模拟，redis突然宕机了，再继续下单，看看你的降级措施有没有奏效） 

验收测试，不是QA的事儿了，一般是产品经理，负责一个头儿，一个尾巴。开发之前，产品经理告诉你，你得做成什么样子；中间产品经理会时不时的跑过来关心你们，看你们搞的怎么样了，甚至可能有些公司，工程师的项目管理太挫了，PM会冲上来顶住，召集一群RD做项目管理；尾巴的时候，就是到验收测试的环节，PM上来，在验收测试环境，会给PM开通一个测试账号，模拟自己就是个小白用户，各种下单，确定她说，很满意。验收通过。 

就是咱们，部署上线，上生产环境 

模拟修复一个线上的bug，走一遍线上bug修复的流程和规范

### 280_基于develop分支和多环境配置完成集成测试（三）

比如有5个人+一个QA一起集成测试，会指定一个人专门部署系统，拉取最新分支，打包，scp上传到集成测试服务器上去，启动 

但是只要有QA发现了bug，5个人一起排查，发现是谁的bug，谁就将develop分支拉取到自己的本地，首先是在本地基于QA反馈的操作，复现出来那个bug。然后修复bug，然后修复好之后，验证bug是修复好了。将代码提交到develop分支上去。5个人谁都可以修改develop分支的代码。 

通知那个专门部署的人，重新拉取代码，打包，部署 

QA重新执行测试用例，验证bug已经修复了 

QA也是走几轮的，第一轮，QA先把预备好的所有测试用例执行一遍，发现一堆bug，反馈给你们5个人，每个人认领相关的bug。然后吭哧吭哧修复一段bug。 

然后第二轮开始之前，专门有个人部署一下 

QA再开始测第二轮，就是再把所有的测试用例执行一遍 

循环往复，直到集成测试通过，一个bug都没有了 

### 281_基于develop分支和多环境配置完成集成测试（四）

### 282_基于develop分支和多环境配置完成集成测试（五）

### 283_基于develop分支和多环境配置完成集成测试（六）

### 284_基于develop分支和多环境配置完成集成测试（七）

### 285_基于develop分支和多环境配置完成集成测试（八）

### 286_基于release分支和多环境配置完成系统测试

已经完成了集成测试了 

develop分支，集成了所有人的代码，beta profile（连接的是eshop-beta库），你在公司里应该用beta profile打一个jar包，部署到集成测试环境的机器上去 

QA开始搞这个集成测试，所有人都基于develop分支去进行bug的fix 

目前的状态，就是主流程全部都跑通了 

测试用例是比较少的，主要是确保主流程跑通，对各种各样的异常情况，是不测试的 

系统测试，release分支，在码云上，通过develop分支拉一个release分支出来（release/v1.0.0），刚拉出来的时候肯定是跟develop分支一模一样的。搞一个test profile（连接的是eshop-test库）。基于release分支的代码和test profie打一个jar包，部署到系统测试环境的机器上去。 

QA开始搞系统测试，功能测试，QA会用预先准备好的大量的测试用例，来进行测试。就比如下订单这个环节。就是一个测试用例，相当于就是一个订单里一个商品，那个商品就绑定了一个直接折扣的促销活动，优惠券就是用了一个现金券。 

QA会下N多个订单，有一个订单购买了两个商品，一个商品使用了赠品促销活动，一个商品使用了满减促销活动，然后使用了满减优惠券；另外一个订单，一个商品使用了满赠促销活动，另外一个商品没有使用促销活动，同时没有使用优惠券。QA的责任，就是去模拟出线上几乎所有可能发生的用户会执行的操作，都给地毯式的铺一边。 

参差不齐，一般的QA，在这个环节，如果自己经验不丰富，对QA的知识不够全面，可能会导致测试的时候，漏掉了很多的测试用例。 

我们不会自己去做，但是我们会模拟一下，先搞一个release/v1.0.0分支出来，就是搞一个test profile，然后再搞一个eshop-test库，模拟一下。 

git fetch origin

git checkout -b 本地分支 origin/远程分支 

然后就是所有人都基于release/v1.0.0分支进行调试，QA在这一轮起码是3轮，甚至可能是5轮。上千个bug都有可能，RD写的代码太烂了。一两百个bug。 

每个人修复好了自己的bug，都直接在release分支上修改代码，然后直接提交代码 

修复好了第一轮的bug之后，再次打包部署，让QA再次测试第二轮 

依次循环往复，直到系统测试环节所有测试用例执行完，没有bug了，那么这个环节就是结束

### 287_基于master分支和多环境配置完成验收测试

基于release/v1.0.0分支，和test profile，eshop-test库，完成了系统测试，整个系统现在基本已经没有什么bug了 

此时需要将release/v1.0.0分支，合并到master分支上去，然后直接基于master分支的代码，加上prod profile，连上eshop-prod库，但是这个打好的jar包，是部署在验收测试环境的服务器上的 

v1.0.0版本的master分支的代码，加上prod profile，连上eshop-prod库，但是是部署在线上服务器上在跑着，线上服务器上跑着，基于域名直接对线上的用户请求提供访问。 

但是如果我们开发好了比如下一个版本，v1.1.0版本的代码，release/v1.1.0合并到了master分支，要做验收测试，此时master分支已经混合了v1.1.0版本的代码，当然此时不能直接部署在线上服务器的 

但是完全可以将v1.1.0版本的master代码，基于prod profile连上生产库，部署在验收测试环境的服务器上，此时产品经理可以使用一个测试账号，通过验收测试环境的服务器，来使用我们的系统，使用测试账号来下订单什么的，验收他期望的系统德全流程。 

前端做的v1.1.0版本的前端代码，此时也会同时部署在他们的前端的验收测试环境的服务器上，连接的是我们的后端的验收测试环境的服务器，staging机器。所以产品经理就可以从前端的staging机器部署的url进入系统来访问，此时呢用的数据是线上库，但是代码是混合了最新的v1.1.0版本的。 

上面的是一种验收测试的流程，还有一种流程，如果你的新版本的代码，没法直接使用线上库，该怎么办呢？肯定还是用master分支，但是会开一个staging profile，连接的是eshop-staging库。做一遍验收，这个环境就是专门给产品经理来验收的。 

一般来说我比较提倡的是第二种模式，我个人认为，环境要划分清楚，要分开，不能搞的太混合太模糊了。master分支代码，staging profile，eshop-staging库来验收测试。

### 288_按照规范制定系统上线计划以及完成系统的最终上线

### 289_按照系统运维规范对线上的bug进行修复

### 290_用一张思维导图对整个项目阶段一进行总结  

互联网公司的流程与规范
	开发流程与规范
		可以落地的软件工程是什么
		可以落地的互联网公司的开发流程与规范
	项目管理流程与规范
		可以落地的实用性项目管理流程与规范
		可以落地的互联网公司的项目管理流程与规范
	在大型复杂的电商业务系统完整实践2套流程与规范
		需求评审
		需求分析
		概要设计
		详细设计
		项目管理计划
		工程初始化
		项目进度把控
			工作计划
			站立会
			周会周报
		项目风险管理
		编码开发
		单元测试
		冒烟测试
		静态代码扫描
		单元测试覆盖率检测
		code review
		集成测试
		系统测试
		验收测试
		系统上线
		线上运维

Spring Boot
	只讲解Spring Boot最核心的一些功能
	掌握了基于spring boot的基础技术架构
		Spring Boot
		Spring Web MVC
		Spring Core
		MyBatis
		MySQL
		Tomcat
	核心功能学习之后就可以支撑所有crud业务类系统的开发
	在大型复杂的电商业务系统中大量实践了Spring Boot的核心基础功能

设计模式
	大白话讲解了23种设计模式
	结合复杂的电商业务深度实战了23种设计模式
	在结合复杂业务深度实战之后就可以透彻理解23种设计模式
	在透彻理解23种设计模式之后就可以在自己项目中找场景来实战
	从此以后出去面试没人可以问的倒你设计模式相关的东西

作为一个架构师加入公司之后
	当你面对的是一个从0到1的项目背景的时候
	制定整套可以落地的流程与规范
		推动和指导所有项目按照流程与规范去执行
		从项目一开始就确保大家都按照流程与规范在走
		后面项目一旦快速走起来，就可以有条不紊的推进
	使用自己之前做过的设计模式案例对团队进行培训
		要求团队在详细设计环节考虑设计模式的使用
		在详细设计环节就严格把控面向对象的设计
		通过设计模式的运用来保证系统的代码质量
		确保系统在第一个版本的代码质量就很高
			在后续快速开发的时候，扩展性很好，很容易修改代码
			代码的可读性很好，可维护性很好
			彻底避免前期代码成屎导致后期代码要重写
	推动从0到1的项目采用最简单的spring boot技术架构去做
		系统从0到1的过程汇中是几乎没什么用户和并发量的
		只要用最简单的技术架构就可以开发出来所有的业务功能
		用最简单的技术架构速度是最快的
		非常适合10人以内的小型技术团队

下一步的课程展望
	从项目阶段二开始完全基于复杂的业务系统实战所有的技术和架构
		基于9万多行代码的系统来实战技术和架构
		对技术和架构的深入以及实战性完全模拟真实的大型生产项目
		大家在复杂业务系统中实战技术和架构，理解的深度会非常好
		这样子去实战技术和架构以后出去找工作
			面试有真实经验可以说
			直接落地就可以使用
		跟其他培训机构相比
			N个技术一个一个理论的讲+一堆demo
			来一个几千行代码的demo项目实战
			你对技术和架构的理解停留在理论层面，根本没体会到在复杂项目中如何使用
			出去面试没有真实经验可以说
			找到了工作面对复杂业务的时候，之前学到的demo是没法用的
			学到的demo跟实际的复杂生产项目是有一定的差距的
	研发一套公司的企业级框架（项目阶段二之后）
		阅读spring mvc、spring core、mybatis等框架的源码
		基于开源框架针对我们的业务开发一套我们的公司研发框架
		将我们的crud业务类开发效率提升10倍
	再次去完善整个大型电商系统的业务
		比现在复杂好几倍
		各个中心都会比现在业务复杂好几倍
	基于复杂了好几倍的电商业务再去实战高并发、高可用等复杂的技术架构
		真正在完全生产级和真实的项目中去体验各种架构的实战
		真正积累和积淀真实的架构经验

完成了大型电商系统v1.0版本的开发
	大型电商系统的雏形版本
	麻雀虽小五脏俱全
		包含电商核心的14个中心
		采购、购物、退货3大核心流程全部走通
	一套9万多行代码的复杂电商v1.0系统
	对大型电商系统的核心业务知识就理解的很透彻了