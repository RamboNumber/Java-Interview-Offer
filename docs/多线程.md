# 多线程

多线程能够在操作系统多核配置的基础上，能够更好地利用服务器的多个CPU资源，使程序运行起来更加高效。Java通过提供对多线程的支持来在一个进程内并发执行多个线程，每个线程都并行执行不同的任务，以满足编写高效率程序的要求。

## 1.Java线程的创建方式

- 继承Thread类
- 实现Runnable接口
- 通过ExecutorService和Callable<Class>实现有返回值的线程
- 基于线程池

## 2.继承Thread类

Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程。具体实现为创建一个类并继承Thread接口，然后实例化线程对象并调用start方法启动线程。start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。run方法内的代码是线程类的具体实现逻辑。

```
//通过继承Thread类创建NewThread线程
public class NewThread extends Thread{
	public void run(){
	
	}
} 
//实例化一个线程对象
NewThread newThread=new NewThread();
//调用start方法启动线程
newThread.start();
```

以上代码定义了一个名为NewThread的线程类，该类继承了Thread，run方法内的代码为线程的具体执行逻辑，在使用该线程时只需新建一个该线程的对象并调用其start方法即可。

## 3.实现Runnable接口

基于Java编程语言的规范，如果子类已经继承（extends）了一个类，就无法再直接继承Thread类，此时可以通过实现Runnable接口创建线程。具体的实现过程为：通过实现Runnable接口创建ChildrenClassThread线程，实例化名称为childrenThread的线程实例，创建Thread类的实例并传入childrenThread线程实例，调用线程的start方法启动线程。具体的实现代码如下：

```
//通过继承Thread类创建NewThread线程
public class ChildrenClassThread extends SuperClass implements Runnable{
	public void run(){
	
	}
} 
//实例化一个ChildrenClassThread对象
ChildrenClassThread childrenThread=new ChildrenClassThread();
//创建一个线程对象并将其传入已经实例化好的childrenThread实例
Thread thread=new Thread(childrenThread);
//调用start方法启动线程
thread.start();
```

在传入一个实现了Runnable的线程实例target给Thread后，Thread的run方法在执行时就会调用target.run方法并执行该线程具体的实现逻辑。在JDK源码中，run方法的实现代码如下：

```
@Override
public void run(){
	if(target!=null){
		target.run();
	}
}
```

## 4.通过ExecutorService和Callable<Class>实现有返回值的线程

有时，我们需要在主线程中开启多个线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。具体的实现方法为：创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。具体的调用过程为：创建一个线程池、一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历Future List中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果，实现代码如下：

```
//实现Callable接口创建MyCallable线程
public class MyCallable implements Callable<String>{
	private String name;
	public MyCallable(String name){//通过构造函数为线程传递参数，以定义线程名称
		this.name=name;
	}
	@Override
	public String call() throws Exception{//call方法内为线程实现逻辑
		return name;
	}
}
	//创建一个固定大小为5的线程池
	ExecutorService pool=Executors.newFixedThreadPool(5);
	//创建有多个返回值的任务列表List
	List<Future> list=new ArrayList<Future>();
	for(int i=0;i<5;i++){
		//创建一个有返回值的线程实例
		Callable c=new MyCallable(i+"");
		//提交线程，获取Future对象并将其保存到Future List
        Future future=pool.submit(c);
        list.add(future);
	}
	//关闭线程池，等待线程执行结束
	pool.shutdown();
}
```

## 5.基于线程池

线程是非常宝贵的计算资源，在每次需要时创建并在运行结束后销毁是非常浪费资源的。我们可以使用缓存策略并使用线程池来创建线程，具体过程为创建一个线程池并用该线程池提交线程任务，实现代码如下：

```
//创建大小为10的线程池
ExecutorService pool=Executors.newFixedThreadPool(10);
for(int i=0;i<10;i++){
	//提交多个线程任务并执行
	pool.execute(new Runnable(){
		@Override
		public void run(){
		
		}
	});
}
```

## 6.线程池的工作原理

Java线程池主要用于管理线程组及其运行状态，以便Java虚拟机更好地利用CPU资源。Java线程池的工作原理为：JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果线程数量超过了最大线程数量（用户设置的线程池大小），则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。

线程池的主要作用是线程复用、线程资源管理、控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）地运行。

## 7.线程复用

在Java中，每个Thread类都有一个start方法。在程序调用start方法启动线程时，Java虚拟机会调用该类的run方法。前面说过，在Thread类的run方法中其实调用了Runnable对象的run方法，因此可以继承Thread类，在start方法中不断循环调用传递进来的Runnable对象，程序就会不断执行run方法中的代码。可以将在循环方法中不断获取的Runnable对象存放在Queue中，当前线程在获取下一个Runnable对象之前可以是阻塞的，这样既能有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行。这样就简单实现了一个线程池，达到了线程复用的效果。

## 8.线程池的核心组件和核心类

Java线程池主要由以下4个核心组件组成。

- 线程池管理器：用于创建并管理线程池。
- 工作线程：线程池中执行具体任务的线程。
- 任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。
- 任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。

Java中的线程池是通过Executor框架实现的，在该框架中用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类。

其中，ThreadPoolExecutor是构建线程的核心方法，该方法的定义如下：

```
public ThreadPoolExecutor(int corePoolSize,int maxinumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)
	this(corePoolSize,maxinumPoolSize,keepAliveTime,unit,workQueue,Executors.defaultThreadFactory(),defaultHandler);
```

### ThreadPoolExecutor构造函数的具体参数

- corePoolSize:线程池中核心线程的数量
- maxinumPoolSize：线程池中最大线程的数量
- keepAliveTime：当前线程数量超过corePoolSize时，空闲线程的存活时间
- unit：keepAliveTime的时间单位
- workQueue：任务队列，被提交但尚未被执行的任务存放的地方
- threadFactory：线程工程，用于创建线程，可使用默认的线程工厂或自定义线程工厂
- handler：由于任务过多或其他原因导致线程池无法处理时的任务拒接策略

## 9.Java线程池的工作流程

Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。

- 如果正在运行的线程数量少于corePoolSize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务。
- 如果正在运行的线程数量大于等于corePoolSize，该任务就将被放入阻塞队列中。
- 在阻塞队列已满且正在运行的线程数量少于maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小。

## 10.线程池的拒绝策略

若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这 4种，默认的拒绝策略在ThreadPoolExecutor中作为内部类提供。在默认的拒绝策略不能满足应用的需求时，可以自定义拒绝策略。

### AbortPolicy

AbortPolicy直接抛出异常，阻止线程正常运行。

### CallerRunsPolicy

CallerRunsPolicy的拒绝策略为：如果被丢弃的线程任务未关闭，则执行该线程任务。注意，CallerRunsPolicy拒绝策略不会真的丢弃任务。

### DiscardOldestPolicy

DiscardOldestPolicy的拒绝策略为：移除线程队列中最早的一个线程任务，并尝试提交当前任务。

### DiscardPolicy

DiscardPolicy的拒绝策略为：丢弃当前的线程任务而不做任何处理。如果系统允许在资源不足的情况下丢弃部分任务，则这将是保障系统安全、稳定的一种很好的方案。

### 自定义拒绝策略

以上4种拒绝策略均实现了RejectedExecutionHandler接口，若无法满足实际需要，则用户可以自己扩展RejectedExecutionHandler接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略。下面实现一个自定义拒绝策略DiscardOldestNPolicy，该策略根据传入的参数丢弃最老的N个线程，以便在出现异常时释放更多的资源，保障后续线程任务整体、稳定地运行。

## 11.5种常用的线程池

Java定义了Executor接口并在该接口中定义了execute()用于执行一个线程任务，然后通过ExecutorService实现Executor接口并执行具体的线程操作。ExecutorService接口有多个实现类可用于创建不同的线程池。

- newCachedThreadPool：可缓存的线程池
- newFixedThreadPool：固定大小的线程池
- newScheduledThreadPool：可做任务调度的线程池
- newSingleThreadExecutor：单个线程的线程池
- newWorkStealingPool：足够大小的线程池

## 12.newCachedThreadPool

newCachedThreadPool用于创建一个缓存线程池。之所以叫缓存线程池，是因为它在创建新线程时如果有可重用的线程，则重用它们，否则重新创建一个新的线程并将其添加到线程池中。对于执行时间很短的任务而言，newCachedThreadPool线程池能很大程度地重用线程进而提高系统的性能。

在线程池的keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程任务运行时，newCachedThreadPool将不会占用系统的线程资源。

在创建线程时需要执行申请CPU和内存、记录线程状态、控制阻塞等多项工作，复杂且耗时。因此，在有执行时间很短的大量任务需要执行的情况下，newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。具体的创建方式如下：

```
ExecutorService cachedThreadPool=Executors.newCachedThreadPool();
```

## 13.newFixedThreadPool

newFixedThreadPool用于创建一个固定线程数量的线程池，并将线程资源存放在队列中循环使用。在newFixedThreadPool线程池中，若处于活动状态的线程数量大于等于核心线程池的数量，则新提交的任务将在阻塞队列中排队，直到有可用的线程资源，具体的创建方式如下：

```
ExecutorService fixedThreadPool=Executors.newFixedThreadPool(5);
```

## 14.newScheduledThreadPool

newScheduledThreadPool创建了一个可定时调度的线程池，可设置在给定的延迟时间后执行或者定期执行某个线程任务：

```
ScheduledExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(3);
//创建一个延迟3秒执行的线程
scheduledThreadPool.schedule(new Runnable(){
	@Override
	public void run(){		
	}
},3,TimeUnit.SECONDS);
//创建一个延迟1秒执行且每3秒执行一次的线程
scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
	@Override
	public void run(){		
	}
},1,3,TimeUnit.SECONDS);
```

## 15.newSingleThreadExecutor

newSingleThreadExecutor线程池会保证永远有且只有一个可用的线程，在该线程停止或发生异常时，newSingleThreadExecutor线程池会启动一个新的线程来代替该线程继续执行任务：

```
ExecutorService singleThread=Executors.newSingleThreadExecutor();
```

## 16.newWorkStealingPool

JDK1.8新增。

newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。这里所说的有足够的线程指JDK根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU资源估算并行度的过程。当然，如果开发者想自己定义线程的并发数，则也可以将其作为参数传入。

## 17.线程的生命周期

线程的生命周期分为新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）这5种状态。在系统运行过程中不断有新的线程被创建，旧的线程在执行完毕后被清理，线程在排队获取共享资源或者锁时将被阻塞，因此运行中的线程会在就绪、阻塞、运行状态之间来回切换。

![](D:\workspace\Java-Interview-Offer\images\并发编程001.png)

其流程如下所述。

（1）调用new方法新建一个线程，这时线程处于新建状态。

（2）调用start方法启动一个线程，这时线程处于就绪状态。

（3）处于就绪状态的线程等待线程获取CPU资源，在等待其获取CPU资源后线程会执行run方法进入运行状态。

（4）正在运行的线程在调用了yield方法或失去处理器资源时，会再次进入就绪状态。

（5）正在执行的线程在执行了sleep方法、I/O阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入阻塞状态，进入Blocked池。

（6）阻塞状态的线程由于出现sleep时间已到、I/O方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入就绪状态，等待CPU时间片的轮询。该线程在获取CPU资源后，会再次进入运行状态。

（7）处于运行状态的线程，在调用run方法或call方法正常执行完成、调用stop方法停止线程或者程序执行错误导致异常退出时，会进入死亡状态。

### 新建状态：New

在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是为线程分配内存并初始化其成员变量的值。

### 就绪状态：Runnable

新建的线程对象在调用start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行。

### 运行状态：Running

就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

### 阻塞状态：Blocked

运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

（1）等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（Waitting Queue）中，线程转为阻塞状态。

（2）同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（Lock Pool）中，此时线程转为阻塞状态。

（3）其他阻塞：运行状态的线程在执行Thread.sleep(long ms)、Thread.join()或者发出I/O请求时，JVM会把该线程转为阻塞状态。直到sleep()状态超时、Thread.join()等待线程终止或超时，或者I/O处理完毕，线程才重新转为可运行状态。

### 线程死亡：Dead

线程在以下面三种方式结束后转为死亡状态。

- 线程正常结束：run方法或call方法执行完成。
- 线程异常退出：运行中的线程抛出一个Error或未捕获的Exception，线程异常退出。
- 手动结束：调用线程对象的stop方法手动结束运行中的线程（该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用）。

## 18.线程的基本方法

线程相关的基本方法有wait、notify、notifyAll、sleep、join、yield等，这些方法控制线程的运行，并影响线程的状态变化。

### 线程等待：wait方法

调用wait方法的线程会进入WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

### 线程睡眠：sleep方法

调用sleep方法会导致当前线程休眠。与wait方法不同的是，sleep方法不会释放当前占有的锁，会导致线程进入TIMED-WATING状态，而wait方法会导致当前线程进入WATING状态。

### 线程让步：yield方法

调用yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

### 线程中断：interrupt方法

interrupt方法用于向线程发行一个终止通知信号，会影响该线程内部的一个中断标识位，这个线程本身并不会因为调用了interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对interrupt方法的理解需要注意以下4个核心点。

- 调用interrupt方法并不会中断一个正在运行的线程，也就是说处于Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
- 若因为调用sleep方法而使线程处于TIMED-WATING状态，则这时调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WATING状态。
- 许多声明抛出InterruptedException的方法如Thread.sleep(longmills)，在抛出异常前都会清除中断标识位，所以在抛出异常后调用isInterrupted方法将会返回false。
- 中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如，在想终止一个线程时，可以先调用该线程的interrupt方法，然后在线程的run方法中根据该线程isInterrupted方法的返回状态值安全终止线程。

### 线程加入：join方法

join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法。

### 线程唤醒：notify方法

Object类有个notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。

我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有notifyAll，用于唤醒在监视器上等待的所有线程。

### 后台守护线程：setDaemon方法

setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。

守护线程的优先级较低，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程对象创建之前用线程对象的setDaemon(true)来设置。

在后台守护线程中定义的线程也是后台守护线程。后台守护线程是JVM级别的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。

守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程不依赖于终端，但是依赖于JVM，与JVM“同生共死”。在JVM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![](D:\workspace\Java-Interview-Offer\images\并发编程002.png)

## 19.sleep方法与wait方法的区别

sleep方法与wait方法的区别如下。

- sleep方法属于Thread类，wait方法则属于Object类。
- sleep方法暂停执行指定的时间，让出CPU 给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复运行状态。
- 在调用sleep方法的过程中，线程不会释放对象锁。
- 在调用wait方法时，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象调用notify方法后，该线程才能进入对象锁池准备获取对象锁，并进入运行状态。

## 20.start方法与run方法的区别

start方法与run方法的区别如下。

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法后，线程会在后台执行，无须等待run方法体的代码执行完毕，就可以继续执行下面的代码。
- 在通过调用Thread类的start方法启动一个线程时，此线程处于就绪状态，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码。在run方法运行结束后，该线程终止，CPU再调度其他线程。

## 21.终止线程的4种方式

### 正常运行结束

指线程体执行完成，线程自动结束。

### 使用退出标志退出线程

在一般情况下，在run方法执行完毕时，线程会正常结束。然而，有些线程是后台线程，需要长时间运行，只有在系统满足某些特殊条件后，才能触发关闭这些线程。这时可以使用一个变量来控制循环，比如设置一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，具体的实现代码如下：

```
public class ThreadSafe extends Thread{
	public volatile boolean exit=false;
    public void run(){
    	while(!exit){
    		//执行业务逻辑代码
    	}
    }
}
```

以上代码在线程中定义了一个退出标志exit，exit的默认值为false。在定义exit时使用了一个Java关键字volatile，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时，while循环退出。

### 使用Interrupt方法终止线程

使用interrupt方法终止线程有以下两种情况。

（1）线程处于阻塞状态。例如，在使用了sleep、调用锁的wait或者调用socket的receiver、accept等方法时，会使线程处于阻塞状态。在调用线程的interrupt方法时，会抛出InterruptException异常。我们通过代码捕获该异常，然后通过break跳出状态检测循环，可以有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法就会结束线程，这实际上理解有误，一定要先捕获InterruptedException异常再通过break跳出循环，才能正常结束run方法。具体的实现代码如下：

```
public class ThreadSafe extends Thread{
    public void run(){
    	while(!isInterrupted()){//在非阻塞过程中通过判断中断标志来推出
    		try{
    			Thread.sleep(5*1000);//在阻塞过程中捕获中断异常来退出
    		}catch(InterruptedException e){
    			e.printStackTrace();
    			break;//在捕获到异常后执行break跳出循环
    		}
    	}
    }
}
```

（2）线程未处于阻塞状态。此时，使用isInterrupted方法判断线程的中断标志来退出循环。在调用interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

### 使用stop方法终止线程：不安全

在程序中可以直接调用Thread.stop方法强行终止线程，但这是很危险的，就像突然关闭计算机的电源，而不是正常关机一样，可能会产生不可预料的后果。

在程序使用Thread.stop方法终止线程时，该线程的子线程会抛出ThreadDeatherror错误，并且释放子线程持有的所有锁。加锁的代码块一般被用于保护数据的一致性，如果在调用Thread.stop方法后导致该线程所持有的所有锁突然释放而使锁资源不可控制，被保护的数据就可能出现不一致的情况，其他线程在使用这些被破坏的数据时，有可能使程序运行错误。因此，并不推荐采用这种方法终止线程。

## 22.线程上下文切换

CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。任务的状态保存及再加载就叫作线程的上下文切换。

- 进程：指一个运行中的程序的实例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一地址空间（一段内存区域）和其他资源。
- 上下文：指线程切换时CPU寄存器和程序计数器所保存的当前线程的信息。
- 寄存器：指CPU 内部容量较小但速度很快的内存区域（与之对应的是CPU 外部相对较慢的RAM主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来加快计算机程序运行的速度。
- 程序计数器：是一个专用的寄存器，用于表明指令序列中CPU 正在执行的位置，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。

## 23.上下文切换

上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在进程控制块（PCB-ProcessControl Block）中。PCB又被称作切换桢（SwitchFrame）。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。上下文的切换流程如下。

（1）挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB中。

（2）在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。

（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程。

时间片轮转方式使多个任务在同一CPU上的执行有了可能.

## 24.引起线程上下文切换的原因

- 当前正在执行的任务完成，系统的CPU正常调度下一个任务。
- 当前正在执行的任务遇到I/O 等阻塞操作，调度器挂起此任务，继续调度下一个任务。
- 多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。
- 用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。
- 硬件中断。

## 25.多线程如何共享数据

在Java中进行多线程通信主要是通过共享内存实现的，共享内存主要有三个关注点：可见性、有序性、原子性。Java内存模型（JVM）解决了可见性和有序性的问题，而锁解决了原子性的问题。在理想情况下，我们希望做到同步和互斥来实现数据在多线程环境下的一致性和安全性。常用的实现多线程数据共享的方式有将数据抽象成一个类，并将对这个数据的操作封装在类的方法中；将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量。

### 将数据抽象成一个类，并将对这个数据的操作封装在类的方法中

这种方式只需要在方法上加synchronized关键字即可做到数据的同步。

在应用时需要注意的是，如果两个线程AddRunnable和DecRunnable需要保证数据操作的原子性和一致性，就必须在传参时使用同一个data对象入参。这样无论启动多少个线程执行对data数据的操作，都能保证数据的一致性。

### 将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量

将Runnable对象作为类的内部类，将共享数据作为这个类的成员变量，每个线程对共享数据的操作方法都被封装在该类的外部类中，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。

## 26.线程调度

### 抢占式调度

抢占式调度指每个线程都以抢占的方式获取CPU资源并快速执行，在执行完毕后立刻释放CPU资源，具体哪些线程能抢占到CPU资源由操作系统控制，在抢占式调度模式下，每个线程对CPU资源的申请地位是相等，从概率上讲每个线程都有机会获得同样的CPU执行时间片并发执行。抢占式调度适用于多线程并发执行的情况，在这种机制下一个线程的堵塞不会导致整个进程性能下降。

### 协同式调度

协同式调度指某一个线程在执行完后主动通知操作系统将CPU资源切换到另一个线程上执行。线程对CPU的持有时间由线程自身控制，线程切换更加透明，更适合多个线程交替执行某些任务的情况。

协同式调度有一个缺点：如果其中一个线程因为外部原因（可能是磁盘I/O阻塞、网络I/O阻塞、请求数据库等待）运行阻塞，那么可能导致整个系统阻塞甚至崩溃。

## 27.Java线程调度的实现：抢占式

Java采用抢占式调度的方式实现内部的线程调度，Java会为每个线程都按照优先级高低分配不同的CPU时间片，且优先级高的线程优先执行。优先级低的线程只是获取CPU时间片的优先级被降低，但不会永久分配不到CPU时间片。Java的线程调度在保障效率的前提下尽可能保障线程调度的公平性。

## 28.线程让出CPU的情况

线程让出CPU的情况如下。

- 当前运行的线程主动放弃CPU，例如运行中的线程调用yield()放弃CPU 的使用权。
- 当前运行的线程进入阻塞状态，例如调用文件读取I/O 操作、锁等待、Socket等待。
- 当前线程运行结束，即运行完run()里面的任务。

## 29.进程调度算法

进程调度算法包括优先调度算法、高优先权优先调度算法和基于时间片的轮转调度算法。其中，优先调度算法分为先来先服务调度算法和短作业优先调度算法；高优先权优先调度算法分为非抢占式优先权算法、抢占式优先权调度算法和高响应比优先调度算法。基于时间片的轮转调度算法分为时间片轮转算法和多级反馈队列调度算法。

### 优先调度算法

进程调度算法包括优先调度算法、高优先权优先调度算法和基于时间片的轮转调度算法。其中，优先调度算法分为先来先服务调度算法和短作业优先调度算法；高优先权优先调度算法分为非抢占式优先权算法、抢占式优先权调度算法和高响应比优先调度算法。基于时间片的轮转调度算法分为时间片轮转算法和多级反馈队列调度算法。

## 30.优先调度算法

优先调度算法包含先来先服务调度算法和短作业（进程）优先调度算法。1.

### 先来先服务调度算法

先来先服务调度算法指每次调度时都从队列中选择一个或多个最早进入该队列的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时会从就绪队列中选择一个最早进入队列的进程，为其分配CPU资源并运行。该算法优先运行最早进入的任务，实现简单且相对公平。

### 短作业优先调度算法

短作业优先调度算法指每次调度时都从队列中选择一个或若干个预估运行时间最短的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时，会从就绪队列中选出一个预估运行时间最短的进程，为其分配CPU资源并运行。该算法优先运行短时间作业，以提高CPU整体的利用率和系统运行效率，某些大任务可能会出现长时间得不到调度的情况。

## 31.高优先权优先调度算法

高优先权优先调度算法在定义任务的时候为每个任务都设置不同的优先权，在进行任务调度时优先权最高的任务首先被调度，这样资源的分配将更加灵活，具体包含非抢占式优先调度算法、抢占式优先调度算法和高响应比优先调度算法。

### 非抢占式优先调度算法

非抢占式优先调度算法在每次调度时都从队列中选择一个或多个优先权最高的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时会从就绪队列中选出一个优先权最高的进程，为其分配CPU资源并运行。进程在运行过程中一直持有该CPU，直到进程执行完毕或发生异常而放弃该CPU。该算法优先运行优先权高的作业，且一旦将CPU分配给某个进程，就不会主动回收CPU资源，直到任务主动放弃。

### 抢占式优先调度算法

抢占式优先调度算法首先把CPU资源分配给优先权最高的任务并运行，但如果在运行过程中出现比当前运行任务优先权更高的任务，调度算法就会暂停运行该任务并回收CPU资源，为其分配新的优先权更高的任务。该算法真正保障了CPU在整个运行过程中完全按照任务的优先权分配资源，这样如果临时有紧急作业，则也可以保障其第一时间被执行。

### 高响应比优先调度算法

高响应比优先调度算法使用了动态优先权的概念，即任务的执行时间越短，其优先权越高，任务的等待时间越长，优先权越高，这样既保障了快速、并发地执行短作业，也保障了优先权低但长时间等待的任务也有被调度的可能性。

该优先权的变化规律如下。

- 在作业的等待时间相同时，运行时间越短，优先权越高，在这种情况下遵循的是短作业优先原则。
- 在作业的运行时间相同时，等待时间越长，优先权越高，在这种情况下遵循的是先来先服务原则。
- 作业的优先权随作业等待时间的增加而不断提高，加大了长作业获取CPU 资源的可能性。

高响应比优先调度算法在保障效率（短作业优先能在很大程度上提高CPU的使用率和系统性能）的基础上尽可能提高了调度的公平性（随着任务等待时间的增加，优先权提高，遵循了先来先到原则）。

## 32.时间片的轮转调度算法

时间片的轮转调度算法将CPU资源分成不同的时间片，不同的时间片为不同的任务服务，具体包括时间片轮转法和多级反馈队列调度算法。

### 时间片轮转法

时间片轮转法指按照先来先服务原则从就绪队列中取出一个任务，并为该任务分配一定的CPU时间片去运行，在进程使用完CPU时间片后由一个时间计时器发出时钟中断请求，调度器在收到时钟中断请求信号后停止该进程的运行并将该进程放入就绪队列的队尾，然后从就绪队列的队首取出一个任务并为其分配CPU时间片去执行。这样，就绪队列中的任务就将轮流获取一定的CPU时间片去运行。

### 多级反馈队列调度算法

多级反馈队列调度算法在时间片轮询算法的基础上设置多个就绪队列，并为每个就绪队列都设置不同的优先权。队列的优先权越高，队列中的任务被分配的时间片就越大。默认第一个队列优先权最高，其他次之。

多级反馈队列调度算法的调度流程为：在系统收到新的任务后，首先将其放入第一个就绪队列的队尾，按先来先服务调度算法排队等待调度。若该进程在规定的CPU时间片内运行完成或者运行过程中出现错误，则退出进程并从系统中移除该任务；如果该进程在规定的CPU时间片内未运行完成，则将该进程转入第2队列的队尾调度执行；如果该进程在第2队列中运行一个CPU时间片后仍未完成，则将其放入第3队列，以此类推，在一个长作业从第1队列依次降到第n队列后，在第n队列中便以时间片轮转的方式运行。

多级反馈队列调度算法遵循以下原则。

- 仅在第一个队列为空时，调度器才调度第2队列中的任务。
- 仅在第1～(n-1)队列均为空时，调度器才会调度第n队列中的进程。
- 如果处理器正在为第n队列中的某个进程服务，此时有新进程进入优先权较高的队列（第1～(n-1)中的任何一个队列），则此时新进程将抢占正在运行的进程的处理器，即调度器停止正在运行的进程并将其放回第 n 队列的末尾，把处理器分配给新来的高优先权进程。

 队列的末尾，把处理器分配给新来的高优先权进程。多级反馈调度算法相对来说比较复杂，它充分考虑了先来先服务调度算法和时间片轮询算法的优势，使得对进程的调度更加合理。