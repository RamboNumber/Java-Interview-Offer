# 并发编程

多线程能够在操作系统多核配置的基础上，能够更好地利用服务器的多个CPU资源，使程序运行起来更加高效。Java通过提供对多线程的支持来在一个进程内并发执行多个线程，每个线程都并行执行不同的任务，以满足编写高效率程序的要求。

## 1.Java线程的创建方式

- 继承Thread类
- 实现Runnable接口
- 通过ExecutorService和Callable<Class>实现有返回值的线程
- 基于线程池

## 2.继承Thread类

Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程。具体实现为创建一个类并继承Thread接口，然后实例化线程对象并调用start方法启动线程。start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。run方法内的代码是线程类的具体实现逻辑。

```
//通过继承Thread类创建NewThread线程
public class NewThread extends Thread{
	public void run(){
	
	}
} 
//实例化一个线程对象
NewThread newThread=new NewThread();
//调用start方法启动线程
newThread.start();
```

以上代码定义了一个名为NewThread的线程类，该类继承了Thread，run方法内的代码为线程的具体执行逻辑，在使用该线程时只需新建一个该线程的对象并调用其start方法即可。

## 3.实现Runnable接口

基于Java编程语言的规范，如果子类已经继承（extends）了一个类，就无法再直接继承Thread类，此时可以通过实现Runnable接口创建线程。具体的实现过程为：通过实现Runnable接口创建ChildrenClassThread线程，实例化名称为childrenThread的线程实例，创建Thread类的实例并传入childrenThread线程实例，调用线程的start方法启动线程。具体的实现代码如下：

```
//通过继承Thread类创建NewThread线程
public class ChildrenClassThread extends SuperClass implements Runnable{
	public void run(){
	
	}
} 
//实例化一个ChildrenClassThread对象
ChildrenClassThread childrenThread=new ChildrenClassThread();
//创建一个线程对象并将其传入已经实例化好的childrenThread实例
Thread thread=new Thread(childrenThread);
//调用start方法启动线程
thread.start();
```

在传入一个实现了Runnable的线程实例target给Thread后，Thread的run方法在执行时就会调用target.run方法并执行该线程具体的实现逻辑。在JDK源码中，run方法的实现代码如下：

```
@Override
public void run(){
	if(target!=null){
		target.run();
	}
}
```

## 4.通过ExecutorService和Callable<Class>实现有返回值的线程

有时，我们需要在主线程中开启多个线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。具体的实现方法为：创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。具体的调用过程为：创建一个线程池、一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历Future List中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果，实现代码如下：

```
//实现Callable接口创建MyCallable线程
public class MyCallable implements Callable<String>{
	private String name;
	public MyCallable(String name){//通过构造函数为线程传递参数，以定义线程名称
		this.name=name;
	}
	@Override
	public String call() throws Exception{//call方法内为线程实现逻辑
		return name;
	}
}
	//创建一个固定大小为5的线程池
	ExecutorService pool=Executors.newFixedThreadPool(5);
	//创建有多个返回值的任务列表List
	List<Future> list=new ArrayList<Future>();
	for(int i=0;i<5;i++){
		//创建一个有返回值的线程实例
		Callable c=new MyCallable(i+"");
		//提交线程，获取Future对象并将其保存到Future List
        Future future=pool.submit(c);
        list.add(future);
	}
	//关闭线程池，等待线程执行结束
	pool.shutdown();
}
```

## 5.基于线程池

线程是非常宝贵的计算资源，在每次需要时创建并在运行结束后销毁是非常浪费资源的。我们可以使用缓存策略并使用线程池来创建线程，具体过程为创建一个线程池并用该线程池提交线程任务，实现代码如下：

```
//创建大小为10的线程池
ExecutorService pool=Executors.newFixedThreadPool(10);
for(int i=0;i<10;i++){
	//提交多个线程任务并执行
	pool.execute(new Runnable(){
		@Override
		public void run(){
		
		}
	});
}
```

## 6.线程池的工作原理

Java线程池主要用于管理线程组及其运行状态，以便Java虚拟机更好地利用CPU资源。Java线程池的工作原理为：JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果线程数量超过了最大线程数量（用户设置的线程池大小），则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。

线程池的主要作用是线程复用、线程资源管理、控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）地运行。

## 7.线程复用

在Java中，每个Thread类都有一个start方法。在程序调用start方法启动线程时，Java虚拟机会调用该类的run方法。前面说过，在Thread类的run方法中其实调用了Runnable对象的run方法，因此可以继承Thread类，在start方法中不断循环调用传递进来的Runnable对象，程序就会不断执行run方法中的代码。可以将在循环方法中不断获取的Runnable对象存放在Queue中，当前线程在获取下一个Runnable对象之前可以是阻塞的，这样既能有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行。这样就简单实现了一个线程池，达到了线程复用的效果。

## 8.线程池的核心组件和核心类

Java线程池主要由以下4个核心组件组成。

- 线程池管理器：用于创建并管理线程池。
- 工作线程：线程池中执行具体任务的线程。
- 任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。
- 任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。

Java中的线程池是通过Executor框架实现的，在该框架中用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类。

其中，ThreadPoolExecutor是构建线程的核心方法，该方法的定义如下：

```
public ThreadPoolExecutor(int corePoolSize,int maxinumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)
	this(corePoolSize,maxinumPoolSize,keepAliveTime,unit,workQueue,Executors.defaultThreadFactory(),defaultHandler);
```

### ThreadPoolExecutor构造函数的具体参数

- corePoolSize:线程池中核心线程的数量
- maxinumPoolSize：线程池中最大线程的数量
- keepAliveTime：当前线程数量超过corePoolSize时，空闲线程的存活时间
- unit：keepAliveTime的时间单位
- workQueue：任务队列，被提交但尚未被执行的任务存放的地方
- threadFactory：线程工程，用于创建线程，可使用默认的线程工厂或自定义线程工厂
- handler：由于任务过多或其他原因导致线程池无法处理时的任务拒接策略

## 9.Java线程池的工作流程

Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。

- 如果正在运行的线程数量少于corePoolSize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务。
- 如果正在运行的线程数量大于等于corePoolSize，该任务就将被放入阻塞队列中。
- 在阻塞队列已满且正在运行的线程数量少于maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小。

## 10.线程池的拒绝策略

若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这 4种，默认的拒绝策略在ThreadPoolExecutor中作为内部类提供。在默认的拒绝策略不能满足应用的需求时，可以自定义拒绝策略。

### AbortPolicy

AbortPolicy直接抛出异常，阻止线程正常运行。

### CallerRunsPolicy

CallerRunsPolicy的拒绝策略为：如果被丢弃的线程任务未关闭，则执行该线程任务。注意，CallerRunsPolicy拒绝策略不会真的丢弃任务。

### DiscardOldestPolicy

DiscardOldestPolicy的拒绝策略为：移除线程队列中最早的一个线程任务，并尝试提交当前任务。

### DiscardPolicy

DiscardPolicy的拒绝策略为：丢弃当前的线程任务而不做任何处理。如果系统允许在资源不足的情况下丢弃部分任务，则这将是保障系统安全、稳定的一种很好的方案。

### 自定义拒绝策略

以上4种拒绝策略均实现了RejectedExecutionHandler接口，若无法满足实际需要，则用户可以自己扩展RejectedExecutionHandler接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略。下面实现一个自定义拒绝策略DiscardOldestNPolicy，该策略根据传入的参数丢弃最老的N个线程，以便在出现异常时释放更多的资源，保障后续线程任务整体、稳定地运行。

## 11.5种常用的线程池

Java定义了Executor接口并在该接口中定义了execute()用于执行一个线程任务，然后通过ExecutorService实现Executor接口并执行具体的线程操作。ExecutorService接口有多个实现类可用于创建不同的线程池。

- newCachedThreadPool：可缓存的线程池
- newFixedThreadPool：固定大小的线程池
- newScheduledThreadPool：可做任务调度的线程池
- newSingleThreadExecutor：单个线程的线程池
- newWorkStealingPool：足够大小的线程池

## 12.newCachedThreadPool

newCachedThreadPool用于创建一个缓存线程池。之所以叫缓存线程池，是因为它在创建新线程时如果有可重用的线程，则重用它们，否则重新创建一个新的线程并将其添加到线程池中。对于执行时间很短的任务而言，newCachedThreadPool线程池能很大程度地重用线程进而提高系统的性能。

在线程池的keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程任务运行时，newCachedThreadPool将不会占用系统的线程资源。

在创建线程时需要执行申请CPU和内存、记录线程状态、控制阻塞等多项工作，复杂且耗时。因此，在有执行时间很短的大量任务需要执行的情况下，newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。具体的创建方式如下：

```
ExecutorService cachedThreadPool=Executors.newCachedThreadPool();
```

## 13.newFixedThreadPool

newFixedThreadPool用于创建一个固定线程数量的线程池，并将线程资源存放在队列中循环使用。在newFixedThreadPool线程池中，若处于活动状态的线程数量大于等于核心线程池的数量，则新提交的任务将在阻塞队列中排队，直到有可用的线程资源，具体的创建方式如下：

```
ExecutorService fixedThreadPool=Executors.newFixedThreadPool(5);
```

## 14.newScheduledThreadPool

newScheduledThreadPool创建了一个可定时调度的线程池，可设置在给定的延迟时间后执行或者定期执行某个线程任务：

```
ScheduledExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(3);
//创建一个延迟3秒执行的线程
scheduledThreadPool.schedule(new Runnable(){
	@Override
	public void run(){		
	}
},3,TimeUnit.SECONDS);
//创建一个延迟1秒执行且每3秒执行一次的线程
scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
	@Override
	public void run(){		
	}
},1,3,TimeUnit.SECONDS);
```

## 15.newSingleThreadExecutor

newSingleThreadExecutor线程池会保证永远有且只有一个可用的线程，在该线程停止或发生异常时，newSingleThreadExecutor线程池会启动一个新的线程来代替该线程继续执行任务：

```
ExecutorService singleThread=Executors.newSingleThreadExecutor();
```

## 16.newWorkStealingPool

JDK1.8新增。

newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。这里所说的有足够的线程指JDK根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU资源估算并行度的过程。当然，如果开发者想自己定义线程的并发数，则也可以将其作为参数传入。

## 17.线程的生命周期

线程的生命周期分为新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）这5种状态。在系统运行过程中不断有新的线程被创建，旧的线程在执行完毕后被清理，线程在排队获取共享资源或者锁时将被阻塞，因此运行中的线程会在就绪、阻塞、运行状态之间来回切换。

![](D:\workspace\Java-Interview-Offer\images\并发编程001.png)

其流程如下所述。

（1）调用new方法新建一个线程，这时线程处于新建状态。

（2）调用start方法启动一个线程，这时线程处于就绪状态。

（3）处于就绪状态的线程等待线程获取CPU资源，在等待其获取CPU资源后线程会执行run方法进入运行状态。

（4）正在运行的线程在调用了yield方法或失去处理器资源时，会再次进入就绪状态。

（5）正在执行的线程在执行了sleep方法、I/O阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入阻塞状态，进入Blocked池。

（6）阻塞状态的线程由于出现sleep时间已到、I/O方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入就绪状态，等待CPU时间片的轮询。该线程在获取CPU资源后，会再次进入运行状态。

（7）处于运行状态的线程，在调用run方法或call方法正常执行完成、调用stop方法停止线程或者程序执行错误导致异常退出时，会进入死亡状态。

### 新建状态：New

在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是为线程分配内存并初始化其成员变量的值。

### 就绪状态：Runnable

新建的线程对象在调用start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行。

### 运行状态：Running

就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

### 阻塞状态：Blocked

运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

（1）等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（Waitting Queue）中，线程转为阻塞状态。

（2）同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（Lock Pool）中，此时线程转为阻塞状态。

（3）其他阻塞：运行状态的线程在执行Thread.sleep(long ms)、Thread.join()或者发出I/O请求时，JVM会把该线程转为阻塞状态。直到sleep()状态超时、Thread.join()等待线程终止或超时，或者I/O处理完毕，线程才重新转为可运行状态。

### 线程死亡：Dead

线程在以下面三种方式结束后转为死亡状态。

- 线程正常结束：run方法或call方法执行完成。
- 线程异常退出：运行中的线程抛出一个Error或未捕获的Exception，线程异常退出。
- 手动结束：调用线程对象的stop方法手动结束运行中的线程（该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用）。

## 18.线程的基本方法

线程相关的基本方法有wait、notify、notifyAll、sleep、join、yield等，这些方法控制线程的运行，并影响线程的状态变化。

### 线程等待：wait方法

调用wait方法的线程会进入WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

### 线程睡眠：sleep方法

调用sleep方法会导致当前线程休眠。与wait方法不同的是，sleep方法不会释放当前占有的锁，会导致线程进入TIMED-WATING状态，而wait方法会导致当前线程进入WATING状态。

### 线程让步：yield方法

调用yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

### 线程中断：interrupt方法

interrupt方法用于向线程发行一个终止通知信号，会影响该线程内部的一个中断标识位，这个线程本身并不会因为调用了interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对interrupt方法的理解需要注意以下4个核心点。

- 调用interrupt方法并不会中断一个正在运行的线程，也就是说处于Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
- 若因为调用sleep方法而使线程处于TIMED-WATING状态，则这时调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WATING状态。
- 许多声明抛出InterruptedException的方法如Thread.sleep(longmills)，在抛出异常前都会清除中断标识位，所以在抛出异常后调用isInterrupted方法将会返回false。
- 中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如，在想终止一个线程时，可以先调用该线程的interrupt方法，然后在线程的run方法中根据该线程isInterrupted方法的返回状态值安全终止线程。

### 线程加入：join方法

join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法。

### 线程唤醒：notify方法

Object类有个notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。

我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有notifyAll，用于唤醒在监视器上等待的所有线程。

### 后台守护线程：setDaemon方法

setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。

守护线程的优先级较低，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程对象创建之前用线程对象的setDaemon(true)来设置。

在后台守护线程中定义的线程也是后台守护线程。后台守护线程是JVM级别的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。

守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程不依赖于终端，但是依赖于JVM，与JVM“同生共死”。在JVM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![](D:\workspace\Java-Interview-Offer\images\并发编程002.png)

## 19.sleep方法与wait方法的区别

sleep方法与wait方法的区别如下。

- sleep方法属于Thread类，wait方法则属于Object类。
- sleep方法暂停执行指定的时间，让出CPU 给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复运行状态。
- 在调用sleep方法的过程中，线程不会释放对象锁。
- 在调用wait方法时，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象调用notify方法后，该线程才能进入对象锁池准备获取对象锁，并进入运行状态。

## 20.start方法与run方法的区别

start方法与run方法的区别如下。

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法后，线程会在后台执行，无须等待run方法体的代码执行完毕，就可以继续执行下面的代码。
- 在通过调用Thread类的start方法启动一个线程时，此线程处于就绪状态，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码。在run方法运行结束后，该线程终止，CPU再调度其他线程。

## 21.终止线程的4种方式

### 正常运行结束

指线程体执行完成，线程自动结束。

### 使用退出标志退出线程

在一般情况下，在run方法执行完毕时，线程会正常结束。然而，有些线程是后台线程，需要长时间运行，只有在系统满足某些特殊条件后，才能触发关闭这些线程。这时可以使用一个变量来控制循环，比如设置一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，具体的实现代码如下：

```
public class ThreadSafe extends Thread{
	public volatile boolean exit=false;
    public void run(){
    	while(!exit){
    		//执行业务逻辑代码
    	}
    }
}
```

以上代码在线程中定义了一个退出标志exit，exit的默认值为false。在定义exit时使用了一个Java关键字volatile，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时，while循环退出。

### 使用Interrupt方法终止线程

使用interrupt方法终止线程有以下两种情况。

（1）线程处于阻塞状态。例如，在使用了sleep、调用锁的wait或者调用socket的receiver、accept等方法时，会使线程处于阻塞状态。在调用线程的interrupt方法时，会抛出InterruptException异常。我们通过代码捕获该异常，然后通过break跳出状态检测循环，可以有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法就会结束线程，这实际上理解有误，一定要先捕获InterruptedException异常再通过break跳出循环，才能正常结束run方法。具体的实现代码如下：

```
public class ThreadSafe extends Thread{
    public void run(){
    	while(!isInterrupted()){//在非阻塞过程中通过判断中断标志来推出
    		try{
    			Thread.sleep(5*1000);//在阻塞过程中捕获中断异常来退出
    		}catch(InterruptedException e){
    			e.printStackTrace();
    			break;//在捕获到异常后执行break跳出循环
    		}
    	}
    }
}
```

（2）线程未处于阻塞状态。此时，使用isInterrupted方法判断线程的中断标志来退出循环。在调用interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

### 使用stop方法终止线程：不安全

在程序中可以直接调用Thread.stop方法强行终止线程，但这是很危险的，就像突然关闭计算机的电源，而不是正常关机一样，可能会产生不可预料的后果。

在程序使用Thread.stop方法终止线程时，该线程的子线程会抛出ThreadDeatherror错误，并且释放子线程持有的所有锁。加锁的代码块一般被用于保护数据的一致性，如果在调用Thread.stop方法后导致该线程所持有的所有锁突然释放而使锁资源不可控制，被保护的数据就可能出现不一致的情况，其他线程在使用这些被破坏的数据时，有可能使程序运行错误。因此，并不推荐采用这种方法终止线程。

## 22.Java中的锁

Java中的锁主要用于保障多并发线程情况下数据的一致性。在多线程编程中为了保障数据的一致性，我们通常需要在使用对象或者方法之前加锁，这时如果有其他线程也需要使用该对象或者该方法，则首先要获得锁，如果某个线程发现锁正在被其他线程使用，就会进入阻塞队列等待锁的释放，直到其他线程执行完成并释放锁，该线程才有机会再次获取锁进行操作。这样就保障了在同一时刻只有一个线程持有该对象的锁并修改对象，从而保障数据的安全。

锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态的角度可分为偏向锁、轻量级锁和重量级锁。同时，在JVM中还巧妙设计了自旋锁以更快地使用CPU资源。下面将详细介绍这些锁。

## 23.乐观锁

乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。

Java中的乐观锁大部分是通过CAS（Compare And Swap，比较和交换）操作实现的，CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。

## 24.悲观锁

悲观锁采用悲观思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞、等待直到拿到锁。

Java中的悲观锁大部分基于AQS（Abstract Queued Synchronized，抽象的队列同步器）架构实现。AQS定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的Synchronized、ReentrantLock、Semaphore、CountDownLatch等。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如RetreenLock）。

## 25.自旋锁

自旋锁认为：如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。

线程在自旋时会占用CPU，在线程长时间自旋获取不到锁时，将会产CPU的浪费，甚至有时线程永远无法获取锁而导致CPU资源被永久占用，所以需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁。

## 26.自旋锁的优缺点

- 优点：自旋锁可以减少CPU 上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅度提升，因为自旋的CPU 耗时明显少于线程阻塞、挂起、再唤醒时两次CPU上下文切换所用的时间。
- 缺点：在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起CPU 的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。

## 27.自旋锁的时间阈值

自旋锁用于让当前线程占着CPU的资源不释放，等到下次自旋获取锁资源后立即执行相关操作。但是如何选择自旋的执行时间呢？如果自旋的执行时间太长，则会有大量的线程处于自旋状态且占用CPU资源，造成系统资源浪费。因此，对自旋的周期选择将直接影响到系统的性能！

JDK的不同版本所采用的自旋周期不同，JDK 1.5为固定DE时间，JDK1.6引入了适应性自旋锁。适应性自旋锁的自旋时间不再是固定值，而是由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的，可基本认为一个线程上下文切换的时间是就一个最佳时间。

## 28.synchronized

synchronized关键字用于为Java对象、方法、代码块提供线程安全的操作。synchronized属于独占式的悲观锁，同时属于可重入锁。在使用synchronized修饰对象时，同一时刻只能有一个线程对该对象进行访问；在synchronized修饰方法、代码块时，同一时刻只能有一个线程执行该方法体或代码块，其他线程只有等待当前线程执行完毕并释放锁资源后才能访问该对象或执行同步代码块。

Java中的每个对象都有个monitor对象，加锁就是在竞争monitor对象。对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方法是否加锁是通过一个标记位来判断的。

### synchronized的作用范围

- synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。
- synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不属于对象。
- synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。

### synchronized的用法简介

synchronized作用于成员变量和非静态方法时，锁住的是对象的实例。

```
public static void main(String[] args){
	final SynchronizedDemo demo=new SynchronizedDemo();
	new Thread(new Runnable(){
		@Override
		public void run(){
			demo.generalMethod1();
		}
	}).start();
	new Thread(new Runnable(){
		@Override
		public void run(){
			demo.generalMethod2();
		}
	}).start();
}

//synchronized修饰普通的同步方法，锁住的是当前实例对象
public synchronized void generalMethod1(){
}
//synchronized修饰普通的同步方法，锁住的是当前实例对象
public synchronized void generalMethod2(){
}
```

上面的程序定义了两个使用synchronized修饰的普通方法，然后在main函数中定义对象的实例并发执行各个方法。我们看到，线程1会等待线程2执行完成才能执行，这是因为synchronized锁住了当前的对象实例synchronizedDemo导致的。具体的执行结果如下：

```
generalMethod1 execute 1 
generalMethod1 execute 2 
generalMethod2 execute 1 
generalMethod2 execute 2 
```

稍微把程序修改一下，定义两个实例分别调用两个方法，程序就能并发执行起来了：

```
final SynchronizedDemo demo1=new SynchronizedDemo();
final SynchronizedDemo demo2=new SynchronizedDemo();
new Thread(new Runnable(){
	@Override
	public void run(){
		demo1.generalMethod1();
	}
}).start();
new Thread(new Runnable(){
	@Override
	public void run(){
		demo2.generalMethod2();
	}
}).start();
```

具体的执行结果如下：

```
generalMethod1 execute 1 
generalMethod2 execute 1 
generalMethod1 execute 2 
generalMethod2 execute 2 
```

synchronized作用于静态同步方法，锁住的是当前类的Class对象，具体的使用代码如下，我们只需在以上方法上加上static关键字即可：

```
final SynchronizedDemo demo1=new SynchronizedDemo();
final SynchronizedDemo demo2=new SynchronizedDemo();

//synchronized修饰静态同步方法，锁住的是当前类的Class对象
public static synchronized void generalMethod1(){
}
//synchronized修饰静态同步方法，锁住的是当前类的Class对象
public static synchronized void generalMethod2(){
}
```

以上代码首先定义了两个static的synchronized方法，然后定义了两个实例分别执行这两个方法，具体的执行结果如下：

```
generalMethod1 execute 1 
generalMethod1 execute 2 
generalMethod2 execute 1 
generalMethod2 execute 2 
```

我们通过日志能清晰地看到，因为static方法是属于Class的，并且Class的相关数据在JVM中是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁住所有调用该方法的线程。

synchronized作用于一个代码块时，锁住的是在代码块中配置的对象。具体的实现代码如下：

```
String lockA="lockA";
final SynchronizedDemo demo=new SynchronizedDemo();

//synchronized用于方法块，锁住的是在括号里面配置的对象
public void generalMethod1(){
	try{
		synchronized(lockA){
		
		}
	}
}
//synchronized用于方法块，锁住的是在括号里面配置的对象
public void generalMethod2(){
	try{
		synchronized(lockA){
		
		}
	}
}
```

以上代码的执行结果很简单，由于两个方法都需要获取名为lockA的锁，所以线程 1会等待线程2执行完成后才能获取该锁并执行：

```
generalMethod1 execute 1 
generalMethod1 execute 2 
generalMethod2 execute 1 
generalMethod2 execute 2 
```

我们在写多线程程序时可能会出现A线程依赖B线程中的资源，而B线程又依赖于A线程中的资源的情况，这时就可能出现死锁。我们在开发时要杜绝资源相互调用的情况。

## 29.synchronized的实现原理

在synchronized内部包括ContentionList、EntryList、WaitSet、OnDeck、Owner、!Owner这6个区域，每个区域的数据都代表锁的不同状态。

- ContentionList：锁竞争队列，所有请求锁的线程都被放在竞争队列中。
- EntryList：竞争候选列表，在Contention List中有资格成为候选者来竞争锁资源的线程被移动到了Entry List中。
- WaitSet：等待集合，调用wait方法后被阻塞的线程将被放在WaitSet中。
- OnDeck：竞争候选者，在同一时刻最多只有一个线程在竞争锁资源，该线程的状态被称为OnDeck。
- Owner：竞争到锁资源的线程被称为Owner状态线程。
- !Owner：在Owner线程释放锁后，会从Owner的状态变成!Owner。

synchronized在收到新的锁请求时首先自旋，如果通过自旋也没有获取锁资源，则将被放入锁竞争队列ContentionList中。

为了防止锁竞争时ContentionList尾部的元素被大量的并发线程进行CAS访问而影响性能，Owner线程会在释放锁资源时将ContentionList中的部分线程移动到EntryList中，并指定EntryList中的某个线程（一般是最先进入的线程）为OnDeck线程。Owner线程并没有直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，让OnDeck线程重新竞争锁。在Java中把该行为称为“竞争切换”，该行为牺牲了公平性，但提高了性能。

获取到锁资源的OnDeck线程会变为Owner线程，而未获取到锁资源的线程仍然停留在EntryList中。

Owner线程在被wait方法阻塞后，会被转移到WaitSet队列中，直到某个时刻被notify方法或者notifyAll方法唤醒，会再次进入EntryList中。ContentionList、EntryList、WaitSet中的线程均为阻塞状态，该阻塞是由操作系统来完成的（在Linux内核下是采用pthread_mutex_lock内核函数实现的）。

Owner线程在执行完毕后会释放锁的资源并变为!Owner状态。

![](D:\workspace\Java-Interview-Offer\images\并发编程003.png)

在synchronized中，在线程进入ContentionList之前，等待的线程会先尝试以自旋的方式获取锁，如果获取不到就进入ContentionList，该做法对于已经进入队列的线程是不公平的，因此synchronized是非公平锁。另外，自旋获取锁的线程也可以直接抢占OnDeck线程的锁资源。

synchronized是一个重量级操作，需要调用操作系统的相关接口，性能较低，给线程加锁的时间有可能超过获取锁后具体逻辑代码的操作时间。

JDK 1.6对synchronized做了很多优化，引入了适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等以提高锁的效率。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫作锁膨胀。在JDK 1.6中默认开启了偏向锁和轻量级锁，可以通过-XX:UseBiasedLocking禁用偏向锁。

## 30.ReentrantLock

ReentrantLock继承了Lock接口并实现了在接口中定义的方法，是一个可重入的独占锁。ReentrantLock通过自定义队列同步器（AbstractQueued Sychronized，AQS）来实现锁的获取与释放。

独占锁指该锁在同一时刻只能被一个线程获取，而获取锁的其他线程只能在同步队列中等待；可重入锁指该锁能够支持一个线程对同一个资源执行多次加锁操作。

ReentrantLock支持公平锁和非公平锁的实现。公平指线程竞争锁的机制是公平的，而非公平指不同的线程获取锁的机制是不公平的。

ReentrantLock不但提供了synchronized对锁的操作功能，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。

## 31.ReentrantLock的用法

ReentrantLock有显式的操作过程，何时加锁、何时释放锁都在程序员的控制之下。具体的使用流程是定义一个ReentrantLock，在需要加锁的地方通过lock方法加锁，等资源使用完成后再通过unlock方法释放锁。具体的实现代码如下：

```
public class ReentrantLock implements Runnable{
	//定义一个ReentrantLock
	public static ReentrantLock lock=new ReentrantLock();
	public static int i=0;
	public void run(){
		for(int j=0;j<10;j++){
			lock.lock();//加锁，可重入锁		
		}
		try{
			i++;
		}finally{
			lock.unlock();//释放锁
		}
	}
}
```

ReentrantLock之所以被称为可重入锁，是因为ReentrantLock锁可以反复进入。即允许连续两次获得同一把锁，两次释放同一把锁。将上述代码中的注释部分去掉后，程序仍然可以正常执行。注意，获取锁和释放锁的次数要相同，如果释放锁的次数多于获取锁的次数，Java就会抛出java.lang.IllegalMonitorStateException异常；如果释放锁的次数少于获取锁的次数，该线程就会一直持有该锁，其他线程将无法获取锁资源。

## 32.ReentrantLock如何避免死锁

### 响应中断

在synchronized中如果有一个线程尝试获取一把锁，则其结果是要么获取锁继续执行，要么保持等待。ReentrantLock还提供了可响应中断的可能，即在等待锁的过程中，线程可以根据需要取消对锁的请求。具体的实现代码如下：

```
//如果当前线程未被中断，则获取锁
lock.lockInterruptibly();

//检查当前线程是否持有该锁，如果持有释放该锁
if(lock.isHeldByCurrentThread){
	lock.unlock();
}

Long time=System.currentTimeMillis();
InterruptiblyLock interruptiblyLock=new InterruptiblyLock();
Thread thread1=interruptiblyLock.lock1();
Thread thread2=interruptiblyLock.lock2();
//自旋一段时间，如果等待时间过长，则可能发生死锁等问题，主动中断并释放锁
while(true){
	if(System.currentTimeMillis-time>3000){
		thread2.interrupt();//中断线程1
	}
}
```

### 可轮询锁

通过booleantryLock()获取锁。如果有可用锁，则获取该锁并返回true，如果无可用锁，则立即返回false。

### 定时锁

通过boolean tryLock(long time,TimeUnit unit)throws InterruptedException获取定时锁。如果在给定的时间内获取到了可用锁，且当前线程未被中断，则获取该锁并返回true。如果在给定的时间内获取不到可用锁，将禁用当前线程，并且在发生以下三种情况之前，该线程一直处于休眠状态。

- 当前线程获取到了可用锁并返回true。
- 当前线程在进入此方法时设置了该线程的中断状态，或者当前线程在获取锁时被中断，则将抛出InterruptedException，并清除当前线程的已中断状态。
- 当前线程获取锁的时间超过了指定的等待时间，则将返回false。如果设定的时间小于等于0，则该方法将完全不等待。

## 33.Lock接口的主要方法

Lock接口的主要方法如下。

- voidlock()：给对象加锁，如果锁未被其他线程使用，则当前线程将获取该锁；如果锁正在被其他线程持有，则将禁用当前线程，直到当前线程获取锁。
- boolean tryLock()：试图给对象加锁，如果锁未被其他线程使用，则将获取该锁并返回true，否则返回false。tryLock()和lock()的区别在于tryLock()只是“试图”获取锁，如果没有可用锁，就会立即返回。lock()在锁不可用时会一直等待，直到获取到可用锁。
- tryLock(long timeout TimeUnit unit)：创建定时锁，如果在给定的等待时间内有可用锁，则获取该锁。
- void unlock()：释放当前线程所持有的锁。锁只能由持有者释放，如果当前线程并不持有该锁却执行该方法，则抛出异常。
- Condition newCondition()：创建条件对象，获取等待通知组件。该组件和当前锁绑定，当前线程只有获取了锁才能调用该组件的await()，在调用后当前线程将释放锁。
- getHoldCount()：查询当前线程保持此锁的次数，也就是此线程执行lock方法的次数。
- getQueueLength()：返回等待获取此锁的线程估计数，比如启动 5个线程，1 个线程获得锁，此时返回4。
- getWaitQueueLength(Condition condition)：返回在Condition条件下等待该锁的线程数量。比如有5 个线程用同一个condition对象，并且这 5 个线程都执行了condition对象的await方法，那么执行此方法将返回5。
- hasWaiters(Condition condition)：查询是否有线程正在等待与给定条件有关的锁，即对于指定的contidion对象，有多少线程执行了condition.await方法。
- hasQueuedThread(Thread thread)：查询给定的线程是否等待获取该锁。
- hasQueuedThreads()：查询是否有线程等待该锁。
- isFair()：查询该锁是否为公平锁。
- isHeldByCurrentThread()：查询当前线程是否持有该锁，线程执行lock方法的前后状态分别是false和true。
- isLock()：判断此锁是否被线程占用。
- lockInterruptibly()：如果当前线程未被中断，则获取该锁。

## 34.公平锁与非公平锁

ReentrantLock支持公平锁和非公平锁两种方式。公平锁指锁的分配和竞争机制是公平的，即遵循先到先得原则。非公平锁指JVM遵循随机、就近原则分配锁的机制。

ReentrantLock通过在构造函数ReentrantLock(boolean fair)中传递不同的参数来定义不同类型的锁，默认的实现是非公平锁。这是因为，非公平锁虽然放弃了锁的公平性，但是执行效率明显高于公平锁。如果系统没有特殊的要求，一般情况下建议使用非公平锁。

## 35.tryLock、lock和lockInterruptibly的区别

tryLock、lock和lockInterruptibly的区别如下。

- tryLock若有可用锁，则获取该锁并返回true，否则返回false，不会有延迟或等待；tryLock(long timeout,TimeUnit unit)可以增加时间限制，如果超过了指定的时间还没获得锁，则返回false。
- lock若有可用锁，则获取该锁并返回true，否则会一直等待直到获取可用锁。
- 在锁中断时lockInterruptibly会抛出异常，lock不会。

## 36.synchronized和ReentrantLock的比较

synchronized和ReentrantLock的共同点如下。

- 都用于控制多线程对共享对象的访问。
- 都是可重入锁。
- 都保证了可见性和互斥性。synchronized和ReentrantLock的不同点如下。
- ReentrantLock显式获取和释放锁；synchronized隐式获取和释放锁。为了避免程序出现异常而无法正常释放锁，在使用ReentrantLock时必须在finally控制块中进行解锁操作。
- ReentrantLock可响应中断、可轮回，为处理锁提供了更多的灵活性。
- ReentrantLock是API级别的，synchronized是JVM级别的。
- ReentrantLock可以定义公平锁。
- ReentrantLock通过Condition可以绑定多个条件。
- 二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略。
- Lock是一个接口，而synchronized是Java中的关键字，synchronized是由内置的语言实现的。
- 我们通过Lock可以知道有没有成功获取锁，通过synchronized却无法做到。
- Lock可以通过分别定义读写锁提高多个线程读操作的效率。