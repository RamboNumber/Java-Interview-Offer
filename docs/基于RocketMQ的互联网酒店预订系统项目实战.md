# 基于RocketMQ的互联网酒店预订系统项目实战

### **01_梳理一下互联网酒店预订系统的功能结构图**

**1、写在前面：颠覆传统专栏的授课思路**

大家好，今天带大家开始 RocketMQ 项目实战的课程。众所周知，在高并发、大流量的系统架构中，MQ（Message Queue）消息队列的应用是非常广泛的。从读写分离到服务之间的解耦，从高并发的削峰到热点数据的请求，MQ 的应用是无处不在。

RocketMQ 作为一款分布式的消息中间件，经历了 Metaq1.x、Metaq2.x 的发展和淘宝双十一的洗礼，成为市面上比较流行的 MQ 产品，被各大厂商争相采用。

应广大同学要求，儒猿教学研发团队开发了这款针对 RocketMQ 的教学产品。本专栏将颠覆传统专栏的讲授模式，通过老师讲解、学员动手开发、上线实践的方式，让大家在实战中掌握技术细节，在真实业务中吃透 MQ 的原理，同时知道在实际项目中是如何与其他后端技术进行交流与融合的。

课程共分 12 周共 66 节，以小步快跑、快速迭代的方式从无到有建立 MQ 的项目。课程将通过“互联网酒店预约系统”作为贯穿整个 MQ 开发实践的实例，大家可以跟着课程一起，落地实战一个属于自己的 RocketMQ 项目。

#### **2、项目背景**

本项目主要针对“互联网酒店预约系统”开发的，其中酒店的管理人员可以在“酒店管理后台”进行酒店房间的管理，如图1 所示，例如：添加、修改房间。

如图 2 所示，后台管理人员可以通过订单管理列表看到用户的订单信息，从而进行入住和退房操作。

总体而言“酒店管理后台”主要是给酒店的管理人员使用的，包括：分店管理，房间管理，订单管理，优惠券管理等部分。

其次，客人可以通过“酒店小程序”进行酒店房间的查询，接着预定、下单、查看优惠卷等动作。如图3 所示，客人可以通过小程序查询酒店，根据列表中显示的酒店，选择位置和价格都适中的，并且针对合适的房型进行预订。

总而言之，可以理解为“酒店小程序“负责提供给客人查找和预订等功能，而“酒店管理后台”负责房型的管理和订单相关操作。这里我们对该项目的大概功能有所了解以后，再来看下面的具体功能结构。

#### 3、功能结构

上面我们通过大致的背景给大家介绍了项目的整体概貌，这里将项目所涉及到的人和功能给大家做展开介绍。

如图4 所示，互联网酒店预订系统的内容分为两块，分别是上面桔红色的“酒店小程序”，这部分是提供给客人使用的。主要功能包括：登录、查看优惠券、预订下单、支付订单、取消订单。

这些功能涵盖了预订房间的整个生命周期，其操作顺序是：用户“登录”，“搜索分店”，“选择分店”、“查看房型”、“选择房型”、“预定下单”，以及“支付订单“或者“取消订单”

与此同时，用户登录以后可以在“优惠券管理”中查看“优惠券”，“我的订单”中查看“待支付订单“和”取消订单“

下面的绿色部分是“酒店管理后台”，主要是给酒店管理人员使用的，其包括：添加房型、修改房型、确认订单（入住）以及结束订单（退房）

这些功能基本上可以总结为房型管理和订单管理。其操作流程是：在“分店管理”中添加分店，在“房间管理”中给指定分店添加房间。在“订单管理”中针对具体订单进行“入住”或者“退房”操作。也就是这些后台操作与小程序中的功能相映成趣，完成整个订单流程。

#### 4、总结

本节通过为什么学习 RocketMQ 作为切入点，引出了“互联网酒店预订系统”这个儒猿的教学产品。在项目背景中介绍了这个项目主要的功能和使用的人群，在功能结构中，具体将项目划分为了“酒店小程序”和“酒店管理后台”两个部分，并且将所服务的人群，以及包含的功能给大家做了梳理。

下一节，我会带大家介绍该项目的服务端架构图。咱们下期见，拜拜。

### **02_梳理一下互联网酒店预订系统的业务流程图**

**1、开篇**

大家好，上节课我们将酒店预订系统的功能给大家做了介绍，其中提到了整个系统的业务流程，但只是一笔带。

如果说功能是散落在沙滩上的“珍珠”，那么业务流程就是“金线”，它将珍珠串成项链。因此，这一节课在上节的基础上介绍酒店预订系统的业务流程。由于业务流程涉及到整个系统的所有功能，这里我会浓缩成两个场景给大家介绍：

1. 用户登录
2. 搜索房型以及下单

#### **2、用户登录**

用户通过小程序进行登录，这里会通过微信授权登录方法来调用后端登录接口登录，同时也会有手机号的授权。

如图1所示，在登录“酒店小程序”的时候，会请求“小程序后台”判断是否“第一次登录？“：如果“是”，会给用户发放优惠券。同时用户会在”我的优惠券“中找到对应的优惠券信息。如果不是第一次登录，那么不会走“发放优惠券”的流程。

无论是否“第一次登录”，都会在“小程序后台”通过“验证登录信息”，返回给客户登录的结果。客户在获得登录结果以后，登录系统或者由于后端服务异常，返回登陆失败（微信授权失败）。

#### **3、用户登录**

顺着上面登录的思路继续往下，用户在登录以后会进行哪些业务流程呢？如图2所示，泳道的从左到右依次列出了“酒店小程序”和“酒店管理后台”，从上往下流出了“客户”和“酒店管理人员”。可以方便了解，在不同流程的参与者和操作的平台。

“酒店小程序”中的流程模块通过橙色表示，而在“酒店管理后台”中的由蓝色表示。另外，有部分配置信息是“酒店管理员”事先在“酒店管理后台”配置好的，这里用黄色表示，同时在执行流程过程中如果需要调用这部分信息时，会通过蓝色的箭头表示。

 我们顺着箭头从上往下来看流程，先从“查询酒店”开始。客户登录“酒店小程序”以后，会通过时间范围等搜索条件查询酒店信息，在此基础上“选择分店”，“分店信息”是由酒店管理者在“酒店管理后台”事先配置好的。

针对每个分店有对应的房型信息“选择房型”，同样该信息也是配置好的，直接获取就好了。之后，通过“预订”功能“填写入住信息”，最后通过“付款”完成交易。

需要注意的是，付款的时候会获取优惠券的信息，还记得在登录时发放的优惠券吗？在这里就派上用场了。到这里客户在小程序上面操作的流程就完了。用户可以在小程序的“我的”中实时查看订单的状态。接下来就轮到“酒店管理人员”上场了。

客户付款以后会“记录预订”，以订单的形式，让“酒店管理人员”在“查询订单信息”中找到对应的订单。在根据对应的订单进行“确定入住”操作，也就是当客户到达酒店以后进行Check in的时候执行。

当然，客户离开酒店的时候，我们的管理人员也可以执行“确定退房”的操作。上述的这些操作都是在酒店管理后台完成。整个订单的状态变更可以在小程序上看到。

#### **3、总结**

这一节在延续了酒店预订系统功能的基础上，介绍了对应功能的业务流程，让大家知道功能之间是如何互动和沟通的。

另外，着重介绍了登录和下单的流程。其中涉及到“客户”、“酒店管理人员”两个角色和“酒店小程序”和“酒店管理后台”两个平台。下一节会根据功能以及流程给大家介绍系统的逻辑架构图。我们下期见！

### **03_梳理一下互联网酒店预订系统的逻辑架构图**

**1、开篇**

大家好，上节课我们介绍了酒店预订系统的业务流程，相信大家如果开发这个系统，对流程是有了大致的了解。

有了业务的指导后再根据业务进行系统的搭建，逻辑架构图就是根据业务流程和功能实现技术架构的基础。逻辑架构就是对功能的技术抽象，告诉架构师为了实现这些业务功能需要用到哪些技术，例如：客户端、网关、服务、存储等等。而具体的技术实现则在系统架构中进行讲解。今天就开始酒店预订系统的逻辑架构讲解。

#### **2、酒店预订系统的逻辑架构**

正如开篇中提到的，有了功能和流程形成了业务的骨架，这个骨架需要落地成为“活生生的人”就需要进行逻辑设计。

逻辑设计就是设计人的血肉，在原来的骨架上进行实体的填充，包括使用到的技术，功能模块的划分。在逻辑架构中可以不提及具体的实现技术工具，但是要对技术要点进行分析，也就是“造人”的可行性分析。这里一起来看看架构图，如图1 所示，我们将本系统分为四层，从上往下分别是“访问层”、“接入层”、“服务层”、“数据层”。

从上往下也是用户请求的方向，用户请求从“访问层”接触到系统，请求通过“接入层”访问到具体的业务服务。业务服务在“服务层”中提供“访问层”需要的服务，并且对服务进行模块划分。最后数据的持久化和缓存需要数据层提供。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj2zuub0skn.png)

图1 逻辑架构图





上面对整个逻辑架构图有了大致了解以后，再展开说明每层的作用和技术要点。

#### **3、访问层**

用户会通过这层提供的应用访问到整个系统，这里会继承系统中功能的访问接口。由于本系统有两类用户，分别是“客户”和“酒店管理人员”，因此这里提供了两个访问的入口，分别是“预订客户端”（“酒店小程序”）和“酒店管理后台”。

之所以这里不直接说小程序和Web管理网站，是因为在这一层需要做抽象。根据具体的使用场景不同，小程序可以被Android 、IOS所替代；管理后台也有可能需要接入其他系统或者使用其他技术。这也是逻辑层存在的价值，帮助大家使用抽象思维架构系统。

#### **4、接入层**

有了访问层，请求会通过HTTP/HTTPS请求进入到系统的内部。在进入之前会经过访问层，由于我们的系统有可能暴露在公网环境下，而内部的服务和公网用户访问需要有一个缓冲或者保护机制。

这里使用反向代理的方式，将外部的请求代理到内部的服务中，对流量进行了管理、也隔离了网络。同时使用网关的机制，也可以对请求进行过滤和鉴权。例如：用户访问权限、重复发送请求、恶意请求、大流量控制都可以在这一层完成。

#### **5、服务层**

这个是系统的大头，基本所有的服务都是在这里提供。从图中绿色的部分可以看到包括三个紫色的框图。将服务分为了三类：基础信息管理、订单管理和系统管理。

基础信息管理，主要包括分店信息、房型信息、优惠券信息这些信息属于系统基础信息，系统正常运行会依赖这部分的信息，在系统构建之后需要第一时间建立。订单管理包括系统中的主要业务信息，包括：订单预订、订单付款、确认入住、确认退房，也是业务流程中的主要操作。系统管理中的用户登录和消息推送，属于系统级别的功能和业务可以解耦。

#### **6、数据层**

为了实现数据的持久化，这一层通常用来存储业务数据。同时在必要的时候还会为系统提供缓存服务。

#### **7、总结**

这一节在功能和流程的基础上扩展出了系统的逻辑架构，这个逻辑架构是对功能层面的技术抽象。也就是告诉我们为了完成这些功能和流程需要提供那些技术点，这里通过一张大图展示四层架构，分别是：访问层、接入层、服务层、数据层。并且分别解释每层的作用。

下一节会在逻辑架构图的基础上加入技术实现的部分，同样是四层架构，但是在不同层级使用不同的技术实现具体功能。我们下次见，拜拜。

### **04_梳理一下互联网酒店预订系统的服务端架构图**

#### **1、开篇**

大家好，上节课我们介绍了酒店预订系统的逻辑架构，将系统分为四层从上到下分别是：访问层、接入层、服务层和数据层。

如果说逻辑架构是系统技术的抽象，那么技术架构就是对抽象的具体化，也就是说用什么具体的技术手段完成逻辑架构。那么就让我们开始今天的课程吧。

#### **2、技术架构说明**

延续上节课中的内容，在切分逻辑架构以后，针对具体每层进行技术实施。如图1所示，依旧将架构分为四层，这里我们将针对每次完成的技术要点进行深入的分析。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj3zqpq0vha.png)



图1 技术架构图

#### **3、访问层**

使用了微信小程序和H5的方式提供给“客户”和“酒店管理人员”进行操作。这里的技术选型和使用场景相关。

“客户”通常预订房间多是在旅途中，使用移动终端的场景会多些，由于微信的普及率较广，使用小程序作为入口推广成本较低。同样，“酒店管理人员”移动办公需求较少，同时还需要处理各种表格数据，PC端使用H5的方式是不错的选择，符合使用场景匹配的原则。

#### **4、接入层**

是连接客户和服务的纽带，这里使用了Nginx 作为反向代理，反向代理不仅使外网和内网进行了有效的隔离，同时进行了IP的转化。

Nginx 结合OpenResty的脚本功能还可以和缓存队列等技术有机结合，而且为以后的水平扩展也提供了可能性。启用“儒猿自研网关”对请求进行过滤和鉴权，针对流量限制，用户权限控制等功能可以放在这里完成。

#### **5、服务层**

服务层内容比较多，先从下面四个独立的模块开始。Spring Boot 作为脚手架搭建基本服务架构，理清组件包之间的依赖关系，快速搭建后台应用程序。MyBatis 作为数据库访问的利器，支持ORM和手动SQL的方式对数据库进行操作。

Spring Web MVC 是提供RESTFUL API的主力军，其网络请求的处理能力使它成为本架构的不二之选。最后是Elastic Search ，其将数据库中的信息转化为索引文件，提供高效的数据检索功能，非常适合酒店搜索功能。在四个模块的右边有三个竖条分别是RocketMQ、Redis 和Nacos。

RocketMQ提供了服务之间消息流转的通道，将服务之间关系进行解耦，让架构真正做到高内聚、低耦合。

Redis 作为进程外缓存，提高请求的响应时间，增强用户体验。

Nacos的加入作为服务之间的注册中心，不仅理清了服务之间的调用关系，也提供了分布式服务部署的可能性。

接着再看右边粉色的条形，slf4j （Simple Logging Facade for Java）作为日志的利器，保存运行时的日志信息，是debug的好帮手。

中间紫色区域的“业务服务”包括“基础信息管理”、“订单管理”以及“系统管理”三大服务模块，是系统需要实现的服务主体，作为业务描述放在这里与逻辑架构中的业务部分相对应。

最后是上方的Tomcat 应用服务器，作为应用服务的容器承载服务请求与响应的主要工作。

#### **6、数据层**

数据层的内容相对简单，MySQL老牌的关系型数据库负责存放客户、酒店、房型、配置等业务信息。Redis的持久化功能增加了Redis缓存的可靠性。

#### **7、总结**

这一节在逻辑架构的基础上扩展出系统架构，正如开篇中讲到的是从抽象到实现的转换，依旧是针对四层架构，列举出了每次实现的技术工具和架构。

这些工具的选型在业界也经常使用，不仅从可靠性还是扩展性而言都是相对优秀的。同样，大家也可以根据实际场景选取趁手的工具，进行开发。

下一节是本周的最后一节课，会把这周的全部课程进行总结和梳理，用一张大图鸟瞰整个酒店预订系统。我们下次见，拜拜。

### **05_ 一张图了解我们要做的项目最终长什么样子？**

**1、开篇**

大家好，上节课我们介绍了酒店预订系统的系统架构，将系统架构和逻辑架构一样分为四层从上到下分别是：访问层、接入层、服务层和数据层，针对每层的技术实现进行扩展和细化，为的是项目最终能够落地。

系统架构中每个技术组件就好像人身体里面的器官，各司其职保证人的生命体征。每个器官在不同场景下会发挥不同的作用，例如：运动的时候，四肢、心肺是主力。学习的时候，大脑、五官是主力。当然，一些基础组件在每种场景中都扮演重要的角色。

与之相同，系统架构完毕以后，这些技术组件会在不同的业务场景中施展不同的能力。为了让系统架构图“动起来”，这里会列举两种场景，看看这些组件是如何协同工作的。希望通过这种方式，让大家了解酒店预订系统的项目大图。

#### **2、项目大图-修改房间场景**

正如开篇中提到的每个业务场景应用到的技术组件会有所不同，技术组件的使用也会根据业务场景不同而侧重不同。这里先给大家介绍“修改房间场景”的实现过程，其包括：从请求进入系统直到完成整个请求的过程。

如图1 所示，整个系统架构和上一节中描述的一致，不同的是通过用户请求的过程将每个技术组件串联起来，我们可以顺着箭头的方向从上往下查看，在每一步请求中我们都加入了数字的标号方便大家阅读。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj4kcg40wty.png)



图1 修改房间场景

#### **3、修改房间执行流程**

1. “酒店管理人员”通过“酒店管理后台”访问房间详情的配置信息。这里的入口是H5，也就是管理后台的具体实现。
2.  此时请求通过H5请求到系统的入口，作为反向代理和负载均衡的Nginx接受到请求会将其转交给“儒猿自研网关”。
3.  在“儒猿自研网关”可以进行用户验证、流量限制等工作，最终通过服务层请求对应的服务。
4. 由于每个服务都是Host在Tomcat之上的，这里会通过Tomcat请求每个服务。这里的Tomcat对应的是“酒店管理后台”，需要与后面提到的小程序后台Tomcat作区分。
5. 在请求服务之前会经过Spring Web MVC对HTTP请求进行解析，转化为请求对象。
6. 将解析请求以后会调用“基础信息管理“中的”房间详情“服务，并且根据请求内容进行房间信息的修改。
7.  修改信息通过MyBatis 更新到MySQL中完成数据的更新。
8. 之后再将更新的房间信息发送给Redis缓存起来，如果此时有请求访问时就不用从数据库中获取了。
9.  接下来就是通过RocketMQ队列分发修改房间信息的消息，并且通知订阅该消息的其他服务。
10. 订阅消息的服务获取消息通知以后，会更新服务本身JVM的缓存，同样也是为了提高用户的访问效率。
11. 最后，将这一连串的操作记录成日志存档。

#### **4、项目大图-查看房间场景**

前面提到了修改房间场景的流程，从用户请求的过程可以看到其中一些组件的工作情况。这里要讲解的是“查询房间场景”，查询操作实际上与上面的修改操作形成对比，刚才保存的数据也就是为这里查询使用的。

如图2所示，系统架构和技术组件都没有改变，不同的是业务的流程和请求的路径发生变化。依旧是顺着数字标号一路向下，不过其中一些组件的功能在图1 中已经介绍过了，这里会一笔带过，会将使用不同的地方着重提出来讲。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj4ng5q0w0f.png)

图2 查询房间详情的场景

#### **5、查询房间执行流程 **

1. “客户”通过微信小程序访问酒店预订系统，此时小程序作为系统的入口。
2.  访问接入层的Nginx。
3.  通过“儒猿自研网关”的过滤。
4.  这里访问的是小程序后台的Tomcat，其承载着小程序需要的服务API。
5.  依旧是通过Spring Web MVC访问具体的服务。
6.  房间信息存放在基础信息管理服务中，从这里开始流程会有所不同。
7. 服务在获取用户请求的时候，会先去检查本地JVM缓存中是否有房间详情的信息，如果有的话将会直接返回给客户。
8. 如果在JVM缓存中不存在房间详情，会从Redis 缓存中获取。
9. 如果Redis缓存中依旧不存在该信息，才回源到MySQL数据库，同样也是使用MyBatis来访问。
10. 完成查询操作以后依旧会记录日志归档。

#### **6、总结**

有了逻辑架构和系统架构之后，需要通过业务场景帮助我们理解这些技术组件是如何运作的，为了覆盖更多的技术组件这里列举了“修改”和“查询”的两个场景。

通过请求访问四层系统时访问的组件顺序以及组合了解整个架构体系，让我们更清楚地认识项目的最终形态。本周的课程也在这里告一段落了，下周将对项目实施进行一系列的准备工作。我们下次见，拜拜。

### **06_初来乍到：首先基于目前主流的SpringCloud Alibaba进行项目初始化**

**0、开篇**

经过第一周的讲解，让我们对学习的内容有了基本的了解。其中需要依托“互联网酒店预订系统”作为RocketMQ的学习案例，同时在过去一周的课程中也对案例项目进行了完整的介绍。

从功能到业务逻辑，从业务逻辑到逻辑架构，又从逻辑架构到系统架构。在做足这些准备以后，今天就开始该项目的开发了。

千里之行始于足下，这节课的主题是通过主流的SpringCloud Alibaba 对项目进行初始化。并且从这一节开始，会涉及到代码的部分，因此我们会将每次生成的代码都附在每节课程结束的位置给大家参考。将今天的课程分为一下几个部分：

1. 创建项目
2. 引入项目依赖
3. 编写配置文件
4. 创建启动类
5. 创建HealthController的接口
6. 运行项目

#### **1、创建项目**

我们通过IntelliJ IDEA创建项目，如图1 所示，打开IntelliJ IDEA，选择“Create New Project” 创建项目。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj803to05cc.png)图1 创建项目

如图2 所示，在弹出的选框中，选择“Maven”表示通过Maven来创建项目，然后点击“Next”按钮。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj803tj04ef.png)

图2 选择Maven 创建项目

如图3 所示在弹框中输入“GroupId”和“ArtifactId”的信息。分别是“com.ruyuan2020.little.project”和“little-project-rocketmq”，然后点击“Next”进入下一步。 

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj804o404qx.png)图3 填写GroupId和ArtifactId的信息

如图4所示，在弹框中填写“Project name”为“little-project-rocketmq”，然后点击“Finish”按钮表示完成项目创建。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj804pp0qei.png)图4 填写Project name完成项目创建

#### **2、引入项目依赖**

如图5所示，首先来看看引入依赖后的pom.xml文件，里面包含了很多组件的依赖项。相信在[C2C 电商系统微服务架构 120 天实战训练营](https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5f1e9ddbe4b0a1003cafad34/6) 的课程中大家已经有过接触，这里选择几个儒猿小实战云平台提供的依赖给大家做介绍。 

![5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km05e8p508or.png)图5 项目依赖 

#### **2.1、儒猿团队提供的公共依赖项**

如图6 所示，这里的小实战项目的公共依赖由儒猿团队提供的，这个依赖会贯穿整个项目，因此需要在此处引入。

![6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km05f5jo0vxm.png) 图6 小实战项目的公共依赖

#### **2.2、儒猿团队提供的私服地址**

需要注意的是由于该组件出自儒猿团队，因此需要通过配置Maven 仓库对应的私服地址才能够获取，我们把地址的配置放到下面，以供参考。

<!--私服地址-->  <repositories>    <repository>      <id>public</id>      <name>public</name>      <url>http://121.4.45.211:8081/repository/maven-public/</url>      <snapshots>        <updatePolicy>always</updatePolicy>      </snapshots>    </repository>  </repositories>

#### **2.3、RocketMQ Client依赖项**

如图7所示，作为本节课的主角，需要引入 RocketMQ Client 的依赖项，特别是在API中会用到它和RocketMQ Server 进行交互。 

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj804qy0t67.png)图7 RocketMQ Client 依赖项

#### **2.4、Spring Cloud Alibaba依赖项**

如图8所示，这里使用了Alibaba spring cloud dubbo和nacos的依赖项。其中由于项目中使用了dubbo的服务，nacos 作为其服务的注册中心。

![图片18.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj804u10odh.png) 图8 Spring Cloud Alibaba依赖项

#### **2.5、应用程序包启动项的入口**

这里配置的依赖是指定，在编译应用程序生成Jar 包以后启动的MainClass的全称，让程序找到启动的入口。和后面提到的启动入口函数产生对应。

![图片19.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj805dm0jrh.png) 图9 应用程序包启动项的入口

#### **3、编写配置文件**

说完了依赖项，再来看看配置文件。如图10所示，我们需要添加三个配置文件，分别是：

1. “application.properties”:用来存放项目配置信息。
2. “application-dev.properties”：用来存放dev（开发）环境的配置信息。
3. “application-prod.properties”：用来存放prod（生产）环境的配置信息。

从图10 中还可以看到“application.properties”定义了如下内容：

1. 应用的名字：spring.application.name=little-project-rocketmq
2. 使用开发环境的配置：spring.profiles.active=dev
3. 应用的服务器端口号：server.port=8088
4. dubbo.cloud.subscribed-services= （订阅的服务名称，初始化先暂时为空）
5. dubbo.scan.base-packages=com.ruyuan.little.project.rocketmq（扫描的dubbo接口的包名）

![图片20.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj805e40t0o.png)

 图10 配置文件

至于dev和prod 中配置的信息关于nacos服务器的地址，有儒猿团队已经配置好了，在最后的代码中会提供给大家使用。这里把配置文件分为dev和prod也是为了日后发布不同的环境做准备，大家可以根据不同的环境设置对应的配置信息。

#### **4、创建启动类**

正如依赖项里面提到的包启动的入口函数里面说的，应用程序打包以后会指定一个启动的入口MainClass函数。如图11 所示，我们创建了 “LittleProjectRocketMqApplication” 类，并打上“@SpringBootApplication”的annotation，其对应的main函数也就是整个项目的入口函数了。

![图片21.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj803tn0qsy.png)图11 入口函数

#### **5、创建HealthController的接口**

整个项目会以服务的形式暴露给前端应用调用，为了检查服务的健康状况，我们建立一个HealthController。如图12 所示，建立“com.ruyuan .little.project.rocketmq.api”包，并且定义HealthController类加上“@RestController”的annotation。在访问服务的根目录且服务运行正常时会返回“成功”，否则就视为服务不可用。

![图片22.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj805gz0map.png) 图12 HealthController

#### **6、运行项目**

完成以上步骤以后尝试运行项目，如图13所示，右键点击“LittleProjectRocketMqApplication” 启动类，选择“运行”。

![图片23.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klj803tn02hi.png)

图13 运行项目

同时打开浏览器，输入“http://localhost:8088”查看结果，此时请求会路由到HealthController中检查服务的健康状况，需要说明的是8088是在配置文件中设置的端口号。看到浏览器返回“{"code":200,"message":"成功","data":null}” 表示项目构建成功了。

#### **7、总结**

这一节作为实践的第一次课，带大家创建了项目框架。其中包括了几个部分：填写基本信息创建项目、设置项目的依赖组件、生成配置文件、项目启动的入口函数、创建HealthController检查服务健康以及运行项目，大家可以跟着每步的图文提示走一遍，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week02/)给大家。

下节课，会介绍基本服务以及对应的功能模块，下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

注意事项：maven依赖下载不下来的同学，请将本机maven setting中repository和mirror给注掉。

### **07_跟紧步伐：再对本次项目实战的基础服务进行介绍和引入**

**1、开篇**

上节课我们对互联网酒店预订系统进行了项目初始化，通过SpringCloud Alibaba 创建了项目。其中介绍了项目的创建方式、依赖项、配置、启动入口。

由于课程中会涉及到通用功能的使用，例如：数据库的访问、缓存使用和消息发送。这些功能作为课程的基础，辅助我们实现RocketMQ的应用场景，但比起RocketMQ而言并不是核心功能。

为了让大家更加聚焦主要内容的学习，这里我们将辅助功能封装成组件，一来方便大家调用，二来让大家把更多的精力放在RocketMQ的架构学习上。今天就将这几个组件介绍如下：

-  little-project-common
- little-project-mysql-api
- little-project-redis-api
- little-project-message-api

#### 2、little-project-common组件

最先登场的“little-project-common”组件是大家的老朋友，在上一节中作为基础组件已经引入了初始化的项目中。

其主要封装了请求的响应体，以及枚举响应码的信息。在Controller中完成请求返回的时候经常被用到。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/27722100_1614172758.png)

如图1 中的CommonResponse就是出自于“little-project-common”组件，作为标准的响应返回体。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljg2wa00iz4.png)图1 “little-project-common”组件的返回体

#### 3、little-project-mysql-api组件

“little-project-mysql-api”组件作为访问MySQL数据库的API，是一个dubbo服务，它在获取数据库信息的时候会被用到。



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/64351400_1614172864.png)

如图2 所示，在需要访问数据库之前先定义MysqlApi类型的变量，在图3 中使用MysqlApi 中的Query方法，传入查询的DTO对象，从而获取返回的结果。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljg2wa40wgx.png)图2 定义MysqlApi 

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljga3q80twz.png)图3应用MysqlApi 查询数据

#### 4、little-project-redis-api组件

“little-project-redis-api”是用来访问Redis的组件，也是一个dubbo服务，用来对Redis缓存进行操作。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/3047300_1614172881.png)

这里和Redis Setnx（SET if Not eXists） 命令保持一致，也就是在指定的 key 不存在时，为 key 设置指定的value。如图4 所示，在代码中通过定义RedisApi来使用Redis的功能，在图5中使用RedisApi中的setnx方法针对key设置value。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljg2wa504t3.png)图4 定义RedisApi

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljg2wa5088k.png)图5 使用RedisApi中的setnx方法 

#### 5、little-project-message-api组件

“little-project-message-api”组件是微信推送消息的API，也是dubbo组件，在完成某些业务场景的时候会调用其进行微信消息的推送。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23302600_1614172895.png)

通过图7 可以看到，通过调用WxSubscribeMessageApi 中的send方法负责微信消息推送，其输入参数是包含推送消息的DTO对象。如图6所示，将订单的微信消息的推送封装到抽象类中，其中针对“WxSubscribeMessageApi”类声明变量，用来消息发送。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljg2wa60azc.png)  图6 订单微信消息推送的抽象类

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljgerdj0v2i.png)图7 调用WxSubscribeMessageApi 中的send方法负责微信消息推送

#### **6、总结**

这一节课介绍了儒猿团队给大家提供的基础服务，之后会在具体开发功能时进行引用，这里大家先做一个了解。

其目的是让大家专注于核心业务和技术的学习上，针对基础功能的调用就由儒猿为大家搞定。总结一下四个基础组件分别负责：请求响应、MySQL数据库访问、Redis缓存访问和微信消息推送。

下节课，会介绍项目中模块的整体划分，下期见，拜拜。

### **08_有条不紊：对互联网酒店预订系统项目进行整体划分**

**1、开篇**

上节课我们对互联网酒店预订系统需要使用到的基础组件进行了介绍，包含了响应包定义、数据库访问、缓存、微信消息推送等。这些功能作为课程的基础，辅助我们实现RocketMQ的应用场景。在开始正式编码之前还需要对应用结构进行规划。从今天就将介绍以下几点内容：

- 后台系统的划分
- 代码模块的划分

#### 2、后台系统的划分

整个系统由酒店小程序、酒店管理后台，这两套系统分别对应两个后台的服务，它们分别是：小程序后台API和酒店管理后台API。

如图1 所示，上方虚线框部分已经有儒猿团队提供给大家了，作为学员我们需要关注下方实线框的部分，小程序后台API和酒店后台管理API是这次课程的主体，我们的大部分代码都在这里完成。

![图片01.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljh8iqr0omg.png)图1 后台的结构划分

#### 3、代码模块的划分

上面谈到了我们需要关注的API，这里回到liitle-project-rocketmq项目本身。如果从业务出发我们需要将每个业务划分为不同的模块，每个模块对应一个或者多个服务从而支撑模块的运行。

实际工作中这些服务有可能分开开发和部署，但作为教学实战的项目我们希望方便学员的学习和部署。因此，将这些服务通过包的形式包含在同一个项目中。

如图2所示，我们在liitle-project-rocketmq项目中建立了admin和api两个包，admin用来为酒店后台管理提供API服务，而api 为酒店小程序提供API服务。其中api包中分别包含如下几个包：

- coupon：包含优惠券相关的DTO、服务、Listener以及MQ消费者。
- hotel：包含房间相关的DTO、服务、Controller、Listener以及MQ消费者。
- login：包含登录相关的DTO、服务、Controller、Listener 、枚举状态、MQ生产者以及MQ消费者。
- message：包含消息推送相关的DTO、Listener 、消息命令以及MQ消费者。
- order：包含订单相关的DTO、服务、Controller、Listener 、枚举状态、MQ生产者以及MQ消费者。
- pay：包含消息支付相关的DTO、常量定义、Controller、服务。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljha3d10oyk.png)

图2 项目中的包结构

上面提到的每个包会随着课程的推进不断被丰富，会在其中添加不同的包，例如：Service、Controller、DTO等等。这里大家对整体的包结构有一个了解，做到心中有森林。

#### 4、总结

这一节课介绍了后台系统的划分和代码模块的划分，在后台系统划分中理清了前台后台的区别，并且着重介绍了大家需要关注的后台API部分。而在代码模块划分中，根据业务定义了不同的服务包，以及介绍每个包的职能，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week02/)给大家。

下节课会介绍儒猿RocketMQ实战云平台，后面我们会经常与这个平台打交道，从而完成应用的发布和测试。下期见，拜拜。

### **09_一见如故：对儒猿RocketMQ实战云平台进行介绍和引入**

**1、开篇**

上节课我们对互联网酒店预订系统的架构切分以及包结构，从中知道了需要专注于小程序和管理端的后台代码，并且知道了模块的大致分布。

这一节课需要帮助大家了解儒猿RocketMQ实战云平台的使用方式，因为后面所有课程的实验和部署都会依赖这个平台。这节课大家可以学到如下内容：

- 如何访问儒猿RocketMQ实战云平台
- 平台的基本操作和功能

#### **2、**如何访问儒猿RocketMQ实战云平台

儒猿的技术团队专门为这次课程搭建了实战云平台，大家可以通过https://project-practice-cloud.ruyuan2020.com/login地址进行访问。

如图1 所示，访问上述URL以后，会展示图中的画面，输入手机号获取验证码以后就可以登录云平台了。

这里的手机号需要和购买课程的手机号保持一致，这样云平台就能够识别学员信息了。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljj73tt03gb.png)图1 访问儒猿小实战云平台

#### **3、**平台的基本操作和功能

在正确输入手机号和验证码以后就进入了系统欢迎页，如图2所示，在左边的菜单中有两个选项分别是：“课程管理”和“酒店管理”。

其中“课程管理”中的功能是这次主要介绍的内容，“酒店管理”是RocketMQ实战“酒店管理后台”的入口。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klrun8xa0hrm.png)图2 登录云平台

如图3所示，在“课程管理”中选择“小实战课程”选项会看到一个列表，我们逐一来介绍列表中的信息（部分字段转移到详情页中）。

- 课程名称：描述了学员所购买的构成名字，这里会显示所有您在儒猿平台购买的课程。
- 可用时间（分钟）：由于课程中需要部署应用程序，需要用到ECS（虚拟机），这里是记录还可以使用ECS的时间长度。单位是分钟。
- 已用次数：记录已经使用ECS的次数。
- 可用次数：还可以使用ECS的次数。
- 总的次数：针对某节可总共可以使用的ECS次数。总的次数=已用次数+可用次数。
- 服务器地址：显示分配ECS 的外网IP地址。
- 服务器密码：显示分配ECS的登录密码。
- 服务器申请时间：什么时候申请的ECS服务器。
- 服务器过期时间：ECS服务器什么时候过期，过期以后服务器就无法再使用了，需要重新申请其他服务器，随之改变的还有ECS的IP，这里需要特别注意。
- 创建时间：是指课程的创建时间。
- 操作：这里有一个“分配机器”的按钮，如果点击云平台会给用户分配一个ECS服务器，并且在服务器地址和服务器密码两列，给出对应信息。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljj73tz05f9.png) 图3 小实战课程

说完了“小实战课程”的主要信息以后，再来看看“小实战操作日志”菜单中的信息。

同样还是通过图4看看每列的信息，其中有些字段和“小实战课程”中的含义一致，这里就用“同上”代替。

- 课程名称：同上。
- 可用时间（分钟）：同上。
- 上次可用次数：上次实验可用的ECS次数。
- 可用次数：当前的可用ECS次数。
- 上次已用次数：上次实验已用的ECS次数。
- 已用次数：当前已用ECS的次数。
- 总的次数：同上。
- 服务器地址：同上。
- 服务器密码：同上。
- 服务器申请时间：同上。
- 服务器过期时间：同上。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kljj73tz09l0.png)图4 小实战操作日志

#### **4、总结**

这一节课介绍了儒猿小实战云平台的基本功能和信息，以后大家会在这个平台上进行申请ECS和查询操作日志的工作，ECS  IP和密码的获取也是相对频繁的。

下节课会告诉大家如何在云平台上申请ECS服务器，并且完成登录的工作。下期见，拜拜。

### **10_跃跃；欲试：如何申请可弹性伸缩实战阿里云镜像环境**

**1、开篇**

上节课我们对互联网酒店预订系统的学习平台进行功能介绍，这是一个儒猿团队打造的实战平台，其主要是提供ECS 服务器发布学员编写的代码，从而检验学习成果。

这个ECS服务器的镜像已经包含了JDK，Maven，RocketMQ环境，大家唯一要做的就是申请它，并在上面部署我们的后台代码，从而查看结果。那么今天就来看看如何申请ECS服务器，包括如下内容：

- 分配ECS 服务器
- 返回部分登录信息
- 等待分配ECS 服务器IP
- 登录ECS服务器

#### **1、**分配**ECS 服务器**

如果需要将编写的后台代码发布到服务器上查看结果，就必须先申请ECS 服务器，将它作为应用程序的宿主。

如图1所示，正如上节课讲到的，通过购买课程的手机号和验证码登录https://project-practice-cloud.ruyuan2020.com/login 实战云平台。

在左侧的菜单中“课程管理”中选择“小实战课程”，右边的课程列表中找到“RocketMQ小实战”的课程。

在“操作”这一列点击“分配机器”的按钮，这个操作会有实战云平台在我们的ECS池中，为大家分配一台ECS服务器，由于使用的学员较多每次分配的ECS服务器都是随机的，因此每次生成的ECS服务器的IP也是不固定的，这里需要特别注意。

![机器列表.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km4hr94i055y.png)图1 分配ECS 服务器

#### **2、**返回部分登录信息

如图2所示，在点击“分配机器”按钮以后，点击详情以下信息会发生改变。

- 已使用次数：由于已经申请了ECS服务器，这个字段做了+1 操作。
- 可用次数：同理，已使用次数+1了，那么可用次数就-1了。
- 服务器密码：由于服务器需要登录，这里会给出密码。密码的格式是：RuYuan@{手机号}#% 可以用登录的手机号替换密码中 “{手机号}”的部分。例如：你的手机号是123456，那么服务器密码就是：RuYuan@123456#%
- 服务器申请时间：显示服务器开始申请的时间。
- 服务器过期时间：显示服务器什么时候使用过期，也就是过了这个时间服务器就无法使用了，一般来说平台会给出充裕的时间，这里提醒大家注意。

![分配01.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km4hyje00tz0.png)图2等待ECS服务器分配完成

#### **3、**等待分配**ECS 服务器IP**

在点击“分配机器“之后虽然会显示上述信息，但是不会马上显示服务器的IP地址，由于分配是有一个过程的，加上线上等待分配的小伙伴较多，系统需要排队处理。

大约1-2分钟以后在点击详情就可以看到ECS 分配的IP地址了，如图3所示，“服务器地址”这一栏就显示出分配的ECS 服务器的IP了，后面可以根据服务器IP和给出的密码进行登录操作了。

![分配04.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km4i49fm0z18.png)图4 分配ECS 服务器成功，IP地址显示

#### **4、**登录**ECS服务器**

通过上面几个步骤获取了服务器IP和登录密码，这里就来登录一下服务器。登录的方式如下：

\1. 打开命令行工具，通过ssh命令登录ECS服务器。输入：ssh root@{ECS服务器IP}，如果你获得的服务器IP是123.123.123.123 那么命令就是：ssh root@123.123.123.123

\2. 输入完毕以后，会显示“Are you sure you want to continue connecting (yes/no)?”的字样，问你是否继续连接服务器，输入“yes”即可。

\3. 此时会让你输入密码，输入密码回车即可。由于密码比较复杂，建议从云平台中的“服务器密码”直接复制粘贴过来，会比较方便。

\4. 当你看到“Welcome to Alibaba Cloud Elastic Compute Service ! “字样的时候，表示登录ECS服务器成功了。

#### **5、**总结

本节课告诉大家通过哪些步骤申请和登录ECS服务器，其中包括：分配ECS服务器、返回部分登录信息、等待分配ECS服务器IP、登录ECS服务器几个步骤。

下节课会告诉大家如何在云平台上申请ECS服务器，并且完成登录的工作。下期见，拜拜。

#### **11_边干边学：部署一个小规模的RcoketMQ集群，为实战做准备**

**1、开篇**

上节课我们介绍了互联网酒店预订系统实战云平台如何进行ECS的申请和分配，既然有了ECS服务器那么就可以将本地代码发布上去。

同时ECS镜像中自带了RocketMQ的服务，虽然是儒猿团队已经预装的，也带大家一起看看RocketMQ console中的功能。

那么今天要介绍的内容包括如下：

- 打包服务
- 上传服务
- 启动服务
- RocketMQ Console的功能介绍

#### **1、打包服务**

既然分配了对应的服务器，那么就可以讲我们前几节课中提到的应用服务部署上去了。

如图1所示，打开我们熟悉的酒店管理后台应用服务，在IntelliJ IDEA中选择下方的“Teminal”按钮，在显示的命令行中（红色箭头的地方）输入对应的命令，用来对项目进行打包。

![图1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkew0ow0op9.png)图1打开命令行

如图2 所示，这里输入“mvn clean package” 的命令，这里表明通过Maven进行打包，打包的是生产环境（prod）。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkewd0p0npq.png)图2 输入打包命令

在输入命令以后回车，如图3所示，会在输出信息中看到“BUILD SUCCESS”的字样表示，打包成功。

同时在项目文件的target目录下面会看到一个“little-project-rocketmq.jar”的文件，这就是我们将要发布的jar包。后面的操作会用到它。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkexcbe0ira.png)图3 打包成功

#### **2、上传服务**

在上传服务（jar包）之前需要保证，在对应的ECS中建立服务运行的目录如下：

/home/admin/little-project-rocketmq/target

这个目录已经由儒猿团队在ECS的镜像中创建好了，大家不用手动创建，我们后面的发布就基于这个目录。

其中“/home/admin/little-project-rocketmq”是用来存放部署脚本的，注意我们这里使用的deploy.sh 脚本已经由儒猿团队上传了。

“/home/admin/little-project-rocketmq/target”目录是存放服务的jar包的，这个包是需要我们自己上传的。

在ECS上建立好目录结构以后，再回到本地的项目中，依旧是在IntelliJ IDEA的命令行中输入以下命令：

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

命令的意思是通过scp命令将刚才打包的“little-project-rocketmq.jar”文件copy 到对应ECS服务器的“/home/admin/little-project-rocketmq/target”目录中。

这里的“47.117.120.102”是我的测试地址，大家可以更换为自己申请的ECS 的IP地址。

这里需要特别说明一下，由于我在执行命令的根目录在“little-project-rocketmq”项目下面，如果你在其他的地方执行上述两条命令，需要指定好源文件的目录。

同时在使用scp命令以后会让大家输入服务器的密码，该密码可以从实战云平台上获取。

完成上面两个命令以后，服务就已经部署到ECS了。

#### **3、启动服务**

完成部署以后，需要到ECS 服务器上面启动部署的酒店管理后台的服务。还是登录ECS服务器，通过以下命令进入到“deploy.sh”文件所在的目录。

cd /home/admin/little-project-rocketmq

deploy.sh 文件是儒猿团队为大家生成的发布的脚本文件，通过Linux shell脚本完成发布的参数配置和启动命令。

包括启动应用等待的时间、应用端口号、健康检查的URL以及jar包的目录和日志信息。有兴趣的同学可以打开看看，这里就不做展开的介绍了。

保证当前目录下面存在“deploy.sh”文件，使用如下命令启动服务。

sh deploy.sh restart

命令使用了“restart”作用与“start”是一致的，用“restart”的目的以免在重复发布过程中，学员忘记是否启动过服务。因此使用“restart”，这样即便是已经启动过服务，也会重新加载服务。

另外，deploy.sh中已经加了自动化脚本，用来防止用户未指定成prod环境和更改rocketmq.namesrv.address地址的配置，默认了prod环境和当前ECS的地址:9876为namesrv的地址。这些大家只需要了解就可以了，不用做任何更改。

运行命令在看到图4所示的“success”字样的时候，就说明服务启动成功了。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf0jt00sot.png)图4启动服务成功。

如图6所示，同样可以通过浏览器输入IP地址加上端口8088 来查看健康检查服务是否工作。http://47.117.115.80:8088，其中把IP地址换成你自己的。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf15po0w9q.png)图6 访问健康服务成功

#### **4、**RocketMQ **Console的功能介绍**

根据上面描述的步骤我们已经能够娴熟地发布本地服务了。不过RocketMQ的服务是儒猿团队已经安装到ECS服务器上的，我们可以通过如下方式访问：

47.117.115.80:8080/

只需要将IP地址替换成你的ECS IP就可以了。如图7 所示，这里是RocketMQ的控制台，包括日常的OPS信息、集群（Cluster）、Topic、Consumer、Producer、Message的信息

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf1qng06hd.png)图7 RocketMQ Console

如果大家对RocketMQ的部署和控制台感兴趣的话，可以参考儒猿团队的另外一门经典课程 [从 0 开始带你成为消息中间件实战高手](https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d887e7ea3adc_KDm4nxCm/6) 。

#### **4、**总结

本节课告诉大家通过哪些步骤将本地应用部署到ECS上，其中包括：打包服务、上传服务、启动服务。最后还介绍了RocketMQ Console的访问地址和基本功能，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week02/)给大家。

下节课会带大家进行门店和客房数据的初始化为后面的开发做好数据基础。下期见，拜拜。

### **11_边干边学：部署一个小规模的RcoketMQ集群，为实战做准备**

**1、开篇**

上节课我们介绍了互联网酒店预订系统实战云平台如何进行ECS的申请和分配，既然有了ECS服务器那么就可以将本地代码发布上去。

同时ECS镜像中自带了RocketMQ的服务，虽然是儒猿团队已经预装的，也带大家一起看看RocketMQ console中的功能。

那么今天要介绍的内容包括如下：

- 打包服务
- 上传服务
- 启动服务
- RocketMQ Console的功能介绍

#### **1、打包服务**

既然分配了对应的服务器，那么就可以讲我们前几节课中提到的应用服务部署上去了。

如图1所示，打开我们熟悉的酒店管理后台应用服务，在IntelliJ IDEA中选择下方的“Teminal”按钮，在显示的命令行中（红色箭头的地方）输入对应的命令，用来对项目进行打包。

![图1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkew0ow0op9.png)图1打开命令行

如图2 所示，这里输入“mvn clean package” 的命令，这里表明通过Maven进行打包，打包的是生产环境（prod）。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkewd0p0npq.png)图2 输入打包命令

在输入命令以后回车，如图3所示，会在输出信息中看到“BUILD SUCCESS”的字样表示，打包成功。

同时在项目文件的target目录下面会看到一个“little-project-rocketmq.jar”的文件，这就是我们将要发布的jar包。后面的操作会用到它。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkexcbe0ira.png)图3 打包成功

#### **2、上传服务**

在上传服务（jar包）之前需要保证，在对应的ECS中建立服务运行的目录如下：

/home/admin/little-project-rocketmq/target

这个目录已经由儒猿团队在ECS的镜像中创建好了，大家不用手动创建，我们后面的发布就基于这个目录。

其中“/home/admin/little-project-rocketmq”是用来存放部署脚本的，注意我们这里使用的deploy.sh 脚本已经由儒猿团队上传了。

“/home/admin/little-project-rocketmq/target”目录是存放服务的jar包的，这个包是需要我们自己上传的。

在ECS上建立好目录结构以后，再回到本地的项目中，依旧是在IntelliJ IDEA的命令行中输入以下命令：

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

命令的意思是通过scp命令将刚才打包的“little-project-rocketmq.jar”文件copy 到对应ECS服务器的“/home/admin/little-project-rocketmq/target”目录中。

这里的“47.117.120.102”是我的测试地址，大家可以更换为自己申请的ECS 的IP地址。

这里需要特别说明一下，由于我在执行命令的根目录在“little-project-rocketmq”项目下面，如果你在其他的地方执行上述两条命令，需要指定好源文件的目录。

同时在使用scp命令以后会让大家输入服务器的密码，该密码可以从实战云平台上获取。

完成上面两个命令以后，服务就已经部署到ECS了。

#### **3、启动服务**

完成部署以后，需要到ECS 服务器上面启动部署的酒店管理后台的服务。还是登录ECS服务器，通过以下命令进入到“deploy.sh”文件所在的目录。

cd /home/admin/little-project-rocketmq

deploy.sh 文件是儒猿团队为大家生成的发布的脚本文件，通过Linux shell脚本完成发布的参数配置和启动命令。

包括启动应用等待的时间、应用端口号、健康检查的URL以及jar包的目录和日志信息。有兴趣的同学可以打开看看，这里就不做展开的介绍了。

保证当前目录下面存在“deploy.sh”文件，使用如下命令启动服务。

sh deploy.sh restart

命令使用了“restart”作用与“start”是一致的，用“restart”的目的以免在重复发布过程中，学员忘记是否启动过服务。因此使用“restart”，这样即便是已经启动过服务，也会重新加载服务。

另外，deploy.sh中已经加了自动化脚本，用来防止用户未指定成prod环境和更改rocketmq.namesrv.address地址的配置，默认了prod环境和当前ECS的地址:9876为namesrv的地址。这些大家只需要了解就可以了，不用做任何更改。

运行命令在看到图4所示的“success”字样的时候，就说明服务启动成功了。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf0jt00sot.png)图4启动服务成功。

如图6所示，同样可以通过浏览器输入IP地址加上端口8088 来查看健康检查服务是否工作。http://47.117.115.80:8088，其中把IP地址换成你自己的。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf15po0w9q.png)图6 访问健康服务成功

#### **4、**RocketMQ **Console的功能介绍**

根据上面描述的步骤我们已经能够娴熟地发布本地服务了。不过RocketMQ的服务是儒猿团队已经安装到ECS服务器上的，我们可以通过如下方式访问：

47.117.115.80:8080/

只需要将IP地址替换成你的ECS IP就可以了。如图7 所示，这里是RocketMQ的控制台，包括日常的OPS信息、集群（Cluster）、Topic、Consumer、Producer、Message的信息

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkf1qng06hd.png)图7 RocketMQ Console

如果大家对RocketMQ的部署和控制台感兴趣的话，可以参考儒猿团队的另外一门经典课程 [从 0 开始带你成为消息中间件实战高手](https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d887e7ea3adc_KDm4nxCm/6) 。

#### **4、**总结

本节课告诉大家通过哪些步骤将本地应用部署到ECS上，其中包括：打包服务、上传服务、启动服务。最后还介绍了RocketMQ Console的访问地址和基本功能，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week02/)给大家。

下节课会带大家进行门店和客房数据的初始化为后面的开发做好数据基础。下期见，拜拜。

### 12_准备就绪：对互联网酒店预订系统的门店客房等基础数据做好初始化

**1、开篇**

上节课我们介绍了如何打包部署互联网酒店预订系统，利用实战云平台提供的ECS我们将本地应用打包并且发布。在真正开始实践之前还有一个步骤不能少，那就是数据的初始化，数据就好像系统中流动的血液一样，失去它系统将无法运行。

因此，今天给大家介绍如何在实战云平台上进行数据的添加，以及哪些数据已经由儒猿团队提供的。那么今天要介绍的内容包括如下：

- 基础门店数据
- 添加房间数据

#### **2、**基础门店数据

在前面课程的业务逻辑中，介绍过客户需要选择酒店以后在指定房间，随后才能完成预定的操作。其中酒店和房间的基本信息需要事先在“酒店管理后台”配置好，不过针对酒店的信息由于和主体的业务操作耦合没有那么紧密，已经由儒猿团队为大家配置好了。

如图1 所示，儒猿团队已经在后台配置好了三家酒店，分别是“儒猿酒店成都分店”、“儒猿酒店深圳分店”和“儒猿酒店北京分店”，其基本信息如图中所示。这部分的配置功能就不给大家开放了，也让大家把更多精力放在核心业务上面。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkfa7qc08sc.png)图1 分店的基本信息

#### **3、**添加房间数据

上面的酒店分店数据不用我们自己添加，儒猿平台已经帮我们加好了。房间的数据会作为我们一个实战的场景，所以对应的功能是对我们学员来开放的，这里我们先初始化一下房间数据，后面在进行详细的介绍。

如图2 所示，回到小实战平台，在“房间管理”中会显示所有添加房间的列表。点击右边的按钮，选择“新增房间”就可以初始化房间的数据了。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkfc5i20nxk.png)图2 添加房间作为初始化数据

点击“新增房间”以后在弹出的页面中可以选择“所属分店”，这里的分店就是基础数据中定义好了，直接选择就行了。如图3所示，选择“所属分店”为“儒猿酒店北京分店”、“房型名称”为“钟点房”、“价格”是199、“库存信息”为9999999、以及“减库存方式”为“永不减少库存”。

特别说明一下，“库存信息”不是我们本次实战的核心，这里就默认库存9999999，减库存方式也是如此。另外，“房型图片”中的图片已经由我们的团队上传到腾讯云上了，大家可以直接选取。

 ![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkffmbr01p3.png)图3 添加房间

#### **3、**总结

本节课告诉哪些数据是儒猿团队已经提供给大家使用的，另一部分“房间”的数据需要大家自己手动添加。由于本节课是这周的最后一节，这节课的结束也意味着一切准备工作已经就绪，下周的课程将会进入代码编写的环节。

在这里也将本周的课程做一个总结，本周课程的目的是为酒店预定系统的后台API项目的搭建做前期准备，包含了如下内容：Spring Cloud Alibaba项目的初始化；对项目中依赖的基础服务依赖进行介绍；介绍了项目中所需的模块，并且以jar包的形式创建它们；教大家如何使用儒猿团队搭建的RocketMQ实战平台，在上面创建ECS并且部署实战的应用程序；

最后告诉大家有哪些基础数据的准备，以及如何初始化基础数据。这里是[本周的**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week02/)给大家，大家可以参考。下期见，拜拜。

### **13_一步一图：整体梳理互联网酒店预订系统的登录逻辑的业务流程**

**1、开篇**

经过前两周的课程内容，相信大家对互联网酒店预订系统的架构和项目搭建，初始化都有了足够的了解。

从这周开始会进行代码实战的环节，我们会先回顾业务流程，提出初步的技术实现，然后从中发现问题，调整技术实现，最后落地成代码。这周课程主要聚焦于登录的部分，这节课会带大家回顾登录酒店小程序的业务逻辑。

#### **2、**登录业务逻辑回顾

正如在第一周课中提到的登录酒店小程序的业务，如图1 所示，我们顺着箭头的方向把业务流程再回顾一遍。

客户通过“酒店小程序”进行登录，此时会将请求提交给“小程序后台”，后台在判断是否是第一次登录以后，会出现两个流程分支。

如果是第一次登录：会给对应的客户发放优惠券，同时客户可以在小程序中查询到优惠券的信息。

如果不是第一次登录：跳过发放优惠券的流程进入下面验证登录信息的处理。

无论是否是第一次登录，最后流程都会对用户进行登录验证的操作，最后返回登录结果给客户。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkb56lk01mj.png)图1 登录酒店小程序的业务流程

如果把焦点放到“小程序后台”，有三件事是需要做的：

- 判断是否第一次登录：这个好理解，客户每次登录都在数据库中记录一个状态，下次登录的时候与这个状态进行比较就可以知道是否第一次登录。如果更加细致一点其实是两个操作：检查登录状态和更新登录状态。
- 发放优惠券：可以单独作为一个功能存在，就是向用户发放优惠券，这里使用的是同步调用。在这个场景中是第一次登录就发放。当然这个功能也可以用到其他场景中，例如：消费多少金额，发放优惠券。为了能够将此功能解耦，会单独将其提出来。
- 验证登录信息：由于大家是使用微信登录系统，因此会封装微信登录的模块。由于小程序的部分功能使用开源的PHP完成，因此这部分代码不需要大家做修改，已经由系统完成。我们可以在登录的时候打上日志，方便跟踪和理解这部分功能。

#### **3、开篇**

本节课带大家把登录酒店小程序的流程走了一遍，后台API的部分拆解成三个部分：判断是否第一次登录、发放优惠券、验证登录信息（微信登录），这几个部分我们会一一给大家解答如何实现。

下节课会聚焦于微信登录。下期见，拜拜。

### **14_追根究底：来看看我们熟悉的微信登录是如何实现的？**

**1、开篇**

上节课我们将登录酒店小程序的业务拆分成三个步骤：验证是否第一次登录、发放优惠券、验证登录（微信登录），并且介绍它们之间的业务关系。

这节课主要介绍验证登录，由于使用到微信小程序，因此主要讲解微信登录是如何实现的。今天的内容包括以下几个部分：

- 小程序登录授权的流程
- 登录小程序
- 获取手机号
- 解密手机号

#### **2、**小程序登录授权的流程

小程序登录授权的流程包括三个步骤，如图1所示，从上到下分别是登录小程序、获取手机号和解密手机号。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgicla0yq7.png)图1 小程序登录授权的流程

首先是微信小程序登录，登录的目的是为了获得登录的凭证，保证登录小程序的合法性。 接下来就是手机号授权，由于安全性问题小程序中是无法直接获取学员手机号的，因此需要得到使用者，也就是学员的授权。

授权通过以后，手机号会通过加密的方式传到后端，此时有一个解密的过程，由我们的PHP开源代码完成这个过程。并且把手机号的明文传给服务器端，服务器通过手机号来识别对应学员申请的ECS 以及部署的应用，从而继续后面的实验。 

#### **3、**登录小程序

我们在登录小程序的时候，会弹出如图2所示的提示框，只有点击“登录”按钮并且同意授权的情况进行后面的操作。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgka4q0atr.png)图2 小程序登录授权

登录授权的目的是通过微信官方的登录能力获取微信的用户身份标识，快速建立小程序内的用户体系。

如图4 所示，这里从开发者的角度描述了小程序授权的全过程。我们顺着箭头的方向从左往右看一下。在获取用户授权的时候，小程序会通过wx.login（）方法获取一个code，并且把它发往开发者服务器，其通过已经申请好的appid和appsecret 加上这个code去向微信接口服务获取对应的session_key和openid。

同时将返回的信息与openid，session_key 进行管理，返回自定义登录状态。小程序拿到自定义登录状态以后保存在本地的storage中，在每次发起服务端请求的时候，都会携带上这个登录态，开发者服务器也通过这个登录态去查询用户的openid和session_key，也就是最开始用户授权时生成的信息。在通过验证以后返回业务数据，整个过程保证用户数据传输的安全。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgm5yw0hof.png)图3 微信小程序登录授权流程

#### **4、**获取手机号

前面获取了用户的授权，但是不等于能够获得用户的手机号。微信小程序如果要获取用户的手机号，也需要用户的授权（安全性要求）。由于手机号会和学员的ECS IP以及发布的服务相关，这里必须获取，于是就有了获取手机号的部分。

如图4所示，在小程序授权之后，接着会弹出手机号授权的框，其目的就是为了获取用户的手机号。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgn83s07uk.png)图4 获取手机号

获取微信用户绑定的手机号，需先调用[wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)接口。

由于需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 [button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html) 组件的点击来触发。

也就是在图4的“手机号”[button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html) 组件的 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。

#### **5、**解密手机号

由于获取的手机号为了安全性，本身是进行加密的这一点可以从获取手机号的返回参数看出。如图5所示，在返回参数中包括encryptedData的用户加密信息，以及iv的机密算法的初始向量，还有couldID敏感数据对应的云ID。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgo6lq08hi.png)图5 获取手机号返回的加密信息

尽管返回的手机号是加过密的，但是我们不必担心，因为我们使用的开源PHP程序已经帮助我们处理这些机密信息了。在后台获得小程序请求的时候，我们将看到明文的手机号。

#### **6、**总结

本节课带大家把登录酒店小程序的验证登录流程走了一遍，具体分为三个部分：登录小程序、获取手机号和解密手机号。每个过程都描述的原因和原理，大家在了解的同时也不用担心其实现过程，因为儒猿团队已经在后台代码中完成了这些功能，大家只用专注于登录的逻辑就行了。

下节课会在登录验证的基础上，考虑如何通过异步化的方式将登录、发优惠券操作进行解耦。下期见，拜拜。

### **15_谋定后动：先画图分析如何基于MQ对登录系统核心流程进行异步化改造**

**1、开篇**

上节课主要介绍了小程序的登录验证，其中包括：登录小程序、获取手机号和解密手机号三个部分。

本节课还将继续登录验证的内容，会基于MQ对登录系统的核心流程进行异步化的操作，即对登录的信息保存和发放优惠券的动作进行解耦。今天的内容包括以下几个部分：

- 传统登录流程
- 异步化登录流程

#### **2、**传统登录流程

如果要先谈异步处理流程就要先看看传统登录流程是怎样的，如图1 所示，我们把登录流程进行简化，并且把焦点放到“小程序后台”上。当用户登录的时候，会判断“是否第一次登录？”当用户满足第一次登录条件以后，后台会在数据库中记录登录的信息，然后发放优惠券。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgto1s0v73.png)图1 传统登录流程

需要注意的是，“记录第一次登录信息”和“发放优惠券”在执行上是有先后顺序的，为了方便也会把这两个功能放到一个模块里面执行。

但为了服务的高内聚、低耦合，或者通过分布式提高服务高并发能力，会将模块或者服务器切分，例如：将登录模块和优惠券模块拆分成两个服务。

服务拆分以后，服务内部保证实现对应的功能，服务的执行先后顺序可以根据业务需求进行调整。例如：可以在“记录第一次登录信息”的同时就“发放优惠券”，不用等待记录成功才进行优惠券的发放。让系统效率最优，同时让更多的服务之间可以进行组合。

#### **3、**异步化登录流程

上面介绍了传统登录的流程，大家会发现是通过同步方式进行的，登录完毕更新状态再发送优惠券，同步的方式本身就带来性能问题。为了提升登录接口的性能，同时兼顾服务的高内聚、低耦合，分布式的要求，就有了异步化的登录流程。

如图2 所示，我们将原来的一个小程序后台拆分成两个服务，分别是登录服务和优惠券服务，在图中用红色字体表现出来。注意：这里的服务分割是逻辑上的，为了整个项目方便操作和演示，我们还是将两个服务放到了一个项目中，只是通过包名来区分服务。

其中登录服务包含了LoginService（登录服务），其主要负责判断第一次登录以及记录第一次登录的信息。在完成这些操作之后会通过LoginProducer（登录消息生产者）发送登录的消息。

登录消息会被发送到RocketMQ的消息队列，这里RocketMQ就充当了服务解耦的中介者。在CouponCunsumer（优惠券消息消费者）这边，会订阅登录的消息并且获取对应的消息，进行后续优惠券的发放。

在图的最右侧用灰色的虚线框表示，因为这部分内容的实现会放到下周的课程，这里需要让大家知道实现的方式，为后面做好准备。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkgv9dy0wz1.png)图2 异步化登录流程

#### **4、**总结

本节课从登录流程作为切入点，先讲了传统的登录流程，为了做到高内聚、低耦合，分布式，就引出了异步化的登录流程。在该流程中，将登录和优惠券分为了两个服务，通过RocketMQ作为中介者在两者之间进行信息传递。

下节课会在这节课的基础上，看看如何通过代码实现上述功能。下期见，拜拜。

### 16_代码实战：基于MQ对登录系统核心流程进行异步化改造，提升系统性能

**1、开篇**

上节课主要介绍了小程序的传统登录流程和进化以后的异步化登录流程，其中通过RocketMQ将登录和发放优惠券进行了解耦，通过消息传递的方式交换信息。

今天顺着上节课的思路来把执行的代码带大家过一遍，内容包括以下几个部分：

- 会员表与实体类定义
- 登录RocketMQ 参数定义
- 登录消息生产者
- 登录服务（LoginService）
- 登录Controller 定义

#### **2、**会员表与实体类定义

在写代码之前数据是要先行，首先要定义会员的数据库表结构，和其他的表定义一样，我们这里将定义展示如图1所示，这里不逐一给大家做介绍，因为这部分的表已经在数据库后台由儒猿团队为大家建立好了。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhchhu0qkt.png)

![图片1.1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhchhr0jza.png)图1 会员数据库表结构

在了解会员数据库表结构以后，在来看看dto包中定义的实体类。如图2 所示，我们建立了LoginRequestDTO的实体类，其中包括用户id（userId）、用户名称（nickName）、手机号（phoneNumber）、token、小程序id（beid）。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhd7jc046d.png)

图2 会员dto实体类定义

#### **3、登录**RocketMQ 参数定义

由于我们要使用RocketMQ的功能发送消息，就需要对其的基本参数进行定义。如图3所示，这里定义了RocketMQ topic、producer和consumer的group参数，同时也定义了RocketMQ的namesrv的地址。

需要注意的是，这个服务器的地址不需要大家手动修改了，在部署项目的时候已经在deploy.sh 文件中自动为大家做修改了。这里配置出来是让大家知道，RocketMQ服务器的地址也是必填项。 

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhdt3n0wdc.png)图3 RocketMQ参数定义

#### **4、**登录消息生产者

如4所示，我们在producer包下面建立了LoginProducerConfiguration，这个类的目的是用来启动loginMqProducer，也就是登录消息的生产者，启动producer 以后就能通过这个生产者在需要的时候发送MQ消息了。

这里利用@Configuration标签在项目加载的时候，就执行loginMqProducer 方法返回DefaultProducer，可以从@Bean的标签看出它被注册成为一个Java Bean。 其中使用了两个变量namesrvAddress，它是RocketMQ服务器的地址，这个会去读配置文件。另外，就是loginProducerGroup这个是MQ生产者（Producer）的组（Group）。 

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhegl40wcy.png)图4 LoginProducerConfiguration 启动登录消息生产者服务

#### **5、**登录服务（LoginService）

回到LoginService，这里我们需要定义一个登录服务的执行接口，然后再完成它的实现。如图5所示，在LoginService 接口中，定义了两个方法。分别是firstLoginDistributeCoupon  ，它传入的参数是loginRequestDTO，用来处理第一次登录分发优惠券。

另外一个方法是resetFirstLoginStatus，其传入参数是phoneNumber，调用这个方法可以将用户的第一次登陆状态重置，主要是方便我们反复测试“第一次登录”的功能。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhf6kf0n3w.png)图5 LoginService 接口

看完了接口再来看对应的实现，如图6所示，创建一个LoginServiceImpl类，这个类实现了LoginService 接口，因此也会实现接口中对应的两个方法。

先来看firstLoginDistributeCoupon方法，这个方法体内会先调用isFirstLogin方法查看是否第一次登录，这个方法的内容比较简单，就是从数据库中获取对应用户登录的信息，判断是否第一次登录。如果不是第一次登录会返回对应的信息。

接下来针对第一次登录的情况，会调用updateFirstLoginStatus方法，这个方法也是更新数据库中的用户表，将登陆状态设置为已登录。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhfus10slb.png)图6 LoginServiceImpl执行LoginService接口中的方法

firstLoginDistributeGoupon中比较重要的方式就是sendFirstLoginMessage，它主要负责调用login的producer 往RocketMQ的队列中发送登录消息的。让我们凑近点看看这个方法，如图7所示，方法中定义了RocketMQ Message的实体，并且设置了对应的topic（loginTopic），这个topic 来自properties的定义。最后通过loginMqProducer的send方法将message发送到RocketMQ对应的Topic中，从而等待下游服务中的consumer进行消费。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhjckj0wdv.png)

图7 发送MQ消息

#### **6、**登录Controller 定义

在服务定义完毕以后，就是最后一步定controller了，这里会将服务通过RESTFUL API的方式暴露给小程序使用。如图8所示，这里定义了wxLogin的Post方法，用来处理第一次登录。其中调用了logService中的firstLoginDistributeCoupon方法。

另外一个就是resetFirstLoginStatus方法，它是一个get方法。其作用是方便大家反复测试“第一次登录”功能的。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhjtvg0tpx.png)图8 登录controller定义

如图9 所示，通过get请求，如下URL ：

http://ecs公网ip:8088/api/login/resetLoginStatus?phoneNumber=用户手机号

在点击“Send“ 按钮以后，就得到了返回结果，”code：200“ 说明重置登录已经完成。用户在使用重置的手机号登录，系统会认为是第一次登录。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkhknl0073g.png)图9 使用postman 请求reset login

#### **7、**总结

本节课进入登录流程的代码实践环节，讲述了实体类定义、登录RocketMQ参数和生产者定义、登录服务和登录Controller的定义。

截取了重要的代码给大家讲解，下节课会在这节课的基础上验证代码，看看在实际中能否跑通。这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week03/)先放给大家，有兴趣的同学可以根据前面学习的知识自己部署一下。

如果没有时间也没有关系，我们下节课也会带大家跑一次。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **17_阶段测试：提交代码后，验证一下改造后的登录逻辑是否走通**

**1、开篇**

上节课主要介绍了小程序后台如何实现登录异步化的代码实现，包括实体类定义、RocketMQ消息生产者定义、以及LogService和Controller的定义。

今天在上节课完成代码的基础上，带大家将代码部署并且上线测试。今天课程的内容包括以下几个部分：

- 申请ECS 
- 打包部署
- 启动服务
- 验证登录功能

#### **2、**申请ECS 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/login“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**验证登录功能

在确认服务启动以后，我们需要登录小程序验证登录功能。如图8所示，使用微信扫描二维码登录酒店小程序。注意：这里微信绑定的手机号需要和购买实战课程的手机号是同一个才能测试功能。

![图片8.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjusom03xz.jpg)

图8 酒店小程序二维码入口

扫描以后会看到如图9所示的授权页面，需要点击“登录”按钮进行授权。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkk0m830q3j.png)

图9 登录授权

授权完毕以后，还会看到如图10所示的手机号授权页面，因为需要通过学员的手机号去匹配申请的ECS所以，这里必须执行这一步。在点击“手机号”以后确认获取手机号的信息。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkk12pk0mlw.png)

图10 获取手机号

在授权登录和获取手机号之后，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图11 所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到两条信息：

\1. 用户登录成功（login success user info），返回了用户的昵称、手机号和对应的小程序号

\2. 发送登录成功的消息提醒（start send login success notify message）。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkk22fb0vpf.png)图11 登录成功和发送消息成功

在完成登录授权和获取手机号以后，就登录到了酒店小程序。如图12 可以根据酒店关键字、日期范围“查询酒店”。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkk2iu20w8x.png)

图12 查询酒店信息

如图13 在查询酒店结果的页面可以看到三个分店的信息。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkk5q1s0pbh.png)

图13 分店信息。

至此我们就完成了登录代码的发布以及测试。前面提到的登录和发放优惠券异步化的功能，会在发放优惠券功能完成以后一并给大家演示。

#### **6、**总结

本节课带大家从打包、发布、启动服务几个步骤将登录功能演示了一遍。作为本周课程的最后一讲，这里将一周的课程做一个总结。

本周从登录功能作为酒店实战的起点，先讲解了登录的业务流程，然后从微信登录的实现原理说起，逐步推进到登录异步化，之后带大家通过代码实现整个登录过程，在最后将实现的代码进行打包、发布、启动并且测试最终的结果，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week03/)给大家。

从下周开始我们将进入优惠券模块的开发。下期见，拜拜。

### **18_一步一图：整体梳理酒店预订系统之优惠券管理模块的业务流程**

**1、开篇**

上周的课程我们将登录流程带大家跑了一遍，并且通过业务分析、登录详解、异步请求、代码实践、验证结果几个环节展现了整个过程。

这周的课程将延续上周的思路，不过主角换成了发放优惠券，当优惠券的Consumer 接受到了登录消息以后会进行哪些操作呢？就让我们进入本周的课程吧。今天课程的内容介绍发放优惠券的业务流程。

- 发放优惠券的业务流程
- 优惠券初始化

#### **2、**发放优惠券的业务流程

在介绍登录服务的时候，我们用了一张大图介绍其业务流程，相信大家对这张图应该有印象。如图1 所示，先回顾一下灰色的部分，也就是上周课程中提到的部分。

在客户登录“微信小程序”以后，判断是否第一次登录，然后记录第一次登录的信息。随后，会通过LoginProducer发起一次消息，这个消息会通过消息队列RocketMQ发送到CouponConsumer中。

此时，CouponConsumer作为优惠券消费者接收到这个消息，会进行“消费第一次登录消息”的动作，从而调用CouponService去执行“发放优惠券”的动作。在“发放优惠券”以后，客户就可以通过微信小程序看到对应的优惠券信息了。

不过这部分的功能没有画在下图中，代码的实现已经由儒猿团队在PHP端实现了。大家可以理解为“发放优惠券”会将优惠券保存到用户优惠券表中了，PHP代码只是做了简单的查询动作。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkkyzbf0rwa.png)图1 发放优惠券

从上图的颜色可以分辨，将上一周课程的内容用灰色内容标注出来，橘黄色和蓝色的部分是我们需要关注的部分，也是这周学习的重点。

在本节课中只是将业务流程进行梳理，后面会实现对应的业务代码，并分析发放优惠券为啥会存在重复发放的问题，如何通过Redis来保证优惠券不会重复发放。最后依旧是带领大家过一遍，通过实践的方式去验证最终的结果。

#### **3、**优惠券初始化

在使用优惠券之前需要对其进行初始化，针对初始化的操作不需要大家进行任何操作，已经有儒猿团队完成。这里我们提供几个初始化的界面让大家知道其过程，如果以后开发类似的功能可以参考进行。

如图2 所示，在儒猿团队提供的后台中可以添加优惠券信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkkzsq907cg.png)图2添加优惠券

在点击“添加优惠券”之后会弹出如图3的内容，可以选择优惠券的种类、类别、类型、名称、参数设置、有效期、数量、状态、使用范围、优惠说明、排序等一些列信息。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkl0tso095m.png)图3 优惠券详细信息

在完成添加以后，会通过图4中的内容，在优惠券的列表中会显示刚刚添加的优惠券。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkl19ow04cx.png)图4 优惠券列表

虽然上述添加优惠券的过程并不需要大家进行操作，但是需要了解这个过程，帮助我们有逻辑地进入后续的优惠券发放。

#### **4、**总结

这节课是本周的第一节课，重点是介绍发放优惠券的业务流程，并且介绍了与登录流程之前的关系，同时讲述了优惠券初始化的过程。

通过一张大图告诉大家需要关注的重点，后面会着重介绍“消费第一次登录消息”和“发放优惠券”功能上。课程还会聚焦优惠券重复发放的问题，并且提出Redis的幂等性方案。

下节课我们开始针对发放优惠券的代码实现。下期见，拜拜。

### **19_代码实战：尝试着给首次登录的用户，发放一张优惠券**

**1、开篇**

上节课将发放优惠券的流程和大家过了一遍，其中提到了“消费第一次登录消息”和“发放优惠券”是业务中需要实现的重点。今天就带大家从代码实战的角度来实现上述功能。今天课程的内容如下：

- 数据库表设计与实体类
- 定义优惠券消费者（CouponConsumer）
- 实施消息监听（FirstLoginMessageListener）
- 分发优惠券（DistributeCoupon）

#### **2、**数据库表设计与实体类

根据数据与实体先行的原则，首先定义优惠券相关的数据库表结构。如图1所示，这里定义了“t_coupon”表，其中字段我们不逐一介绍，每个字段定义后面对应了备注信息，大家可以自行阅读。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklmydz0l5a.png)

图1 coupon 表结构

如果说coupon表是记录优惠券基本信息的话，那么coupon user 表就是记录优惠券与用户关系的。如图2 所示，”t_coupon_user”表的表结构中，记录 phone_number 和coupon_id 的信息，这张表就建立了用户和优惠券的关联。换句话说当把优惠券发放给某个人时，就会在这张表中进行记录。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklniqv0jyi.png)

图2 coupon user 关联表

数据库表的定义之后，我们回头到项目中查看实体类的定义。如图3所示，在“/api/coupon/dto”下面定义了“FirstLoginMessageDTO”的实体类，从名字上看它是用来获取RocketMQ中关于第一次登录消息的。Message包含：userId（用户ID）、nickName（用户名称）、beid（小程序id）以及phoneNumber（用户手机号）。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklnz8n0hvn.png)

图3 FirstLoginMessageDTO

#### **3、**定义优惠券消费者（**CouponConsumer）**

实体类定义的是第一次登录的队列消息（FirstLoginMessageDTO），为了接受这个订阅消息需要定义与之对应的CouponConsumer，也就是优惠券消费者。如图4所示，在”coupon/consumer/“中定义CouponConsumerConfiguration”，用配置的方式初始化一个“DefaultMQPushConsumer“。

在类中定义了一个loginConsumer方法，在@Bean的annotaion中可以得到是用来监听登录消息的。需要注意的是在@ Qualifier的annotation中定义了具体的监听器名称：“firstLoginMessageListener”。也就是说在CouponConsumer启动以后，是由这个监听器来处理具体RocketMQ的登录消息的。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklpc0n0fgz.png)图4 定义优惠券消费者

与登录中的producer相同，针对loginConsumer 也需要定义RocketMQ的NamesrvAddr、topic等信息。最后需要通过start方法启动consumer，此后就可以通过“firstLoginMessageListener”的监听方法获取登录发过来的信息了。 

#### **4、**实施消息监听（**FirstLoginMessageListener）**

有了CouponConsumer 作为第一次登录消息的消费者，就要提供一个处理消息的监听者FirstLoginMessageListener，说白了它需要对消息进行处理。如图5所示，在api/coupon/listener下面定义了FirstLoginMessageListener类，其中有一个consumerMessage方法，就是用来对消息进行处理的。

在传入参数是一个Message的List，通过for函数对这个List进行遍历，解析Message的内容为FirstLoginMessageDTO，从而获取userId（用户id）、phoneNumber（手机号）等信息，通过调用couponService中的DistributeCoupon方法进行优惠券的分发。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklrimo0x0f.png)图5 FirstLoginMessageListener

#### **5、**分发优惠券（**DistributeCoupon）**

有了前面建立CouponConsumer、FirstLoginMessageListener作为消息接受和处理的类作为基础，最后来到了具体处理分发的CouponServiceImpl。

如图6所示，这里定义CouponService作为分发服务的接口，其中定义了distributeCoupon的方法，照例由于CouponServiceImpl集成这个接口并且实现这个方法。

在distributeCoupon方法中输入参数：beid（小程序Id）、userId（用户Id）、优惠券Id（couponConfigId）、优惠券有效天数（validDay）、订单Id（sourceOrderId）以及电话（phoneNumber）。

而后面的代码通过组件MySqlRequestDTO对象，并且拼装insert SQL 语句，交由MySQLApi 执行对应的SQL语句，完成数据库的保存工作。需要注意的是，这里操作的是”t_coupon_user”表，也就是保存了用户和优惠券之间的关系。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klklsrgq0h1o.png)

图6 DistributeCoupon

#### **6、**总结

这节课从数据库表结构和实体类的设计说起，介绍了如何建立优惠券的消费者，消费第一次登录的信息。然后，通过监听该消息，将消息中关于用户和优惠券的信息进行提取并且保存到数据库中。

下节课我们带大家验证上述代码实践。这里依旧将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)先开发给大家参考，大家可以自己尝试部署，下节课我们也会带大家一起部署测试代码。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **20_停下脚步：先验证一下系统优惠券是否到账？**

**1、开篇**

上节课将发放优惠券的代码实现给大家过了一遍，包括数据库表结构和实体类设计、优惠券的消费者、监听器的建立、保存用户和优惠券的关联信息等。今天就带大家把编写的代码进行验证。今天课程的内容如下：

- 申请ECS
- 打包部署
- 启动服务
-  验证优惠券功能

#### **2、**申请ECS 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/login “。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 j

ar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务



#### **5、**启动服务验证优惠券功能

在确认服务启动以后，我们需要登录小程序验证登录功能。如图8所示，使用微信扫描二维码登录酒店小程序。注意：这里微信绑定的手机号需要和购买实战课程的手机号是同一个才能测试功能。

![微信二维码.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmivrg01q6.jpg)

图8 酒店小程序二维码入口

扫描以后会看到如图9所示的授权页面，需要点击“登录”按钮进行授权。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmlxu008yz.png)

图9 登录授权

授权完毕以后，还会看到如图10所示的手机号授权页面，因为需要通过学员的手机号去匹配申请的ECS所以，这里必须执行这一步。在点击“手机号”以后确认获取手机号的信息。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmmels0s73.png)图10获取手机号

在授权登录和获取手机号后，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图11 所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到以下几条消息：

1. 用户登录成功（login success user info），返回了用户的昵称、手机号和对应的小程序号。

2. 检查第一次登录的状态，从而判断是否第一次登录。

3. 生产者发送登录成功的消息提醒（start send login success notify message）。

4. 消费者接受第一次登录的消息。

5. 发放优惠券，记录用户和优惠券信息到数据库中。 

   ![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmn94i0n2y.png)图11 登录成功和发送消息成功

这里需要注意的是，如果在上周课中已经进行过“第一次登录”的同学，系统会记录手机号的信息这里就不会走“第一次登录”的逻辑来，因而也不会发送“第一次登录”的消息到RocketMQ。

在这种情况下，为了模拟出“第一次登录”的效果，可以通过调用我们提供的reset login的 API，来将已经登录过的手机号还原成没有登录的状态。如图12 所示，通过Postman发起get请求输入如下URL

http://ecs公网ip:8088/api/login/resetLoginStatus?phoneNumber=用户手机号

在点击“Send“ 按钮以后，就得到了返回结果，”code：200“ 说明重置登录已经完成。用户在使用重置的手机号登录，系统会认为是第一次登录。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmogzx0hy7.png)图12 使用postman 请求reset login

重置手机号为“未登录”状态以后，再进行优惠券的查看。如图13所示，在酒店小程序中点击“我的优惠券”进入优惠券的页面，可以看到“首次登录优惠券”的信息，并且标注的使用状态和过期状态，减免金额以及开始、结束时间。

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkmp3lg062i.png)

图13 我的优惠券-首次登录优惠券

至此就走完了首次登录，发放优惠券的流程，并且通过RocketMQ 消息传递的方式对两个模块进行了异步化。

#### **6、**总结

这节课带大家验证了首次登录以后获取优惠券的过程，包括：申请ECS服务器、打包部署、启动服务、优惠券初始化、验证优惠券功能。这里依旧将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)先开发给大家参考。下节课我们思考优惠券重发的问题。下期见，拜拜。

### **21_打开脑洞：思考一下如果优惠券重复发放了，怎么办？**

**1、开篇**

上节课在实施优惠券代码的基础上将其执行结果带大家跑了一遍，不出意外的话大家在模拟第一次登录酒店小程序之后就可以在“我的优惠券”中收到首次登录的优惠券了。优惠券是个好东西，利用的好可以起到增大销量、提高酒店知名度的作用。

但是如果过多发放优惠券，特别是一次登录重复发放多张优惠券就损失酒店的利益了。今天就来讨论是否存在一些场景会导致优惠券重复发放的情况呢？ 

#### **2、**生产者重复发送消息

为了搞清楚重复发送消息的场景，我们回到最终的业务流图中。如图1所示，我们将关注的部分加上了颜色，从左往右来介绍这种场景。最左边橙色的LoginProducer作为第一次登录的消息生产者起到了发送消息的作用，但是由于网络抖动等原因会造成重复发送消息。

例如：这里由于网络抖动，LoginProducer 就发送了两条“登录消息”，分别是“登录消息1”和“登录消息2”。因此，RocketMQ中也保存了上述的两条消息，在CouponConsumer这一端就会监听到两条信息，并且依次对两条消息进行处理。

处理的过程在前面也有讲过是记录用户与优惠券之间的关联，由于处理两次消息，自然就记录了两条关联记录。因此，最后的结果就是CouponService为“第一次登录”分配了两张优惠券。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klku4xg30j8t.png)

图1 消息生产者重复发放消息

 3**、消费者重复处理消息**

上面提到了生产者重复发送消息的场景，这里再来补充一种消费者重复消费的场景。如图2 所示，这次的主角切换到了消费者。

我们从蓝色的部分开始看，CouponConsumer在消费完“第一次登录”的消息之后会给RocketMQ的broker返回CONSUMER_SUCCESS，即当前consumer消费了登录topic中的消息成功提交消息offset；

但是当CouponService组件下发优惠券成功后，consumer端返回broker CONSUMER_SUCCESS时网络抖动或者consumer消费消息后故障，导致broker没收到消费成功的响应即消费者提交offset失败。

当网络恢复或者CouponConsumer重新启动的时候，发现队列指向的offset依旧指着刚才处理的那条“登录消息1”，因此又将该消息处理了一次。因此就造成了在CouponService 中发放了两次优惠券的情况。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klku6jq909xj.png)

图2 消费者重复消费消息

#### **4、**消息处理的幂等机制

实际上除了上面两种场景应该还有其他的可能性造成消息重发，或者消息处理多次。我们无法针对每种情况想出对策，不过可以根据幂等性原则来思考这个问题。也就是无论消息被发送多少次，或者消息被反复处理多少次，最后只对同一条消息进行一次处理。

换句话说即便是RocketMQ的消息队列中积累了上百条消息，只要他们是相同的消息，例如：针对同一个账号的第一次登录，优惠券只会发送一次，永远不会重复。

#### **5、**总结

这节课从消息的生产者和消费者两个角度分析了优惠券重发的场景，有可能生产者产生了两条消息，也有可能消费者针对同一条消息消费了两次。最后的结果都是处理了两次优惠券的业务，导致优惠券重发。

既然发现存在这样的可能性，就应该想出对策，下节课我们会引入Redis的幂等机制，保证优惠券不会重发。下期见，拜拜。

### **22_代码实战：基于redis幂等机制，保证优惠券不会重复发放**

**1、开篇**

上节课讨论优惠券重复发送的场景，无论是生产者场景还是消费者场景最后的结果都是会因为同一条消息获得多张优惠券。从而引出了幂等性的问题。今天的目的就是解决幂等性问题，不让优惠券重复发放，内容如下：

- 通过Redis 解决幂等性问题的思路
- 代码中如何使用Redis解决问题 

#### **2、**通过**Redis 解决幂等性问题的思路**

依旧回到处理流程图中，解决优惠券发放幂等性的问题需要回到消费者处理消息本身。作为优惠券消息的消费者CouponConsumer需要从RocketMQ的队列中获取消息，在上节课中介绍的两种情况中：

1. 因为网络抖动生产者（LoginProducer）产生了重复的消息，CouponConsumer会重复消费两条消息。
2.  消费者（CouponConsumer本身）由于下线没有通知broker CONSUMER_SUCCESS，导致重启后重复消费。

如图1所示，如果在消费者（CouponConsumer）每次处理消息的时候都将这个消息存放到Redis上进行缓存，在每次发放优惠券之前都会询问“是否存在相同消息？”，只有在“否”的情况下才执行“发放优惠券”。这里的“否”也就是不存在相同优惠券的意思，于是就避免了优惠券的重复发放。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllpbkh102fg.png)图1 优惠券消费者在消费消息之后会setnx 写入Redis缓存

#### **3、代码中如何使用Redis解决问题**

整理好思路我们回到项目代码中，在api/coupon/listener 下面的FirstLoginMessageListener中有一个consumeMessage方法，它是用来接受“第一次登录”消息的，在原来的代码设计中这里是直接更新用户和优惠券关系表的。

这里，我们加入存入Redis的部分，通过redisApi.setnx方法（已经由儒猿团队进行封装）将消息信息保存到Redis中。设置了“第一次重复登录”的前缀+用户Id（userId）作为Key，后面的用户名（userId）、电话号码（phoneNumber）作为Value。

利用setnx的函数特性，当reponse返回成功“SUCCESS”并且data为”FALSE“说明Redis中对应的Key已经有Value 了，也就说明Redis中已经存在这条消息了，消费者已经处理过这条“第一次登录”的记录了。这种情况下，只记录一个日志，而不进行后续的操作。

如果返回的是“SUCCESS”并且data为“true”，说明Redis没有记录这条消息，也就是消费者第一次处理这个消息，那么就需要更新数据库中用户和优惠券的关系，从而完成给用户发放优惠券的操作。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllpdebr0h8x.png)图2 利用redisApi中的setnx 判断消息是否处理过

#### **4、**总结

这节课介绍了Redis缓存解决幂等性的思路，同时在原有的项目代码中加入Redis判断的部分，利用setnx函数的特性判断是否第一次消费登录消息。照例我们将测试的[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_22讲/)分享在这里。

其实以上代码还存在一个问题，当redis宕机后如何去保证幂等？常用的兜底方案数据库唯一键，本案例中下发优惠券则需要用户id+优惠券id组成唯一键；这里说明一下，本实战项目幂等模块都只是简单通过redis来保证幂等不考虑兜底方案，大家在公司中实战时需要考虑兜底方案。

下节课我们会带大家将代码进行验证。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **23_阶段测试：验证引入幂等之后，能否保证优惠券不会重复发放？**

**1、开篇**

上节课讨论优惠券重复发送场景的解决方案，同时使用Redis的代码实现落地了这个方案。由于Redis中setnx 函数的加持，让我们方便地判断缓存中的消息是否被处理过。今天就来验证一下上节课的代码，内容如下：

- 验证思路
- 验证重复发放优惠券场景
- 验证引入Redis幂等机制后的优惠券场景

#### **2、**验证思路

在前面的课程中我们描述了两个消息重发的场景，分别是：生产者发送消息重试机制和consumer端消费成功了但是返回consumer_success时宕机了broker没收到。

但由于这两种场景都比较难模拟，我们这里通过重置是否第一次登陆状态来测试重复发券问题，为了方便验证对比，这里会涉及到两套代码：一套代码是没有引入Redis进行幂等性处理的，我们把这套代码叫做“[**无Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)”；

另外一套则是引入Redis从而避免重复发放优惠券的，我们将其称作为“[**有Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_22讲/)”。开始的时候我们会部署“无Redis版本”，然后登录酒店小程序，此时会收到一张优惠券。然后通过ResetLogin 的API，重置用户的登录信息，模拟用户第一次登录的场景，再次登录的时候则又会收到一张优惠券。

这也说明“无Redis版本”是不具备幂等性处理能力的。接下来，我们部署“有Redis版本”，部署完毕以后依旧使用ResetLogin 的API，重置用户的登录信息，模拟用户第一次登录的场景，然后再登录，此时就不会再收到优惠券了。“我的优惠券”只能仍旧是两张，优惠券的数量没有增加。

#### **3、**验证重复发放优惠券场景

这个思路的过程是先重置登录，然后登录酒店小程序，此时由于是第一次登录所以会收到优惠券。接下来，再次重置登录，再次登录酒店小程序，有没有考虑幂等性系统还会给我们发送一次优惠券。

这里把操作步骤罗列如下，其中一些基本操作，例如：申请ECS、打包发布之类的就一笔带过，我们把重点放到酒店小程序看到的优惠券结果，以及后台日志打印的消息内容。

1. 申请ECS服务器获取登录密码。
2. 在本地项目中将“[**无Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)”打包，并且通过scp命令发送到ECS服务器上。
3. 登录ECS服务器通过deploy.sh 脚本启动后台服务。
4. 扫描小程序的二维码登录，酒店小程序。
5. 在登录小程序之前，通过Postman请求resetlogin的API，重置登录信息，保证此次是“第一次登录”。
6. 登录酒店小程序进行小程序授权和获取手机号以后，在“我的优惠券”中可以看到一条优惠券的信息。
7. 回到ECS服务器，通过“vim /home/admin/little-project-rocketmq/logs/start.log” 命令，发现如图1 所示的信息。其中包括如下：

- 生产者发送登录成功消息
- 消费者接受登录成功消息
- 保存用户优惠券的关系

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllr9pfz00qs.png)

图1 第一次登录获取优惠券消息

依旧是这个日志在往下翻一会，会发现在晚一点的时间，又出现了上述的三条消息，说明生产者发送了两次“第一次登录”的消息，消费者处理了两次，数据库也保存了两次。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllra17n0gc5.png)

图2第二次登录获取优惠券消息

此时回到酒店小程序，如图3 所示，看到两张优惠券的信息。需要注意的是，如果之前你申请过一次优惠券了，进行上面7步操作以后就会得到3张优惠券，也就是说会在你之前优惠券的基础上+1张优惠券。这就是没有经过幂等性处理的结果。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllrab0b0e9l.png)

图3 酒店小程序中出现两张优惠券

#### **4、**验证重幂等性处理以后的优惠券场景

前面利用“[**无Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)”发布的后台API程序，模拟了“重复登录”收到两张优惠券的场景。这里引入“[**有Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_22讲/)”其考虑了幂等性的问题，因此无论“重复登录”多少次优惠券的数量都不会增加。依旧重复打包、发布的7个步骤在日志中查看结果。

日志中依旧存在生产者发送登录消息和消费者消费登录消息，不过没有存储用户与优惠券关系的记录了，取而代之的是“duplicate consumer first login message userId：XXXX”。这里是由于使用了Redis 保存了消费的消息，在执行发放优惠券的时候判断是否该消息是否处理过。如果处理过，就不用再次发放了，同时抛出上面这句话作为日志记录下来。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllrf4os0jmv.png)

图4 加入幂等性判断以后的日志

#### **5、**总结

这节课验证了Redis处理优惠券发放幂等性的问题，通过“[**无Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_19讲/)”和“[**有Redis版本**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week04_22讲/)”版本的比较，清楚地验证了整个解决过程。这节课是本周课的最后一次，这里对本周课做一次总结。

本周从优惠券的业务流程作为切入点，通过代码实现完成了这一功能。在完成功能的同时思考了优惠券重复发放的问题，从而引出了Redis幂等性的解决方案，在修改代码加入Redis的判断以后，就针对修改前后的两个版本进行了比较验证。

下周的课程给大家介绍客房管理模块，下期见，拜拜。

### **24_一步一图：对项目中的酒店管理模块的业务流程整体梳理**

**1、开篇**

上周的课程着重介绍了优惠券发放的功能，这周的课程将关注点放到客房管理模块。分别会介绍酒店管理、客房管理的业务流程、同时会引出高并发下客房查询的问题，以及采取多级缓存的应对机制。

今天开始本周的第一次课，让我们来了解酒店管理模块的业务流程，内容如下：

- 酒店管理模块关系
- 酒店管理
- 房间管理

#### **2、**酒店管理模块关系

在本项目中存在酒店后台管理和酒店小程序两个操作入口，酒店后台管理员会通过酒店后台管理系统对酒店管理和房间管理模块进行操作。

如图1 所示，管理员通常会将这两部分的数据进行配置，其中酒店管理的配置已经由儒猿团队实现初始化好了，不用学员进行额外配置。从图中可以看出房间管理由一条红线连接到酒店管理，说明房间管理依赖于酒店管理，学员在添加房间的时候会选择对应的酒店信息。

在客户登录酒店小程序的时候，会通过查询酒店调用酒店管理模块获取酒店的基本信息，然后通过查询房间模块获取房间管理的信息。图中右下方的两个蓝色模块会对左上方两个橙色模块产生数据上的依赖。本节课的内容聚焦于左上方的两个模块。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxcd0202p2.png)

图1 酒店管理与房间管理

#### **3、**酒店管理

正如上面提到的酒店管理模块作为基础数据模块已经由儒猿团队完成初始化，如图2 所示，我们可以看到这里已经生成了三个基本的酒店信息，分别是儒猿酒店成都分店、深圳分店和北京分店。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxe2tr0tu0.png)

图2 酒店列表

如图3 所示，这里是添加分店的页面，可以输入分店名称、排序信息、营业状态、分店头像、分店图片、服务标签、客服电话、详情介绍、分店地址、详细地址等信息。对分店进行描述，这个界面从儒猿小实战平台是无法看到的，大家对此有一定了解就可以了。在实际应用中，这些基础配置界面都是需要开发的。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxeojd0qzr.png)图3 添加分店

#### **4、**房间管理

有了酒店管理模块作为基础，房间管理模块就可以进行配置了。如图4所示，可以登录儒猿小实战平台，通过左侧菜单中“房间管理”进入该模块。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxfjeq043o.png)

图4 房间管理菜单

进入模块以后会看到房间的列表信息，如图5所示，这里列出房间的基本信息：分店名称、房型名称、房型图片、房型状态、售价价格、库存，在最左边还提供了编辑和删除的功能。房间管理中的分店信息就是在图2的时候已经配置好的，这里直接使用了。同时如果需要添加房间可以点击右上角的按钮。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxo1a70sot.png)图5 房间列表

如图6所示，在弹出的窗体中列出添加房间需要输入的基本信息。包括所属分店、房型名称、价格、每日库存、减库存方式、房型图片等。输入对应信息以后点击提交就可以添加房间了。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxoge20ldb.png)

图6添加房间

#### **5、**总结

本节课主要介绍酒店管理和房间管理在后台管理系统中的配置部分，酒店管理是房间管理的基础，其初始化已经由儒猿团队完成，而房间管理在儒猿小实战平台上可以进行配置，学员可以根据喜好对房间信息进行加工处理。

下节课介绍客房管理模块在小程序中的应用，下期见，拜拜。

### **25_一步一图：对项目中的客房管理模块的核心逻辑整体梳理**

**1、开篇**

上节课主要介绍了酒店管理和房间管理在酒店后台管理系统中的业务流程，酒店管理作为初始化数据，而房间管理在其之上可以有学员自行配置。今天我们把目光移向酒店小程序，在这里客户会通过酒店搜索，房间查询的方式获取对应的房间信息，从而选到心仪的房间。

#### **2、**酒店小程序中房间搜索流程

在酒店小程序中会使用酒店管理后台系统中提供的分店信息和房间信息，其执行的流程也比较简单：首先根据条件查询酒店，在列出的分店列表中选择分店，然后在房间列表中选中对应的房间。下面就在小程序中把上面的流程走一遍。

如图1 所示，进入小程序以后登录授权和获取手机之后，会看到酒店查询界面。其中，可以通过酒店名称或者关键字、附近信息以及入住和退房日期等查询信息来获取的酒店信息。在选择好查询条件以后，点击“查询酒店”便进入酒店列表。
![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllxxmde0ew0.png)

图1 查询酒店

在点击“查询酒店”以后就进入了酒店列表页面，在这里列出了所有满足条件的酒店信息。如图2所示，下列的三个分店都是儒猿团队在后台初始化好的，每条酒店记录都由酒店图片、酒店名称、酒店地址、距离以及房间起价几个字段组成的。同时可以根据价格和距离对其进行排序。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klly2mbs0wzf.png)

图2 酒店列表

在查询出来的酒店列表中选择一个酒店便可以看到其具体的房间信息，如图3所示，我们点击“儒猿酒店北京分店”，在酒店详细信息包括酒店名称、酒店地址和联系电话。同时将查询时的入住和退房时间也一并显示出来。

在“房型列表”中列出该酒店所包括的房型信息，这个信息是在酒店后台管理后台中由学员自行配置的，这里我们配置了一个房型记录为“test01”，可以看到房型图片、房间面积、床的类型、以及早餐数量和价格信息等。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kllyhevm0pyn.png)

图3 房间列表

通过上述的查询酒店->酒店列表->房型列表三个步骤的操作就能够查询到房间信息。其中酒店信息和房间信息是已经在酒店管理后台中已经配置好的，这里只是显示对应的内容。

#### **3、**总结

本节课将焦点从酒店管理后台转向酒店小程序，通过查询酒店、展示酒店列表、选择酒店、展示酒店房型等几个操作，带大家认识了在酒店小程序端的业务流程。

下节课会从查询房间信息为切入点，假设在高并发下会遇到的查询瓶颈问题，并且想出对策。下期见，拜拜。

### **26_技术挑战：如何解决客房详情数据在高并发查询下的热key问题？**

**1、开篇**

上节课主要介绍了小程序端如何查询酒店、选择酒店、显示对应房间信息的过程。今天需要从房间信息作为切入点，思考一下获取信息的路径是什么，如果在高并发下面如何高效获取房间信息。今天会学到如下内容：

- 传统获取房间信息的方法
- 使用Redis缓存房间信息
- 使用JVM 进程内缓存房间信息

#### **2、**传统获取房间信息的方法

说到房间信息的获取，可以通过图1 所示看出，在酒店小程序端向酒店程序后台API发起获取房间信息的请求，后台API通过HotelRoomService的服务通过数据库返回对应的房间信息。其过程如下：

\1. 酒店小程序发起获取房间信息请求。

\2. 酒店小程序后台API，通过服务HotelRoomService查找房间信息，从数据库中得到信息并且返回给小程序。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm0asg6010s.png)

图1 传统获取房间信息的方法

这种方法直接从数据库中获取信息，一旦请求并发亮上来了，数据库无疑就成为系统的瓶颈。

#### **3、**使用Redis缓存房间信息

因此，通过改造在酒店小程序后台API这一层加入Redis缓存，用来缓存酒店房间的信息。这样数据在请求HotelRoomService的时候不用先请求数据库，而是就近请求Redis缓存。由于Redis缓存在内存中，因此比磁盘上的数据库有更高的响应能力。

如图2 所示，房间信息请求顺序如下：

1. 酒店小程序通过酒店小程序后台API中的HotelRoomService获取房间信息。
2. HotelRoomService首先去询问Redis缓存中是否存在该房间信息，如果存在房间信息就直接返回给小程序。
3. 如果Redis中不包含房间信息，再请求数据库，并且返回信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm0dr5m0fwk.png)

图2 加入Redis 缓存房间信息。

这种方式讲数据从磁盘搬到了内存中，加快了数据的查询效率，在高并发中提高了用户获取数据的速度。如果并发量再次增大，是否还有更好的方案呢？答案是采取JVM进程内缓存。

#### **4、**使用JVM 进程内缓存房间信息

众所周知数据存放在离客户最近的地方就能更快地响应客户的请求，上面我们讲数据从磁盘搬到了内存中，但毕竟HotelRoomService和Redis属于两个不同的进程。HotelRoomService运行在JVM中而Reids 有自己的进程，在跨进程的数据获取也会面临损耗。

顺着这个思路，我们将缓存的数据从Redis搬到JVM的本地缓存中，于是就有了图3所示，这里将请求步骤分为了4步：

1. 酒店小程序通过酒店小程序后台API中的HotelRoomService获取房间信息。
2. 由于HotelRoomService运行在JVM中，因此会先请求JVM的本地缓存，是否存在酒店房间的信息，如果存在就将其返回给小程序。
3. 如果HotelRoomService所在JVM中不存在房间的缓存信息，再去询问Redis缓存中是否存在该房间信息，如果存在房间信息就直接返回给小程序。
4. 最后，Redis中也不包含房间信息，再请求数据库，并且返回信息。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm0f5gb0c9a.png)

图3 加入JVM 缓存房间信息

最后加入了JVM 缓存信息以后让数据响应效率得到进一步的提升。不过JVM的缓存大小取决于JVM的大小，这里推荐存放不是太大的数量，这些数据最好是热点数据。

#### **5、**总结

本节课将焦点放在房间详情信息的查询效率上，特别是在高并发的场景下需要通过JVM缓存、Redis缓存的方式让数据离用户更近，缩短数据响应的时间。

下节课我们会带大家实现缓存功能的代码。下期见，拜拜。

### **27_代码实战：基于多级缓存机制，优化客房详情页的热点查询功能**

**1、开篇**

上节课主要介绍了为了解决高并发下客房信息的获取问题，通过传统模式推进到Redis缓存模式，再到JVM进程内缓存模式。今天带大家将缓存模式的代码过一遍，会学到如下内容：

- 酒店房间数据库表与实体类设计
- HotelRoomController
- HotelRoomService

#### **2、**酒店房间数据库表与实体类设计

首先是存放分店信息的表“t_shop_categroy”，如图1 所示，该表定义了name（分类名称）、thumb（分类图片）、detail_image（图片详情），area（地区）、phone（电话）等信息。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm11r5c08pt.png)

图1 分店信息表

然后是房间信息表”t_shop_goods”其中定义了，phone_number（手机号）、comment（详情图）、marketprice（市场价）、productprice（本店售价）等信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm15b7w01ae.png)

图2 房间信息表

上面提到的数据库的表信息已经由儒猿团队给大家建立好了，这里只是了解一下，下面就是实体类的部分了。

如图3所示，在/api/hotel/dto下面建立HotelRoom类定义酒店房间的相关信息。其中包括：房间Id、房间名称、店铺Id、房间图片、房间详情信息（RoomDescription类）、房间的banner图片信息（List<RoomPicture>）、参考价格、实际价格、房间数量。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm16esh03q3.png)

图3 HotelRoom 实体类

在HotelRoom中定义了RoomDescription 的信息，如图4所示，其包括面积、宽高、早餐的分数。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm16rzo0xzj.png)图4 RoomDescription

还定义了RoomPicture信息，如图5所示，包括图片Id、图片地址等信息。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klm17hlb0me7.png)

图5 RoomPicture

#### **3、**HotelRoomController

由于酒店小程序需要调用对应的API服务获取酒店房间信息，作为请求的入口小程序后台API需要提供一个Controller来处理RESTFUL的请求。

如图6所示，在/api/hotel/controller下面建立HotelRoomController用来查询房间的信息。在HotelRoomController类中定义getRoiomById方法传入参数为房间的Id和用户手机号phoneNumber。其中会去调用HotelRoomService中的getRoomId方法传入上述的参数进行进一步查询。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmjnad700q7.png)图6HotelRoomController

#### **4、**HotelRoomService

如图7所示，为了实现查询房间的功能在/api/hotel/service下面定义了HotelRoomService的接口，这个接口定义了getRoomId的方法输入参数为房间Id和手机号phoneNumber。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmjpe9d02zq.png)

图7 HotelRoomService 接口

作为HotelRoomService接口的实现，HotelRoomServiceImpl也在/api/hotel/service/impl目录下面被创建。如图8所示，我们将重要的部分用红色框了起来，并且标注上文字。从上到下依次来看一看。

首先是定义了Redis dubbo接口的API，这里的定义会给后面调用Redis缓存做准备。

其次是在getRoomId方法一开始会查询JVM进程内缓存的数据，这里是调用了hotelRoomCacheManager类中的getHotelRoomFromLocalCache这个方法并且传入room id作为参数。

再次是由于JVM没有命中，需要通过查询Redis中的缓存数据，这里使用room id 作为缓存的Key进行查询。

最后如果以上两种方式都没有命中房间信息，就通过查询数据库获取。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmjq5lo0by5.png)图8 通过getRoomById方法获取房间信息

#### **5、**总结

本节课讲了如何通过多级缓存获取房间信息的代码实现，其主要代码集中在HotelRoomServiceImpl中，最新查询JVM进程内缓存，如果没有命中就查询Redis缓存，最后都没有命中的情况下请求数据库，这里讲[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week05/)给大家。

下节课我们会带大家运行一次代码，通过观察日志来看看代码是否执行。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **28_阶段测试：验证多级缓存机制能否优化高并发下的热点查询问题**

**1、开篇**

上节课主要介绍了为了解决高并发下客房信息的获取问题，通过传统模式推进到Redis缓存模式，再到JVM进程内缓存模式。今天带大家将缓存模式的代码过一遍，会学到如下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 验证多级缓存机制

#### **2、**申请ECS 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/login“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、** 验证多级缓存机制

在确认服务启动以后，我们需要登录小程序验证登录功能。如图8所示，使用微信扫描二维码登录酒店小程序。注意：这里微信绑定的手机号需要和购买实战课程的手机号是同一个才能测试功能。

![微信二维码.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmk6n210c3d.jpg)

图8 酒店小程序二维码入口

进入酒店小程序之后依旧是授权登录和获取手机号，之后进入查询酒店页面，如图9所示，在填写查询条件和入住、退房日期以后，点击“查询酒店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmk8zmg0yw4.png)

图9 查询酒店

如图10所示，在查询结果中列出所有符合要求的酒店。这里我们选择“儒猿酒店北京分店”。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmka6t70b1g.png)

图10 酒店列表

选择酒店以后会看到酒店对应的客房信息，如图11 所示，这里显示了我们之前添加的客房“test01”。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkap8h03d0.png)

图11 客房信息

接着点击图11 中的“预订”按钮就可以看到，如图12 所示的房间详细信息。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkb7s50kh0.png)

图12 房间详细信息

完成上述操作以后，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图13 所示，第一次查询酒店房间信息之后，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到以下几条信息：

1. 先检查JVM缓存是否命中，发现JVM没有命中，于是查询Redis缓存
2. 查找Redis缓存发现没有命中，去查找数据库。
3. JVM和Redis都没有命中的情况下从数据库中获取数据。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkbrhi0eyl.png)图13 第一次查询酒店房间信息-JVM、Redis都没有命中查询数据库

由于第一次查询到的房间信息会放入JVM和Redis中进行缓存，因此第二次查询的时候会看到如图14所示，房间信息在JVM缓存中直接命中。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkcm6w05cw.png)图14 第二次查询酒店房间信息-JVM命中

此时，如果我们通过命令行“sh deploy.sh restart”重新启动服务，第三次调用查询房间的功能。如图15所示，由于重启了服务，JVM中缓存的数据丢失，再次请求房间信息的时候，显示JVM没有命中，Redis缓存的数据还在，因此Redis命中缓存。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkd3ar071a.png)图15 第二次查询酒店房间信息-由于重启服务JVM缓存的数据丢失，Redis命中

至此我们就完成了登录代码的发布以及测试。并且通过日志的方式演示了多级缓存的代码实现。

#### **6、总结**

本节课将上节课讲到的多级缓存的代码实现带大家测试了一遍。这节课是本周的最后一次课，照例进行一下总结，本周从酒店管理模块和客房管理模块入手，讲述了酒店管理后台和小程序实现的业务流程。通过客房详情在高并发下的热key问题，引出了多级缓存的思考，并且通过代码实现解决问题。这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week05/)给大家。

下周还会延续多级缓存的问题，看看如何在多级缓存的情况下依旧保持数据的一致性。下期见，拜拜。

### **29_技术挑战：引入多级缓存后，又如何保证多级缓存的数据一致性？**

**1、开篇**

上周课程从酒店管理模块和客房管理模块入手，讲述了酒店管理后台和小程序实现的业务流程。通过客房详情在高并发下的热key问题，引出了多级缓存的思考，并且通过代码实现解决问题。

这周课程会延续缓存的主题，来看看如何在多级缓存的场景下如何保持数据一致性。今天会学到以下内容：

- 多级缓存存在的问题
- 多级缓存的数据一致性 

#### **2、**多级缓存存在的问题

从上周课程可以得知，为了提供用户更快的响应速度，我们会增加Redis和JVM本地缓存机制。用户在请求数据按照 JVM本地缓存->Redis缓存->数据库的顺序进行。这样的好处是让缓存数据离用户足够近，响应足够迅速，特别是在高并发场景下，每多一次调用都会带来系统的损耗。

上面描述的都是数据读取的场景，缓存的数据是如何写入的？在写入缓存数据的时候如何保持Redis缓存和JVM本地缓存的一致性呢？如果Redis缓存发生了改变，而没有及时通知JVM本地缓存，导致其没有改变，刚好此时用户访问时根据房间ID命中了JVM缓存，岂不是拿到的数据就是不正确的了。

为了解决这个问题，我们使用了RocketMQ作为Redis与JVM缓存之间的“通信员”，当修改Redis缓存的同时也发送RocketMQ的广播消息，通知缓存信息修改了，消息的消费者如果接到该信息以后再去对JVM缓存进行修改，如此这般就可以保持数据的一致性了。

#### **3、**多级缓存的数据一致性

根据上面的想法，我们对酒店项目的程序进行了升级，如图1 所示，这里将缓存数据同步的部分画上了标号，按照顺序对数据同步进行讲解。

\1. 当酒店管理员通过酒店管理后台对房间信息进行修改或者添加的时候，会调用酒店后台API中的房间管理服务。

\2. 房间管理服务除了对房间进行修改保存到数据库之外，还有一个任务就是将修改后的房间信息保存到Redis缓存中。

\3. 在保存信息到Redis之后，房间管理服务还充当了消息的生产者，这里它会发送房间更新的消息到RocketMQ的队列中，以供消费者消费该房间更新消息。

\4. 作为消费者的HotelRoomUpdateMessageListener来说，它位于酒店小程序后台的后台API的房间管理模块中，它会一直监听房间更新的消息。

\5. 一旦监听到房间更新消息以后会根据对应的房间ID从Redis中获取房间信息。

\6. 并将房间信息保存到JVM本地的缓存中。这样当客户通过酒店小程序调用JVM缓存获取房间信息时，就可以获取最新的房间信息了。保证了JVM和Redis中数据的一致性。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkmszo0csr.png)

图1 多级缓存保持数据一致性

#### **4、**总结

本节课整理了数据一致性的思路，需要将管理后台中修改的房间信息保存到Redis的同时，发送消息给RocketMQ，从而通知小程序后台API去更新JVM的缓存。这样在用户请求小程序后台API获取房间信息的时候，就可以获取最新的缓存信息了。

下节课我们会通过代码实践带大家把上述设想落地。下期见，拜拜。

### **30_代码实战：基于MQ的广播消息，实现客房数据的缓存一致性**

**1、开篇**

上节课介绍了保证Redis和JVM多级缓存保持数据一致性的思路，并在新的方案中酒店管理后台在修改房间信息以后，在保存Redis的同时还会发送RocketMQ消息，通知更新JVM本地缓存中的房间信息。今天带大家过一遍代码实践。今天会学到以下内容：

- 房间管理后台发送消息逻辑
- 房间消息实体类
- 初始化消息消费者
- 更新JVM缓存
- 房间信息消费者

#### **2、**房间管理后台发送消息逻辑

房间管理后台作为房间更新消息的发送者，在添加房间时会保存数据到数据库和存储房间缓存到redis中，修改房间的时候修改数据库，更新缓存，同时发送房间更新的消息到RocketMQ的message队列中，如图0所示。这个消息是用来通知消费者，酒店房间已经修改，当消费者接受到该消息以后就会查询Redis缓存，更新JVM本地缓存的操作了。

![图片0.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkvz8n0f4v.png)

图0 后台房间管理添加和更新

#### **3、**房间消息实体类

如果说酒店管理后台需要发送房间更新的消息，那么需要一个消息的载体，如图1 所示，在/api/hotel/dto 下面定义了HotelRoomMessage，其中包括roomId（房间ID）和phoneNumber（手机号）的信息。这个实体会在产生Redis缓存更新的时候从Producer发送给RocketMQ，最终由Consumer接收了。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkwkdu08pq.png)图1 房间消息

#### **4、**初始化消息消费者

有了房间消息就一定有对应的消费者，如图2 所示，在/api/hotel/consumer下面定义了

HotelRoomConsumerConfiguration，其中定义了RokcetMQ的name server、hotelRoom的topic以及对应的group，相关配置信息在application.properties文件中。通过@Bean 方式初始化hotelRoomConsumer 的bean对象，并依赖注入HotelRoomUpdateMessageListener Bean对象实例，在将其作为consumer消费的listener。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkxb2h0x58.png)

图2 HotelRoomConsumerConfiguration

#### **5、**更新JVM缓存

有了消息和消费者，还需要对JVM本地缓存进行更新。如图3 所示，在/api/hotel/service/impl 下面定义了HotelRoomCacheManager类，专门用来读取和写入JVM本地缓存的。其中使用了updateLocalCache方法来保存hotelRoom的信息。并且使用了ConcurrentHashMap，其底层采用分段的数组+链表，保证线程安全。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkxu9j08sh.png)图3 HotelRoomCacheManager

#### **6、**房间信息消费者

消息、消费者、JVM缓存都具备了，接下来就来看看如何接收消息、读取Redis以及更新JVM缓存了。如图4所示，在/api/hotel/listener中定义HotelRoomUpdateMessageListener类，其中有一个consumeMessage的方法需要注意，和其他消费者一样它也会接受List<MessageExt>信息。

从代码中可以看出，方法中会遍历List中的消息，通过解析消息获取roomId的信息，并且通过roomId从Redis中获取房间信息。最后，通过HotelRoomCacheManager的updateLocalCache方法将其更新到JVM的本地缓存中，完成Redis与JVM缓存一致性的操作。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmkydc40hd5.png)图4 HotelRoomUpdateMessageListener

#### **7、**总结

本节课带大家将项目代码升级从而匹配多级缓存的数据一致性，包括：房间管理后台发送消息逻辑、房间消费实体类、初始化消息消费者、更新JVM缓存以及房间信息消费者的定义，这里讲[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week06/)给大家。

下节课会带大家将代码进行发布测试。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **31_阶段测试：验证系统的多级缓存数据是否一致？**

**1、开篇**

上节课介绍了多级缓存数据一致性的代码实现，包括消息实体类的定义、初始化消息消费者、更新JVM缓存以及房间信息消费者的具体实现。今天带大家将代码进行测试并且查看执行结果。今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 验证数据一致性

#### **2、**申请ECS 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“[https://project-practice-cloud.ruyuan2020.com](https://project-practice-cloud.ruyuan2020.com/)“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**验证数据一致性

前面的部署工作完成以后，进入测试阶段，首先进入酒店管理后台：https://project-practice-cloud.ruyuan2020.com/ 中点击“房间管理”，在出现的房间列表中选择某条房间记录，并且点击右边的️，选择进入“修改房间”的页面。我们将开始的测试数据“test01”修改为“test02”.

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klml73k60qfh.png)图8 修改房间信息

完成上述操作以后，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图9 所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到如下信息：

1. 在修改了房间名称以后，首先更新了数据库中对应的房间表信息。
2. 然后将更新的房间信息更新到Redis中保存。
3. 同时发送房间更新的消息给RocketMQ。
4. 消费房间更新信息的消费者收到房间更新信息。
5. 消费者通过信息中的房间Id从Redis中获取房间的缓存信息。
6. 通过Redis中的缓存信息更新JVM的本地缓存，完成缓存信息的数据一致。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klml8deu0ozn.png)

![图片9.1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klml8pv60603.png)图9 登录成功和发送消息成功

至此我们就完成了多级缓存数据一致性的发布以及测试。并且通过日志的方式演示了整个过程。

#### **6、**总结

本节课是本周的最后一次课，这里做一个总结。在上周课中引入了多级缓存的概念，也就是通过Redis和JVM的缓存提高应用在高并发下的响应速度，当有多级缓存的时候会引出数据一致性的问题。

这里我们通过RocketMQ同步Redis和JVM的缓存数据。当管理后台修改数据的时候，会更新Redis同时发送消息，给消费者，消费者拿到消息以后从Redis中获取数据再更新JVM，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week06/)给大家。

下周课我们会专注于下单模块的分析和开发。下期见，拜拜。

### **32_一步一图：互联网酒店预订系统之订单业务整体流程梳理**

**1、开篇**

上周主要给大家介绍了在引入JVM和Redis多级缓存以后存在的数据一致性问题，我们通过RocketMQ在保存Redis缓存的同时，通知消费者更新JVM中的数据，从而保证其一致性。

本周课程主要聚焦下单的相关业务流程。今天会学到以下内容：

- 下单业务流程
- 下单流程演示

#### **2、**下单业务流程

订单的下发是互联网酒店预订系统的重要组成部分，这里我们通过一个流程图给大家介绍。如图1 所示，在酒店小程序这端，客户完成登录以后，会通过查询酒店和查询房间的功能找到心仪的房间。

从“预订房间”（橙色的模块）开始就进入下单的流程，客户会对房间进行付款，如果付款成功会创建订单，并且将订单状态设置为“待入住”。如果没有付款，也会创建订单，同时将状态设置为“待付款”。

这部分的订单信息，会保存到数据库中，后续给酒店管理人员查看。如果使用了优惠券，还会去更新优惠券的使用信息。完成订单创建的工作之后，会推送下单成功的微信消息给客户。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0rbf00vdx.png)

图1 订单业务流程

#### **3、**下单流程演示

下面根据上述的业务流程，我们通过截图的方式带大家过一遍。下面这些功能的实现，需要完成本周课程的代码以后方可实现。这里让大家对整个流程有一个印象，所以先给大家展示一下。

如图2 所示，登录授权获取手机以后查询酒店。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0rwfz0lds.png)

图2 查询酒店

如图3 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0scp80dkd.png)

图3 酒店查询结果

如图4 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0t23e04nn.png)

图4 房间列表

如图5所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0vgfz0ye7.png)

图5 确认订单

由于本周课程主要介绍订单流程，还没有涉及到付款过程，因此如图6所示，在弹出的支付页面中，选择“取消”按钮。此时会生成订单，状态为“待付款”。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0xbyw0zvv.png)

图6 取消支付

如图7所示，在点击“取消”以后，就进入了订单详情页面，列出订单价格、订单状态、房型、床型、房间数、预订人、手机号等信息。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0xq960cx4.png)

图7 订单详细信息

登录酒店后台管理，如图8所示，可以在“订单管理”中的订单列表中查看到我们刚刚下的那个订单的信息。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kln0y5w30fb1.png)图8 管理后台查看订单详情

#### **4、**下单流程演示

本节课讲述了酒店下单的主要流程，作为本周的第一节课也带大家把本周涉及到的下单功能过了一遍，包括：预订、付款、生成订单信息、更新优惠券信息、推送微信通知、以及后台查看订单详情。

下节课对订单系统中核心模块异步化的改造。下期见，拜拜。

### **33_性能优化：基于MQ对订单系统中的核心模块进行异步化改造**

**1、开篇**

上节课作为本周的第一节课带大家把本周涉及到的下单功能过了一遍，包括：预订、付款、生成订单信息、更新优惠券信息、推送微信通知、以及后台查看订单详情。

这节课主要围绕下单异步化的问题展开，当订单并发量激增的情况下如何将功能进行异步处理，让系统能够平稳地迎接大流量请求。今天会学到以下内容：

- 同步方式的下单流程
- 异步方式的下单流程 

#### **2、**同步方式的下单流程

在进行下单异步化改造之前，先回顾一下同步方式的下单流程。如图1所示，查询房间、预订房间、生成订单，更新优惠券，最后推送微信的消息通知。属于下单主要流程的是生成订单、更新优惠券，而查询和预订房间的步骤属于下单之前的预备动作。

再看推送微信消息通知可以作为下单之后的后续动作，虽然和下单相关，但是即便不同步发送或者稍有延迟地推送对下单本身也没有特别的影响。

在图1 的设计中推送微信消息的功能是在下单流程中同步完成的，也就是当消息推送成功以后下单才能完成。而微信推送本身要使用网络IO，也需要调用第三方系统，这样会影响订单系统的稳定性和执行效率。

在高并发的场景中，为了提高系统的吞吐量，需要将推送微信消息这类功能进行异步化处理。处理方式不言而喻就是使用RocketMQ对其进行解耦。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpd8z3802ij.png)

图1 同步方式的下单流程 

#### **3、**异步方式的下单流程

异步化处理的方式需要对推送微信消息功能进行拆解。如图2 所示，我们把推送微信消息进行如下拆解，主要关注拆解后带颜色的部分，其他无关的功能流程暂时用灰色表示。

在下单完成以后一定会生成对应的订单，此时通过订单生产者（绿色）生成订单的信息，将这个信息发送到RocketMQ的队列中。同时由订阅订单消息的消费者（橙色）去接受这个信息，然后执行推送微信通知（紫色）的功能。

通过RocketMQ异步化的方式，将订单消息生产者、RocketMQ、订单消息消费者、推送微信通知等几个功能与上面的下单功能进行了异步化的处理。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdaelj03al.png)

图2 下单流程异步化处理

换句话说，就是订单生成以后订单的流程就结束了，系统可以处理其他创建订单的请求。系统只需要发送一个订单创建的消息到RocketMQ中，推送微信通知的功能就交给消费服务去执行了。不用同步等待推送微信消息成功后才返回结果，来提高系统的吞吐量。

#### **4、总结**

本节课将下单的同步流程改成了异步，主要是将微信消息通知的模块通过RocketMQ方式和原来的下单流程进行解耦，解耦以后下单和发送消息可以独立运行，互相不会依赖，提高执行效率从而应对高并发的场景。

下节课主要介绍创建订单的代码编写，带大家完成创建订单等功能的开发。下期见，拜拜。

### **34_代码实战：编写创建订单接口，保存订单数据和订单客房数据（一）**

**1、开篇**

上节课对下单流程进行了异步化的处理，将微信消息通知的模块通过RocketMQ方式和原来的下单流程进行解耦，解耦以后下单和发送消息可以独立运行，互相不会依赖，提高执行效率从而应对高并发的场景。

这节课带大家进行保存订单接口的代码编写，今天会学到以下内容：

- 数据库表设计以及实体类
- 优惠券服务（CouponService）
- 订单服务（OrderService）
- 订单服务入口（OrderController）

#### **2、**数据库表设计以及实体类

首先是数据库的表设计，如图1 所示，”t_shop_order” 就是订单表，其中包括订单Id，手机号、订单所属平台、用户Id等信息。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdp35u0d5e.png)图1 订单表

在订单表下面集连了一个订单项表，如图2 所示，”t_shop_order_goods”就是这张表，主要描述订单里面包含商品的具体内容。对于本案例来说就是房间的信息。其包括了订单Id（与订单表进行关联），手机号、预订天数、商品详情、商品SKU等信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdpii00nwo.png)图2 订单项表

介绍完了数据库表再来看看实体类的设计。如图3 所示，在“api/order/dto”下面定义OrderInfoDTO的实体类，其中包括订单Id、订单号、店铺Id、小程序Id、房间Id、分店Id、酒店名字等信息。后面的信息可以在提供的代码中查看这里不逐一介绍。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdpx7y0k3z.png)图3 订单实体类

如图4 所示，在“api/order/dto”下面定义OrderItemDTO的实体类。其中包括房间图片地址、店铺Id、订单Id、房间Id、房间名称等信息。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdqdoa010t.png)图4 订单项实体类

同样在在“api/order/dto”下面定义CreateOrderResponseDTO的实体类，在创建订单成功以后用来返回响应体。其包括订单编号和订单Id。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdqsag03iv.png)图5 订单响应实体

#### **3、**优惠券服务（CouponService）

由于订单服务中会用到优惠券服务的内容，这里需要对优惠券服务率先进行定义。如图6所示，首先定义CouponService优惠券的接口，然后定义CouponServiceImpl 优惠券接口的实现。

其中定义了使用优惠券的方法userdCoupon，参数为订单Id、优惠券Id以及电话号码。其主要功能就是更新“t_coupon_user”这张表，该优惠券的使用状态，使用时间，被哪个订单消费等信息。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdr5te084y.png)图6 优惠券服务

#### **4、**订单服务（OrderService）

如图7所示，为创建订单建立订单服务的接口OrderService，其中定义了createOrder的方法，传入参数是orderInfoDTO。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdrng70hrp.png)图7订单服务接口

有了订单服务的接口就需要对应的实现，OrderServiceImpl 作为OrderService的实现，主要完成了createOrder方法。如图8所示，红色框体的部分是本节课的重点。

从上到下一次执行了保存订单数据、保存订单商品数据、更新优惠券状态三个动作。这三个动作是一次执行的，都是对数据库中对应表的操作。保存订单数据对应的是”t_shop_order”，保存订单商品数据对应的是“t_shop_order_goods”。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdst920hy9.png)图8订单服务实现

#### **5、**订单服务入口（OrderController）

在介绍了订单服务之后，再说一下订单服务的入口OrderController，依旧是提供RESTFUL的API服务。如图9所示，通过应用/api/order作为服务的访问路径，其中定义了createOrder方法传入参数是orderInfoDTO，访问的方式是Post请求。在createOrder中直接调用orderService中的createOrder方法，传入参数同样是orderInfoDTO。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpdtdyy0z0j.png)图9 OrderController

#### **6、**总结

本节课介绍了订单保存和优惠券使用的功能编码，从数据库表结构和实体类设计到优惠券服务，再到订单服务。作为订单流程的一部分，本节还不包含微信消息推送的功能，会在下节课中给大家介绍，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week07_35讲/)给大家。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **35_代码实战：编写创建订单接口，保存订单数据和订单客房数据（二）**

**1、开篇**

上节课介绍了订单保存和优惠券使用的功能编码，从数据库表结构和实体类设计到优惠券服务，再到订单服务。这节课继续延续订单流程的编码实现，主要介绍异步化的部分，也就是通过RocketMQ队列发送订单完成的消息。

今天会学到以下内容：

- 创建订单消息实体类
- 初始化订单消息生产者
- 创建订单消息管理组件
- 完善创建订单发送消息逻辑

#### **2、**创建订单消息实体类

由于在订单的流程中需要发送订单完成的消息，因此需要定义订单消息的实体类。如图1 所示，在“api/order/dto”的目录下面定义OrderMessageDTO类，其中包括了content（消息内容）和MesssageTypeEnum （消息类型）的定义。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpe5n64043v.png)图1 订单消息实体类

其中消息类型是应用儒猿通用组件中的定义，大家可以直接使用，如图2 所示，消息类型包括：微信登录通知、订单代付款通知、订单取消通知、订单支付成功通知、订单确定通知、订单结束通知等等。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpe6qu90l0w.png)

图2 消息类型

#### **3、**初始化订单消息生产者

定义完订单消息，这里需要定义订单消息的生产者，顾名思义就是用来产生订单消息的producer。如图3 所示，在“api/order/producer”下面定义OrderProducerConfiguration类，其中定义了RokcetMQ的name server、以及对应的group，值需要在application.properties中进行配置。通过@Bean 方式初始化orderProducer的bean对象，同时启动生产者。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpe8bs80voe.png)图3 订单消息生产者

#### **4、**创建订单消息管理组件

有了订单消息的生产者以后，需要执行订单发送的执行者，这个执行者会调用生产者去发送订单消息。如图4所示，在“api/order/service”下定义OrderEventInformManager接口，在这个接口中定义了informCreateOrderEvent方法，传入的参数是OrderInfoDTO。

同样在“api/order/service/impl”定义了OrderEventInformManagerImpl 实现了上述接口的方法。其中的sendOrderMessage的私有方法实现了具体的发送的功能。这个方法会传入MessageTypeEnum和OrderInfoDTO作为参数，用来创建消息体。

通过调用orderMQProducer中的send方法将消息发送到队列中。最终再由informCreateOrderEvent进行调用，完成消息的发送。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpe8snn02m7.png)图4 订单消息发送者

#### **5、**完善创建订单发送消息逻辑

回到OrderServiceImpl类中，如图5所示，上节课已经完成保存订单、保存订单商品、更新优惠券等功能的编写。这里在红框处加入发送消息的代码，直接调用OrderEventInforManager中的informCreateOrderEvent方法，传入早已准备好的orderInfoDTO对象，随即完成订单成功消息的发送。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpe9iw70rli.png)图5 在订单流程中加入发送订单完成消息的功能

#### **6、**总结

本节课接着上节课的编码步骤，完成了创建订单成功后发送消息功能。其中包括：订单消费体类的建立、初始化订单消息生产者、创建订单消息管理组件、完善创建订单发送消息逻辑，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week07_35讲/)给大家。

下节课带大家一起去验证前面两节课代码的实践，看看下单的流程是否完备。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **36_停下脚步：先验证一下系统的整个下单逻辑是否正确？**

**1、开篇**

上两节课针对下单流程带大家进行了编码实践，包括保存订单、保存订单项信息、更新优惠券使用信息、发送订单成功消息在内的一些功能。今天主要带大家一起验证代码的实践，会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 下单流程演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**下单流程演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klmk8zmg0yw4.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpwdfh10ee7.png)图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpwdu7e0vjy.png)图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpweao106ma.png)

图11 确认订单

由于本周课程主要介绍订单流程，还没有涉及到付款过程，因此如图12所示，在弹出的支付页面中，选择“取消”按钮。此时会生成订单，状态为“代付款”。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpweqbg0ybm.png)

图12 取消支付

如图13所示，在点击“取消”以后，就进入了订单详情页面，列出订单价格、订单状态、房型、床型、房间数、预订人、手机号等信息。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpwf4fh0znr.png)

图13 订单详细信息

完成上述操作以后，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图14 所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到如下信息，从上往下按照红字标记的顺序：

1. 保存订单信息到数据库中。
2. 保存订单项信息（订单中商品信息）到数据库中。
3. 更新优惠券的使用信息。
4. 发送订单生成信息到RocketMQ的队列中，其中信息类型为微信通知。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpwfw160x3f.png)图14 查看生成订单日志

#### **6、**总结

本节课带领大家把订单流程代码实施的部分在小程序上验证了一遍，主要关注的是下单流程的部分，其中包括保存订单、保存订单项、更新优惠券信息和发送订单生成的消息，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week07_35讲/)给大家。

下节课会带大家一起思考在下单以后如何推送消息到用户微信。下期见，拜拜。

### **37_新的思考：下单后如何推送订单消息到用户微信呢？**

**1、开篇**

上节课带领大家把订单流程代码实施的部分在小程序上验证了一遍，主要关注的是下单流程的部分，其中包括保存订单、保存订单项、更新优惠券信息和发送订单生成的消息。今天会学到以下内容：

- 小程序消息订阅介绍
- 小程序消息订阅步骤 

#### **2、**小程序消息订阅介绍

前面几节课已经把下单的流程给大家介绍过了，详细大家对流程有整体的认识了。在下单流程的最后，我们通过RocketMQ异步的方式将小程序消息推送与主流程进行了解耦。这里就来给大家介绍如何进行小程序消息订阅的。

消息能力是小程序能力中的重要组成，微信小程序为开发者提供了订阅消息能力。这种能力可以包括如下几个部分的内容。

- 订阅消息推送位置：服务通知
- 订阅消息下发条件：用户自主订阅
- 订阅消息卡片跳转能力：点击查看详情可跳转至该小程序的页面

如图1 所示，当用户登录微信小程序的时候，程序就会询问用户是否接受消息订阅。在选择“允许”以后，用户就会收到来自小程序的消息推送了。![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpwqfis0dg0.png)

图1 询问是否接受消息订阅

订阅消息包括以下两种类型：

- 一次性订阅消息用于解决用户使用小程序后，后续服务环节的通知问题。用户自主订阅后，开发者可不限时间地下发一条对应的服务消息；每条消息可单独订阅或退订。通常来说针对某一种业务进行一次性的消息订阅和推送。
- 长期订阅消息是为了满足下线长期服务的场景，如航班延误，需根据航班实时动态来多次发送消息提醒。为便于服务，我们提供了长期性订阅消息，用户订阅一次后，开发者可长期下发多条消息。

由于我们的酒店小程序是在每次订单生成的时候进行消息推送，属于一次性订阅消息的场景。我们在选择订阅类型的时候，也需要关注小程序使用的场景灵活选择。

#### **3、**小程序消息订阅步骤

上面对小程序消息订阅有了基本的介绍，这里我们将其实现订阅的三个步骤给大家介绍一下。

- 步骤一：获取模板 ID

在微信公众平台手动配置获取模板 ID：登录 [https://mp.weixin.qq.com](https://mp.weixin.qq.com/) 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用。

如图2所示，这是儒猿团队为大家生成好的模版。其中包括：订单代付款提醒、订单确认通知、支付成功通知、订单取消通知、订单结束提醒。根据使用场景，它们的类型都是一次性订阅。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpws8mo062g.png)

- 步骤二：获取下发权限

需要通过小程序端消息订阅接口 wx.requestSubscribeMessage，进行权限的下发，它主要完成以下工作：

- 调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果。
- 当用户勾选了订阅面板中的“总是保持以上选择，不再询问”时，模板消息会被添加到用户的小程序设置页，通过 [wx.getSetting](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html) 接口可获取用户对相关模板消息的订阅状态。

这个过程说白了就是让用户授权给小程序去发送消息。

- 步骤三：调用接口下发订阅消息

在获取下发消息的权限以后就可以通过接口下发消息了，这里需要使用服务端消息发送接口 subscribeMessage.send。这个发送的工作已经由儒猿团队封装成dubbo 服务完成了，如果对之前的介绍有印象的话，这个功能就在little-project-message的依赖包中。在后续的代码实现中，我会带大家调用这个包中的方式，实现这个功能，因此在后面还会提到。

#### 4、总结

本节课针对微信小程序的消息订阅功能进行了介绍，包括消息订阅的功能、消息订阅的分类、以及执行步骤（定义模版、获取权限、发送消息）。

下节课会针对具体的消息实现，用代码全是上面的概念，在原有的订单流程中加入消费者，它可以根据订单完成的消息执行小程序消息推送的功能。下期见，拜拜。

### **38_代码实战: 将订单消息实时推送到用户微信**

**1、开篇**

上节课针对微信小程序的消息订阅功能进行了介绍，包括消息订阅的功能、消息订阅的分类、以及执行步骤（定义模版、获取权限、发送消息）。这节课就针对小程序消息推送的功能，来看看代码是如何实现的。今天会学到以下内容：

- 创建消息实体类
- 初始化订单消息的消费者
- 推送订单消息

#### **2、**创建消息实体类

由于微信消息的推送是独立的功能，因此在com.ruyuan.little.project.rocketmq.api的下面建立了一个新包message，这里主要负责对消息推送的处理。

如图1 所示，在”api/message/dto” 下面创建了OrderInfo实体类，由于微信推送消息需要处理订单业务，因此需要定义订单相关的实体类。这里包括手机号、订单Id、订单号、订单创建时间、订单支付时间等信息。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpx3p460775.png)

图1 OrderInfo实体类

同样也包括了订单项信息，如图2 所示，定义了OrderItem实体类，其中包括了房间名称和订单数量等信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpx60dv0zb2.png)图2 订单项信息

以上的两个实体类服务的对象是Message所以会和Order包中的实体类内容有所区别。接下来就是OrderMessage实体类了，如图3所示，OrderMessage中定义了消息内容和消息类型。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpx6i2r0cf6.png)图3 OrderMessage

#### **3、**初始化订单消息的消费者

说完了消息实体类的定义再来看看消费者的定义和初始化工作。如图4 所示，在/api/message/consumer下面定义了MessageConsumerConfiguration，其中定义了RokcetMQ的name server、order的topic以及对应的group。通过@Bean 方式初始化orderConsumer 的bean对象，并依赖注入orderMessageListener Bean对象实例，在将其作为consumer消费的listener。在启动初始化configuration的时候会初始化orderConsumer，并且将它启动。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpx7d4n0dk9.png)图4 初始化订单消息的消费者

#### **4、**推送订单消息

如图5所示，在/api/message/listener中定义OrderMessageListener类，其中有一个consumeMessage的方法需要注意，由于该类实现了MessageListnerOrderly类并且override了这个方法。因此当RocketMQ获得订阅消息的时候，就会触发这个方法。和其他消费者一样它也会接受List<MessageExt>信息。

从代码中可以看出，方法中会遍历List中的消息，通过解析消息获取订单的信息，并将信息组装成OrderMessage和OrderInfo实体。最后将OrderInfo通过builderWaitPayOrderMessage方法进行包装，最后连同手机号（phoneNumber）和消息类型（messageType）的信息传给send的私有方法，完成微信消息的推送工作。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpxch4p0gz0.png)图5 订单消息的消费者进行微信消息推送

在实际调用发送消息的方法send中，如图6所示，它会初始化WxSubsribeMessageDTO类，并且设置内容（Content）、项目类型（RocketMQ）、消息类型（MessageType）以及手机号（PhoneNumber）。

最后，调用wxSubscribeMessageApi中的send方法传入WxSubsribeMessageDTO对象完成微信小程序消息的推送。WxSubsribeMessageDTO和wxSubscribeMessageApi都是源自儒猿通用组件“little-project-message”，需要在pom中添加对应的依赖，此时需要修改application.properties文件中dubbo.cloud.subscribed-services配置为little-project-redis,little-project-mysql,little-project-message，其功能已经由团队实现，大家可以直接使用。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpxdfzd013h.png)

图6 通过little-project-message组件的方法进行微信消息推送

#### **5、**总结

本节课带大家完成了订单消息监听到发送微信小程序消息的过程。由于Message是一个独立的功能，因此使用了单独的组件包，同时定义了消息发送的实体类，而且初始化了消息的消费者并且在配置加载的时候启动了它，最后完成消费者消费消息的代码，在代码中会将收到的消息进行封装，调用儒猿团队提供的公共组件发送给微信小程序，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week07_38讲/)给大家。

下节课我们会带大家对下单流程的功能进行验证。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **39_测试验证：用户下单后，系统是否能实时推送订单消息到用户微信？**

**1、开篇**

上节课带大家完成了订单消息监听到发送微信小程序消息的过程。由于Message是一个独立的功能，因此使用了单独的组件包，同时定义了消息发送的实体类，而且初始化了消息的消费者并且在配置加载的时候启动了它，最后完成消费者消费消息的代码，在代码中会将收到的消息进行封装，调用儒猿团队提供的公共组件发送给微信小程序。

今天会对下单流程进行整体验证，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 下单流程及消息推送演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**下单流程及消息推送演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy46j90qqq.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy4knr0keh.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy51bs08oc.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy5w3e0nw9.png)图11 确认订单

由于本周课程主要介绍订单流程，还没有涉及到付款过程，因此如图12所示，在弹出的支付页面中，选择“取消”按钮。此时会生成订单，状态为“代付款”。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy6ukd0vrq.png)

图12 取消支付

如图13所示，在点击“取消”以后，就进入了订单详情页面，列出订单价格、订单状态、房型、床型、房间数、预订人、手机号等信息。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy796f0rim.png)

图13 订单详细信息

在生成订单以后，如图14所示，在微信小程序端就会收到一条消息推送，包含了订单号、下单时间、有效时间、订单内容的信息。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy7njg0wmq.png)

图14 订单消息推送

至此就完成了下单到消息推送的流程，返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图15所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到如下信息，从上往下按照红字标记的顺序：

1. 订单消息消费者收到订单完成的消息。
2. 消费者开始发送微信的推送消息。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpy8unr0wtl.png)图15 接受订单完成消息并且发送微信通知

到此，就完成了整个订单下单、保存、优惠券更新、微信消息推送的全部流程。

#### **6、总结**

本节课带大家将订单下单的整个流程带大家走了一遍。作为本周的最后一节课，这里做一个总结。本周从订单业务流程切入，介绍了同步形式的订单流程，提出并发问题以后，又引入了异步模式的订单流程。在实现保存订单代码以后，又加入了微信消息推送的功能，最后实现整个订单的全流程。这里讲[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week07_38讲/)给大家。

下周的课程会以取消订单为主，看看RocketMQ在其中发挥了哪些作用。下期见，拜拜。

### **40_一步一图：互联网酒店预订系统之超时取消订单的整体业务逻辑梳理**

**1、开篇**

上周从订单业务流程切入，介绍了同步形式的订单流程，提出并发问题以后，又引入了异步模式的订单流程。在实现其代码以后，又加入了微信消息推送的功能，最后实现整个订单的全流程。

本周课程聚焦于订单取消的功能实现，会介绍订单取消的业务流程以及中间遇到的问题，我们如何基于RocketMQ延时消息来优化原有逻辑，完善取消订单功能。今天是本周的第一节课，主要给大家讲解取消订单的业务流程。今天会学到以下内容：

- 取消订单的业务流程

#### **2、**取消订单的业务流程

在讲述取消订单流程之前先回顾下单流程，如图1 所示，客户通过登录酒店小程序经过查询酒店、房间的功能生成订单，创建的订单有待入住/待付款的状态，然后更新优惠券信息，最后发送微信消息通知。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpzrf3k0sdc.png)

图1 下单流程

由于本周的主角是取消订单的流程，因此我们将上图进行简化，整理为下单流程和最终生成的订单，再继续取消订单流程的描述。如图2 所示，我们将整个“下单流程”进行了浓缩，形成了一个模块放在最上面，紧接着就是生成订单，可以理解为实际的订单。

同样它是需要和管理后台的数据进行同步的。接下来就是取消订单的流程，我们用有颜色的模块标示出来，大家可以顺着执行的步骤一起来看：

1. 在订单生成完毕以后，客户是可以手动取消订单的，这种操作在小程序上就可以实施，属于显性操作。
2. 还有一种情况就是在订单创建30分钟以后依旧没有对订单进行付款，此时系统会自动取消订单，把购买的机会让给其他客户。通常的做法，会在系统中设置一个“扫描订单支付状态”的Job，这个Job每隔一段时间会扫描订单表。
3. 扫描时筛选条件为订单状态待支付，同时订单超过30分钟未支付，此时会执行“自动取消订单”的业务，我们把这个自动取消的动作可以理解为隐性动作，是在满足一定条件下触发的动作。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpzsgxz0y70.png)

图2 取消订单业务流程

上图中谈到的手动取消订单的业务比较好理解，如图3 所示，在订单完成以后点击“取消订单”就可以完成对应的操作。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpzstue0enu.png)

图3 取消订单操作

但是与取消订单操作的显性动作不同的是，创建订单30分钟以后没有执行支付，而导致订单取消的隐性动作容易被忽视。取消订单业务需要考虑以上两种动作所对应的场景。

#### **3、**总结

本节课从回顾下单流程切入，介绍了取消订单流程与下单流程直接的关系，通过流程图的方式介绍了取消订单流程中存在的两种动作，显性动作：主动取消订单；隐性动作：超时未支付自动取消订单。

下节课会思考自动取消订单通过Job“扫描订单表”的实现方式存在什么样的问题。下期见，拜拜。

### **41_知己知彼：先看看未引入mq时，大量订单超时的取消逻辑**

**1、开篇**

上节课从回顾下单流程切入，介绍了取消订单流程与下单流程直接的关系，通过流程图的方式介绍了取消订单流程中存在的两种动作，显性动作：主动取消订单；隐性动作：超时自动取消订单。

今天会从订单超时说起，看如何通过跑job方式实现自动取消订单的功能。今天会学到以下内容：

- 创建订单超时场景
- 定时任务扫描订单表
- 定时任务存在的问题

#### **2、**创建订单超时场景

在完成下单流程以后，客户通常是会进行付款操作的，但也有例外情况，例如：看中了其他的房间、或者对周边环境的要求更换了居住的酒店等等。无论出现何种情况，生成的订单都处于“未支付”状态。

一般而言这种已经下单的房间，酒店会为客人保留一段时间，在这段时间内其他客人是无法预订当前房间。正因为有这样的规定，酒店预订系统中一般会设计30分钟支付的业务流程。客户在下单的30分钟之内如果进行支付，那么这个房间就是你的了。

反之，如果超过30分钟没有支付，酒店系统就会释放掉房间资源让其他客户进行预订，这里体现的操作就是“自动取消订单”。与“手动取消订单”不同的是，“自动取消订单”是由系统通过检查订单状态和超时时间来完成的。

#### **3、**定时任务扫描订单表

那么如何实现自动取消订单逻辑呢？通常来说我们会建立一个定时任务，如图1 所示，下方蓝色的模块就是定时任务，让我们顺着图中的序号，一起看看它们是如何工作的吧：

1. 创建订单以后，订单信息会保存到数据库中。
2. 如果此时有支付订单的行为，一定会更新数据库中订单的状态为“已支付”。
3. 定时任务会不断扫描订单表。
4. 定时任务在筛选订单数据时会设置两个条件，第一个订单状态是否是“未支付”，第二个是创建订单的时间到当前的时间是否超过了30分钟。只有满足以上两个条件才执行“取消订单”的操作。
5. 定时任务调用取消订单的接口，紧接着更新数据库中订单的信息，完成自动取消订单的流程。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klpz5bn9018o.png)

图1 定时任务处理取消订单流程

#### **4、**定时任务存在的问题

虽然定时任务能满足自动取消超时订单的逻辑，但是这种实现方式实际上并不是很好。

一个原因是未支付状态的订单可能是比较多的，然后你需要不停的扫描他们，可能每个未支付状态的订单要被扫描N多遍，才会发现他已经超过30分钟没支付了。

另外一个是很难去分布式并行扫描你的订单。因为假设你的订单数据量特别的多，然后你要是打算用多台机器部署订单扫描服务，但是每台机器扫描哪些订单？怎么扫描？什么时候扫描？这都是一系列的麻烦问题。

实际上可以通过RocketMQ延时消息来解决这个问题，这也是我们下节课要讲到的内容。

#### **5、总结**

本节课从自动取消订单功能，引出了定时任务与各个模块之间合作完成订单状态和时间的检查，最终实现自动取消订单。同时分析定时任务实现自动取消订单的缺陷。

下节课会引出RocketMQ延时消息对自动取消订单功能进行改造。下期见，拜拜。

### **42_眼前一亮：再看看MQ如何基于延时消息机制，优化大量订单的定时退款扫描问题**

**1、开篇**

上节课从自动取消订单功能，引出了定时任务与各个模块之间合作完成订单状态和时间的检查，最终实现自动取消订单。同时分析定时任务实现自动取消订单的缺陷。今天会从上节课中遇到的问题说起，并且通过引入RocketMQ延时消息优化自动取消订单的实现。今天会学到以下内容：

- RocketMQ的延迟消息机制
- 调整取消订单业务流程图 

#### **2、**RocketMQ的延迟消息机制

如果说引入RocketMQ接收订单生成的消息，同时发送一个延迟30分钟的消息给消费者。在30分钟以后消费者接受到消息在进行订单状态的判断，不仅减少了扫表的工作，而且简化的实现逻辑，同时还将两个功能进行了解耦，不是挺好吗。

顺着这个思路思考，我们通过引入RocketMQ的方式在创建订单的时候就发送一个延迟消息，这个消息会发送到RocketMQ内部延时的topic中，在30分钟后RocketMQ内部会重新投递到原topic给订阅该订单延时topic消费者消费，在消费的时候去判断订单是否被支付，如果没有支付就取消订单。

如图1 所示，将上述想法具体化为如下步骤：

1. 在创建订单的时候，就调用消息生产者生成一条延迟消息。
2. 这个延迟消息生产者的任务就是发送一条消息，消息在30分钟以后会被消费。
3. 延迟消息消费者会在30分钟以后获取消息通知，此时判断“订单是否支付？”
4. 如果此时订单没有支付，就满足了订单创建以后30分钟都没有支付的条件，于是调用取消订单的操作。完成系统自动取消订单的功能。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq0m5fd01nb.png)

图1 RocketMQ的延迟消息机制

#### **3、**调整取消订单业务流程图

由于定时任务面对大量超时未付款订单的处理效率问题，我们将其替换成了RocketMQ的方案。如图2 所示，方案按照以下几个步骤进行：

1. 订单生成之后通过延迟消息生产者发送延迟消息，也就是上面提到的30分种被消费的订单消息，这个消息会被发送到RocketMQ的队列中。
2. 在30分钟的延迟时间以后，延迟消息消费者会获取到这个消息，并且对消息内容进行判断，如果还没有支付。
3. 那么就满足了30分种以后依旧没有支付的订单条件，于是执行取消订单的操作。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq0mku90bky.png)

图2 调整后的取消订单业务流程图

#### **3、总结**

本节课为了解决大量未支付超时订单扫表性能问题，基于RocketMQ的延时消息进行优化。在创建订单的时候发送延迟消息（30分钟），消费者在接受到延迟消息的时候再判断是否支付，未支付则取消订单。

下节课会带大家进行取消订单业务代码的编写。下期见，拜拜。

### **43_代码实战：编写代码实现通过延时消息取消订单、退回优惠券、推送消息（一）**

**1、开篇**

上节课为了解决大量未支付超时订单扫表性能问题，基于RocketMQ的延时消息进行优化。在创建订单的时候发送延迟消息（30分钟），消费者在接受到延迟消息的时候再判断是否支付，未支付则取消订单。

本节课带大家完成客户手动取消订单的代码，也就是前面提到的显性取消订单的动作，今天会学到以下内容：

- 新增取消订单服务
- 退回优惠券服务
- 发送取消订单消息
- 新增取消订单Controller

#### **2、**新增取消订单服务

有取消订单服务针对的对象依旧是订单，因此对于实体类和服务类依旧可以与创建订单保持一致。这里需要在“/api/order/service/”和“/api/order/service/impl”中分别修改OrderService接口和OrderServiceImpl的实现，主要是加入cancelOrder的方法。传入orderNo作为订单号，phoneNumber 作为手机号。

如图1所示，这个方法中还调用了其他几个方法，依次给大家介绍：

\1. 首先从数据库中获取订单相关的信息。

\2. 在取消订单之前需要判断订单的状态，原则上要保证订单状态为“未支付”的情况下，才能取消订单。

\3. 在取消完订单以后，需要把订单状态更新为“取消”。

\4. 如果订单中使用了优惠券，需要退回优惠券，因此需要更新优惠券对应的数据库表。

\5. 最后就是发送订单取消的微信消息通知了。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq1b9ih02um.png)图1 取消订单

如图2 所示，查询订单详情的方法getOrderInfo比较简单，就是向数据库发起SQL的查询语句，通过订单号针对“t_shop_order“进行查询，并且返回OrderInfoDTO对象。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq1bnax0i8j.png)图2 查询订单详情

如图3所示更新订单状态将其设置为Cancel状态的方法 updateOrderStatusAndCancelTime，需要传入订单号、取消时间和手机号信息。也是对“t_shop_order”表进行操作，将订单对应的status字段更新为“CANCELED”，也就是取消状态。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq1c15y0fh9.png)图3 更新订单取消状态 

#### **3、**退回优惠券服务

还记得我们在首次登录的时候会给客户发放优惠券，如果客户在下单的时候使用了优惠券，那么在取消订单的时候将返还优惠券，以便客户在下次下单的时候能够再次使用。

如图4 所示，在“api/coupon/service”下面的CouponServiceImpl中加入了backUsedCoupon方法，同样在CouponService的接口中也定义了这个方法。该方法传入CouponId和phoneNumber，并且对“t_coupon_user”这张表进行了更新操作，将优惠券状态修改为“NOT_USED”也就是没有被使用。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq2gq8k0q2g.png)图4 更新优惠券

#### **4、**发送取消订单消息

和创建订单相同在取消订单的时候也需要通知微信小程序，告知客户订单取消。如图5所示，在”api/order/service/impl”的OrderEventInformManager中加入了informCancelOrderEvent方法，传入参数和informCreateOrderEvent的方法一样都是OrderInfoDTO，不过消息类型是”WX_CANCEL_ORDER”,表示是取消订单的通知。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq2h42d0jmc.png)图5 取消订单微信通知消息

#### **5、**发送取消订单消息新增取消订单Controller

由于本次修改基于客户手动取消订单，也就是前面说到的显性动作，因此需要提供一个RESTFUL的API接口给前端调用。如图6所示，在”api/order/controller”中的OrderController文件中加入cancelOrder的方法传入订单号和手机号，该方法直接调用OrderSerivce中的cancelOrder完成取消订单的过程。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq2hiu90qxb.png)图6 取消订单Controller

#### **6、总结**

本节课带大家完成了手动取消订单的代码，包括：新增取消订单服务、退回优惠券服务、发送取消订单消息、新增取消订单Controller等，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week08/)给大家。

下节课会带大家完成自动取消订单的代码实现。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **44_代码实战：编写代码实现通过延时消息取消订单，退回优惠券、推送消息（二）**

**1、开篇**

上节节课带大家完成了手动取消订单的代码，包括：新增取消订单服务、更新优惠券服务、发送取消订单消息、新增取消订单Controller等。今天会从自动取消订单服务入手，看看在创建订单时如何通过RocketMQ的延时消息来取消未付款超时的订单，今天会学到以下内容：

- 初始化延时消息消费者
- 创建延时消息监听者
- 完善创建订单功能

#### **2、**初始化延时消息消费者

有了延迟消息的发送者就有消息的消费者，如图2 所示，在“api/order/consumer”下面建立OrderDelayConsumerConfiguration类，其中定义了name server address、topic和group的信息。和producer 一样也，通过@Bean的annotation 定义了orderDelayConsumer，并且定义orderDealyMessageListener作为订阅消息的Listener，同时启动orderDelayConsumer消费者。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq5u9rf03w1.png)图2 延迟消息消费者

#### **3、**创建延迟消息监听者

上面初始化了消费者以后，这里聚焦于延迟消息的处理。如图3 所示，在“api/order/listener”中创建OrderDelayMessageListener类，该类实现MessageListenerConcurrently 接口中的consumeMessage方法，对接收到的message进行处理。由于producer发送的是延迟消息，因此consumeMessage是在延迟以后接受到的消息。

方法中会通过message中解析处订单信息，通过redis加入分布式锁，防止在取消订单的时候同时客户进行支付订单，让取消和支付动作串行化，保证数据的正确性。然后就是调用orderService中的cancelOrder方法传入订单号和手机号，对订单进行取消操作。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq5w15x01mt.png)图3 加入OrderDelayMessageListener

#### **4、**完善创建订单功能

还记得上周课程中，我们介绍过在创建订单之后会发送微信的消息通知，需要针对这个方法进行改造。如图4 所示，在“api/order/service/impl”下的OrderEventInformManagerImpl类中，将informCreateOrderEvent进行改造。原来的sendOrderMessage方法不变，它是用来发送微信消息通知的。

只需要添加sendOrderDelayMessage方法，传入orderInfoDTO用来发送延迟消息。在方法中初始化message对象，设置topic并且设置orderDelayLevel，然后通过orderMqProducer的send方法进行发送。我们配置的orderDelayLevel的默认值是9，对应的是5m，也就是5分钟的延迟。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq5wj0b0lfq.png)图4 OrderEventInformManagerImpl中添加sendOrderDelayMessage方法

其中orderDelayLevel是从配置文件中获取的，如图5所示，在application.properties文件中国的rocketmq.order.delay.level中对其进行了配置，其值为9。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq5wx1c0dh7.png)图5 delay level的配置

这里的9是时间对应延迟时间的位移量，如果设置8 就对应4m，也就是4分钟。我们将每个延迟时间对应的level值的对应关系放到如下表格中，给大家参考，在测试的时候可以调整具体时间。

| 时间  | 1s   | 5s   | 10s  | 30s  | 1m   | 2m   | 3m   | 4m   | 5m   | 6m   | 7m   | 8m   | 9m   | 10m  | 20m  | 30m  | 1h   | 2h   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Level | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   |

#### **5、**总结

本节课带大家完成了自动取消订单的代码，包括：初始化延迟消息消费者、创建延时消息监听者、完善创建订单逻辑等，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week08/)给大家。

下节课会带大家测试这两节课完成的代码。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **45_阶段测试：验证一下系统预订超时订单是否自动取消？**

**1、开篇**

上节课带大家完成了自动取消订单的代码，包括：初始化延迟消息消费者、创建延时消息监听者、完善创建订单逻辑等。今天带大家把手动取消订单和自动取消订单两个场景带大家走一遍，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 手动取消订单流程演示
- 自动取消订单流程演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**手动取消订单演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq67znm04md.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq68gru029z.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq68uo00idq.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq69ai30m9o.png)

图11 确认订单

由于本周课程主要介绍订单流程，还没有涉及到付款过程，因此如图12所示，在弹出的支付页面中，选择“取消”按钮。此时会生成订单，状态为“代付款”。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq69p2v0q4w.png)

图12 取消支付

如图13所示，在点击“取消”以后，就进入了订单详情页面，列出订单价格、订单状态、房型、床型、房间数、预订人、手机号等信息。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6a2ob0n66.png)

图13 订单详细信息

在图13的基础上点击“取消订单”按钮，执行取消订单的操作。

返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图14所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到如下信息，从上往下按照红字标记的顺序：

1. 获取订单信息，从而知道订单状态。
2. 获取订单项的信息。
3. 由于是取消订单，因此更新订单状态为“取消”。
4. 更新优惠券信息，从而回退优惠券。
5. 在完成取消订单以后会发送订单取消的消息。
6. 在订单取消的消费者接受到取消订单消息以后会进行微信消息的推送。

![图片14.1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6d09q0rb5.png)![图片14.2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6d09r0mr3.png)![图片14.3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6d09s0bt7.png)图14 手动取消订单

查看完日志以后，再回到小程序上如图15所示，此时可以看到订单详情中看到，订单状态为“已取消”。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6dnus0lah.png)

图15 已取消订单

如图16 所示，在微信小程序中也收到了一条取消订单的通知

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6e5wy0rau.png)

图16 取消订单通知。

#### **6、**自动取消订单演示

自动取消订单的演示和手动的区别在于自动取消订单是在创建订单以后，就不做任何操作了，一直等待到支付超时，如果此时还没有支付的话，系统会自动取消订单。

上节课的代码中给大家介绍的我们为了实验把消息延迟的时间设置成为了5分钟。也就是在创建订单以后，等上5分钟再去查看日志、订单详情、消息通知就会发现订单已经取消了。

先看日志中再下单流程中的部分，如图17所示如下：

1. 下单成功以后会保存订单信息。
2. 同时会保存订单项信息。
3. 并保存使用优惠券的信息。
4. 发送下单成功的微信消息推送。
5. 最重要的是通过延迟消息生产者发送了下单成功的延迟消息。

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6f5u60932.png)图17 自动取消订单-生产者部分

下单完成以后就是等待了，等待超时以后消费者会获取超时消息，如图18所示：

1. 延迟消息消费者接受到延迟消息。
2. 查询订单信息。
3. 查询订单项信息。
4. 更新订单状态为“已取消”并且保存。
5. 更新优惠券信息，回退优惠券。
6. 最后发送取消订单的微信消息。

![图片18.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6g6jx0g44.png)图18 自动取消订单-消费者部分

#### **7、**总结

本节课给大家演示了手动取消订单和自动取消订单，作为本周的最后一节课，这里照例做一个总结。本周课程从取消订单的业务流程作为切入点，发现存在大量未支付超时订单扫表效率问题，从而基于RocketMQ的延时消息来进行优化。

在原有的订单代码基础上进行升级，在生成订单的时候就发送延迟消息，然后由消息消费者接受到延迟消息的时候判断订单状态，如果是未支付就取消订单，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week08/)给大家。

下周课程将讲解支付订单的功能。下期见，拜拜。

### **46_一步一图：互联网酒店预订系统之支付订单的整体业务逻辑梳理**

**1、开篇**

上周课程给大家介绍了手动取消订单和自动取消订单的业务流程，课程从取消订单的业务流程作为切入点，发现存在大量未支付超时订单扫表效率问题，从而基于RocketMQ的延时消息来进行优化。

在原有的订单代码基础上进行升级，在生成订单的时候就发送延迟消息，然后由消息消费者接受到延迟消息的时候进行判断订单状态，如果是未支付就取消订单。

本周课程以订单支付为主，这节课作为本周的第一节课会围绕着订单支付主要流程展开，今天会学到以下内容：

- 订单支付主要流程

#### **2、**订单支付主要流程

到目前为止我们已经介绍了下单流程和取消订单的流程，这些流程都是围绕订单展开的，让我们还是回到总体业务流程的大图上来看。

如图1所示，我们将之前介绍过的下单流程、取消订单流程以及生成订单的动作进行简化处理，用灰色的模块表示。因此，将重点放到有颜色的部分，也就是订单的支付流程。依旧按照箭头从上往下的顺序依次给大家介绍：

1. 在完成订单以后，有两个选择一个是取消订单，另外一个是支付订单。在点击“支付订单”按钮的时候，首先会调用微信支付接口，由于是第三方接口需要等待接口返回支付是否成功。因此这里会涉及到回调服务的设计，后面章节会具体展开。另外，为了让大家顺利进行实验，儒猿团队对支付过程进行了简化，弹框显示是否支付，点击确认支付则回调支付接口。
2. 在获得微信支付的回调以后，会判断支付是否成功。如果失败就通知用户，如果成功就会保存支付的流水信息。
3. 此后就会进入支付幂等性的判断环节，主要原因是对同一个订单的支付不会重复执行。
4. 支付完成以后会更新订单状态，将其修改为“已支付”的状态。
5. \5. 最后还会给客户推送“支付成功”的微信消息推送，依旧会带上对应的支付信息和订单信息作为参考。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq6zjgx0d8t.png)

图1 订单支付主要流程

#### **3、**总结

本节课作为本周的第一节课，介绍了支付订单的业务流程，其主要包括：调用微信支付接口、保存支付流水、支付幂等性判断、更新订单状态、发送支付成功微信消息。

下节课会先从微信支付接口说起，看看项目是如何调用微信支付接口完成支付工作的，同时看看是如何对应支付的回调接口的。下期见，拜拜。

### **47_稳扎稳打：先来分析一下微信小程序订单如何支付的？**

**1、开篇**

上节课作为本周的第一节课，介绍了支付订单的业务流程，其主要包括：调用微信支付接口、保存支付流水、支付幂等性判断、更新订单状态、发送支付成功微信消息。今天的课程主要给大家介绍微信支付接口，今天会学到以下内容：

- 小程序调起支付API单支付主要流程
- 签名算法
- 微信小程序支付调用例子

#### **2、**小程序调起支付API

由于我们的前端是通过微信小程序完成的，如果在其中实现支付的功能需要使用小程序支付API。通过小程序下单接口获取到发起支付的必要参数prepay_id，可以按照接口定义中的规则，使用微信支付提供的SDK调起小程序支付。

在小程序中调用wx.requestPayment(OBJECT)发起微信支付，这里的OBJECT就是我们需要传入的关于支付的对象。如图1 所示，传入的OBJECT包括如下部分：

时间戳（timeStamp），表示发起支付的当前时间，通过字符串类型显示。

随机字符串（nonceStr），是一个不长于32位的随机数字，是为了随机算法而使用的。

订单详情扩展字符串（package），这个是统一下单接口返回的prepay_id参数值。具体到本项目，也就是预下单的订单Id。

签名方式（signType），为了安全性考虑，会通过appId、timeStamp、nonceStr和package生成签名，这里的signType就是签名算法，默认情况下时RSA算法。

签名（paySign），每次支付请求都会通过通过appId、timeStamp、nonceStr和package生成签名，生成的是一个无法阅读的字符串。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq78u3q0epq.png)

图1 支付接口传入对象

#### **3、**签名算法

上面提到了在调用小程序支付接口的时候需要传入OBJECT，其中需要将一些信息进行签名处理，其目的就是为了解决安全问题。因此需要经历如下几个步骤：

1、构造签名串

签名串一共有四行，每一行为一个参数。行尾以\n（换行符，ASCII编码值为0x0A）结束，包括最后一行。

如果参数本身以\n结束，也需要附加一个\n

参与签名字段及格式：

APPID（小程序ID）

时间戳（TimeStamp）

随机字符串（NonceStr）

订单详情扩展字符串（package）

数据举例：

APPID（小程序ID）：wx8888888888888888

时间戳（TimeStamp）：1414561699

随机字符串（NonceStr）：5K8264ILTKCH16CQ2502SI8ZNMTM67VS

订单详情扩展字符串（package）：prepay_id=wx201410272009395522657a690389285100

2、计算签名值（paySign）

PaySign的生成就是通过签名方式（signType）加上上述资格参数生成的，这里不具体深入算法原理。算法会生成如下的字符串。

oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ\/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq\/xDg==

#### **4、**微信小程序支付调用例子

上面讲述了调用的请求内容和签名的方式，下面说一下调用的例子和回调函数的处理。如图2 所示，timeStamp传入了时间戳信息，nonceStr是随机字符串、package是prepay_id（预订单）的ID号，signType是签名的加密算法RSA，上述信息加密以后最终生成paySign。这些信息在请求以后微信的支付接口会返回支付的结果。分别是success成功、fail失败和complete完成。

之前和大家提供这里支付的细节已经由儒猿团队处理过了，因此我们聚焦到支付成功的情况，在图中标注出success的情况下会调用我们项目提供的API的访问地址。这个具体的访问地址已经封装程了RESTFUL API，并且以PayController的方式暴露出去了，小程序这端的代码已经实现，在下一章的内容中会给大家介绍。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7aenn0yf9.png)

图2 微信支付例子

#### **5、**总结

本节课介绍了酒店小程序如何调用微信的支付接口完成支付的，其中介绍了接口的调用方法、传入的OBJECT对象以及对应的每个参数，为了安全性对传入的参数进行了数字签名，最后提供了微信支付的调用例子。

下节课会带大家把支付订单的代码实现一遍。下期见，拜拜。

### **48_代码实战：编写支付订单的代码，通过MQ来通知微信支付订单成功**

**1、开篇**

上节课介绍了酒店小程序如何调用微信的支付接口完成支付的，其中介绍了接口的调用方法、传入的OBJECT对象以及对应的每个参数，为了安全性对传入的参数进行了数字签名，最后提供了微信支付的调用例子。今天主要带大家完成支付订单的代码实战，今天会学到以下内容：

- 数据库表与实体类设计
- 订单支付接口与实现类
- 订单支付回调入口
- 更新订单支付服务

#### **2、**数据库表与实体类设计

由于订单支付需要记录支付的流水情况，就好像银行流水一样需要将客户进行的每一笔交易都记录下来。如图1 所示，根据支付业务建立“pay_transaction”表，包括交易流水号、订单号、订单总金额、订单优惠金额、订单应付金额、交易渠道、用户支付账号以及手机号、交易时间等信息。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7nqok0lvu.png)图1 订单交易流水数据库表

同样与之对应的也有实体类的设计，如图2 所示，在“api/pay/dto”下面的PayTransaction类中就定义了支付流水的实体类。其中包括：订单号、订单应付金额、交易渠道、第三方支付交易编号、第三方支付完成时间以及响应码等信息。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7o6qi0pht.png)图2 交易流水实体类

由于交易记录可以被查询，因此在”api/pay/dto”下面建立QueryPayStatusResponse类，如图3所示，其包括用户手机号、订单编号、订单应付金额、第三方支付交易流水号、第三方支付我完成支付的时间、第三方支付相应状态码等信息。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7on0l0ghc.png)图3 交易查询信息

#### **3、**订单支付接口与实现类

有了实体之后需要编写对应的交易逻辑，于是在“api/pay/service”和“api/pay/service/impl”下面分别建立PayTransactionService接口和PayTransactionServiceImpl的实现。

如图4所示，其主要目的就是更新“pay_transaction”表的内容，记录每一笔的支付交易。其中建立了save方法传入PayTransaction和phoneNumber参数，插入订单号、订单量、支付金额、支付账户、支付渠道、流水号、支付时间、返回码、以及状态等信息。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7q40c0li5.png)图4 支付服务

#### **4、**订单支付回调入口

由于我们是通过调用微信的支付接口完成支付的，在请求支付的时候就会指定回调函数。这里的PayController提供的RESTFUL API就是回调函数。 如图5 所示，wxCallBack方法对应“wx/callback”的url，接受QueryPayStatusResponse作为参数，这个对象就是微信支付完成以后传给调用方的。

从中可以获取订单号、用户账号、流水号、订单完成时间、返回码、支付渠道、以及支付金额和状态的信息。并且通过执行payTransactionService中的save方法将订单流水进行保存。同时在订单支付成功以后会调用orderService中的informPayOrderSuccessed方法发送通知。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7qyih0y9r.png)图5 支付成功回调入口

#### **5、**更新订单支付服务

订单支付服务之前就已经有了只是加入了新方法informPayOrderSuccessed，供支付完成回调使用。如图6所示，在OrderService和OrderServiceImpl中分别加入informPayOrderSuccessed方法，传入订单号和手机号作为参数。在获取订单信息的同时，进行更新订单状态的操作，通过updateOrderStatusAndPayTime方法将订单状态更新为“已支付”。

需要注意的是为了更新订单状态的时候防止取消订单，使用了Redis作为同步锁，让对订单支付操作和自动取消操作串行化。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq7rrbu02zx.png)图6 更新订单支付服务

#### **6、**总结

本节课完成了支付订单的代码实践，其中包括数据库表和实体类的设计、订单支付接口与实现类、订单支付回调入口以及更新订单支付服务，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week09_48讲/)给大家。

下节课会带大家测试上面代码。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **49_阶段测试：验证一下支付接口是否收到回调，订单状态一切正常吗？**

**1、开篇**

上节课我们实战了支付订单代码编写，今天主要带大家完成支付订单的代码的测试，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 支付流程演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**支付订单演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图14所示，在安装目录下面的logs中保存了日志文件start.log，这个文件可以往下翻看可以看到如下信息，从上往下按照红字标记的顺序：

1. 支付成功以后会记录支付交易的流水信息。
2. 查询订单信息
3. 查询订单项信息
4. 针对具体订单更新订单状态为“已支付”。
5. 发送支付完成信息。
6. Message的服务接受到支付完成信息以后，推送支付完成消息给微信端客户。

![图片14.1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8i2ny0f7w.png)![图片14.2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8i2nz0ba3.png)图14 支付订单日志

#### 5、总结

本节课完成支付订单的测试工作，在微信支付接口完成支付之后会回调PayController会执行如下操作：记录支付流水、查询订单（项）信息、更新订单状态为“已支付”、发送支付完成信息、推送微信消息，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week09_48讲/)给大家。

下节课会讨论订单重复支付的问题。下期见，拜拜。

### **50_打开脑洞：思考一下订单在什么情况下会重复支付？**

**1、开篇**

上节课完成支付订单的测试工作，在微信支付接口完成支付之后会回调PayController会执行如下操作：记录支付流水、查询订单（项）信息、更新订单状态为“已支付”、发送支付完成信息、推送微信消息。今天的课程主要讨论重复支付的场景，今天会学到以下内容：

- 页面点击多次场景
- 支付回调重复多次场景
- 模拟重复请求支付的场景

#### 2、页面重复点击的场景

在实际使用支付接口的场景有可能是微信小程序或者是H5页面，也有可能是IOS或者Android的客户端，无论是那种调用方式都会遇到页面重复点击的情况。此时会发起多次对微信接口的请求，从而导致重复付款的问题。

不过这种情况可以通过前端控制的方式避免，例如点击“支付”按钮以后按钮就设置为无法使用，直到支付结果返回才生效。又或者在前端设置，针对同一个订单号的请求支付动作会做记录，只能进行一次。

不过作为Java的后台程序员来说，不能把控制完全放倒前端，即便是在前端有控制的情况下也需要在支付记录流水的时候避免重复支付的场景，也就是我们所说的支付幂等性。

#### 3、支付回调重复多次场景

上面提到了支付幂等性的问题，也就是同一订单的多次支付动作都视为一次，特别在支付回调的时候。大家都知道支付完成以后微信接口会调用我们系统的支付回调方法，也就是本例中PayController，PayController处理完毕以后也会给微信接口进行响应。

但由于网络关系这个响应可能没有及时发送到，此时微信接口会重复调用PayController再次进行尝试，如果此时不考虑支付幂等性的问题，我们的系统中有可能就记录了两条支付信息。造成的结果就是在流水中有两条交易记录，一般电商平台在最终对账的时候会发现交易的流水和实际出货量不一致。这也是为什么系统需要考虑支付幂等性的问题。

#### 4、模拟重复请求支付的场景

上面提到了两种重复支付的场景，这里我们尝试模拟一下，采取的模拟方式是通过Postman发送请求到PayController 的wxCallback的方法上，并且针对同一个订单发送多次请求，看系统是如何处理的。如图1 所示，打开Postman，选择POST的请求方式，输入URL地址

http://47.117.114.131:8088/api/pay/wx/callback

然后在输入如下参数：

| Key                  | Value                            | 说明                                                         |
| -------------------- | -------------------------------- | ------------------------------------------------------------ |
| orderNo              | a0821373acca415da5dddcd014a96201 | 订单号，大家需要通过start.log 中找到刚刚下单的订单号，复制过来使用 |
| userPayAcconut       | 123423423@qq.com                 | 用户支付账号                                                 |
| transactionNumber    | wx0001                           | 第三方支付交易流水号                                         |
| finishPayTime        | 2018/7/7 11:11:00                | 支付时间，测试使用                                           |
| responseCode         | 200                              | 返回码                                                       |
| payTransactionStatus | 2                                | 支付状态                                                     |
| payableAmount        | 0.02                             | 支付总额，测试数据                                           |
| phoneNumber          | 158272**376                      | 订单手机号                                                   |

在输入URL和对应的参数以后会看到返回的错误码500，同时收到message：“系统异常，请联系管理员”。这里连续点击两次“Send”按钮，也就是模拟发起两次支付的会调用，目的是为了模拟重复支付的场景。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8rzeu0w9k.png)图1 通过Postman反复请求PayController支付接口

返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图14所示，在安装目录下面的logs中保存了日志文件start.log，发现有两条订单支付的流水记录，都是对同一个订单号的操作，也就是说同一个订单被记录了支付两次。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8sf5s0g5m.png)图2 重复的支付流水记录，订单号相同

#### 5、总结

本节课描述两种重复支付的场景：页面重复点击和支付回调重复，并且通过Postman向小程序后台API的支付回调函数发送重复请求，模拟了上面两种场景。

下节课会使用Redis解决订单支付的幂等性问题，看看代码应该如何修改。下期见，拜拜。

### **51_代码实战：基于Redis幂等机制，解决订单重复支付的问题**

**1、开篇**

上节课描述两种重复支付的场景：页面重复点击和支付回调重复，并且通过Postman向小程序后台API的支付回调函数发送重复请求，模拟了上面两种场景。今天主要从代码实施的角度来看如何通过Redis实现重复支付的幂等性问题，今天会学到以下内容：

-  支付回调接口加入幂等机制 

#### 2、支付回调接口加入幂等机制

从幂等性原理上来说，就是这个操作无论执行多少次起结果都是一样的。回到订单支付的功能上来看，一个订单无论执行多少次支付，都只能扣一次钱、执行一次支付流水的记录。因为这个支付流水是要用来做对账核销操作的，是不允许出错的。

如图1所示，修改“api/pay/controller/PayController”类，在wxCallback方法的中，记录订单支付流水之前加入红框中的代码。加入存入Redis的部分，通过redisApi.setnx方法（已经由儒猿团队进行封装）将消息信息保存到Redis中。设置订单号作为Key，后面的订单号、电话号码作为Value。

利用setnx的函数特性，当response返回成功“SUCCESS”同时返回值为“FALSE”说明Redis中对应的Key已经有Value 了，也就说明Redis中已经存在这个订单号，表明系统已经处理过这个订单的支付流水了。这种情况下，只记录一个日志，而不进行后续的操作。

反而如果返回的是“SUCCESS”并且返回值为“TRUE”，说明Redis没有记录这条消息，也就是第一次支付订单，那么就需要新增一条订单支付的流水信息。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8yb4308vq.png)图1 统一订单多次支付保证接口幂等

大家可以看到上面红框的代码加入以后，将每次订单支付信息都在Redis进行记录，这样一来即便是对同一订单的多次支付请求回调，都会判断在Redis中是否存在订单支付的记录，一旦发现就不予处理。程序根本就不会进入到下面的支付流水的记录和订单状态保存的部分。充分地保证了支付的幂等性，防止了重复支付的情况发生。

这种使用Redis保证操作幂等性的手法我们在重复获取优惠券的场景下也使用过，如果大家有兴趣可以跳回到之前的章节回顾一下。在很多涉及到关键信息的操作时，例如：现金、积分、优惠券都需要保证幂等性，这种方式也是工业级应用中常见的。

#### 3、总结

本节课给大家介绍了保证订单支付幂等性的代码实现，通过Redis保存订单支付信息，利用setnx方法的特性判断在Redis中是否存在对同一订单的支付信息，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week09_51讲/)给大家。

下节课带大家将完成的代码测试一遍，主要看看对幂等性的测试。下期见，拜拜。 

### 52_阶段测试：验证一下引入幂等之后，能否解决订单重复支付的问题？

**1、开篇**

上节课给大家介绍了保证订单支付幂等性的代码实现，通过Redis保存订单支付信息，利用setnx方法的特性判断在Redis中是否存在对同一订单的支付信息。今天带大家将完成的代码测试一遍，主要看看对幂等性的测试，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 支付流程演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://little-admin.ruyuan2020.com/ “。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### 5、多次支付订单演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

至此位置已经对一个订单进行了支付，如果再进行重复支付应该不会记录支付的流水记录，同时会有日志提醒。为了模拟重复支付的场景，依旧使用Postman进行测试，通过Postman发送多次支付的Post请求，看看结果如何。

如图14 所示，打开Postman，选择POST的请求方式，输入URL地址

http://47.117.114.131:8088/api/pay/wx/callback

然后在输入如下参数：

| Key                  | Value                            | 说明                                                         |
| -------------------- | -------------------------------- | ------------------------------------------------------------ |
| orderNo              | a0821373acca415da5dddcd014a96201 | 订单号，大家需要通过start.log 中找到刚刚下单的订单号，复制过来使用 |
| userPayAcconut       | 123423423@qq.com                 | 用户支付账号                                                 |
| transactionNumber    | wx0001                           | 第三方支付交易流水号                                         |
| finishPayTime        | 2018/7/7 11:11:00                | 支付时间，测试使用                                           |
| responseCode         | 200                              | 返回码                                                       |
| payTransactionStatus | 2                                | 支付状态                                                     |
| payableAmount        | 0.02                             | 支付总额，测试数据                                           |
| phoneNumber          | 158272**376                      | 订单手机号                                                   |

在输入URL和对应的参数以后会看到返回的code状态码200，同时收到message：“成功”。这里连续点击多次“Send”按钮，也就是模拟发起多次支付的回调，目的是为了模拟重复支付的场景。

![14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km0cyeq40xve.png)图14 通过Postman反复请求PayController支付接口

返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图15所示，在安装目录下面的logs中保存了日志文件start.log，这里显示了多条“duplicate pay order orderNo：XXXX”的信息，这正是幂等性代码起了作用，当发现针对同一订单多次发起支付请求的时候，就会返回错误并且记录对应的日志。

![15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/km0cuv6w08jm.png)图15 重复的支付流水记录，订单号相同 

#### 6、总结

本节课是本周的最后一次课照例给大家进行总结，本周从订单支付功能的业务流程作为切入点，分析了再小程序端如何实现微信支付，当使用支付回调接口的时候会遇到幂等性的问题。最后，使用Redis解决支付幂等性的问题，最后这里讲[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week09_51讲/)给大家。

下周的课程会围绕用户入住的功能展开。下期见，拜拜。

### **53_一步一图：互联网酒店预订系统之用户入住整体业务逻辑梳理**

**1、开篇**

上周的课程从订单支付的业务流程作为切入点，分析了再小程序端如何实现微信支付，使用Redis解决支付幂等性的问题。本周的课程聚焦于用户入住功能的开发，今天是本周的第一节课，主要给大家讲解用户入住的业务逻辑，今天会学到以下内容：

- 用户入住业务流程

#### 2、用户入住业务流程

前面几周分别介绍了登录、优惠券发放、下单、取消订单、支付订单等业务流程。当客户达到酒店办理入住事宜的时候，管理人员在与客户核实订单信息以后就可以给客户办理入住手续了。

如图1 所示，我们依旧将前面几个章节中已经讲过的部分用灰色模块表示，目的是简化业务流程操作，同时也让大家看到整体业务的走向。本节课从支付订单之后的流程说起，将其分为以下几个步骤：

1. 支付订单完成以后，酒店后台管理人员可以登录酒店管理后台查看到对应的订单状态，此时的订单状态为“待入住”。
2. 当客户到店进行入住手续办理时，酒店后台管理人员会核实订单信息，进行“确认入住”，此后客人就可以入住酒店了。
3. 在“确认入住”完成以后，也会向酒店小程序端发送一条“确认入住”的消息，此时客户可以查看确认入住消息。
4. 同时，客户在小程序端查看订单状态的时候，其状态也修改为“已入住”，从而完成入住的业务流程。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqa4odj063m.png)

图1 用户入住流程

从整个用户入住流程来看主要是小程序端与管理后台进行交互，属于系统或者应用之间的沟通，在实战过程中会使用不同的包结构来代表不同的应用，在消息通知的部分依旧会使用RocketMQ作为桥梁。

#### 3、总结

本节课作为本周的第一节课，介绍了用户入住的流程，用户在下单支付以后，后台管理人员可以查看到订单状态，当用户到店进行入住的时候，管理员可以确认入住的状态，最终通知小程序端的客户，入住成功的消息。

下节课给大家讲解用户入住的代码实践。下期见，拜拜。

### **54_代码实战：编写代码，完成用户入住整体业务功能开发**

**1、开篇**

上节课作为本周的第一节课，介绍了用户入住的流程，用户在下单支付以后，后台管理人员可以查看到订单状态，当用户到店进行入住的时候，管理员可以确认入住的状态，最终通知小程序端的客户，入住成功的消息。本节课主要讲解用户入住的代码实现，今天会学到以下内容：

- 创建管理端订单服务
- API端订单服务添加确认入住接口
- 创建用户入住功能入口

#### 2、创建管理端订单服务

由于用户入住的功能是在后台管理中实现的，因此需要在后台管理对应的API中定义对应的服务。如图1 所示，在“admin/service/”下面分别建立AdminOrderService的接口和AdminOrderServiceImpl的实现。其中定义并实现了confirmOrder方法，传入参数为订单号和手机号。在服务的内部调用了orderService中的informConfirmOrder方法，把两个参数都传入。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqa8tf50mfc.png)图1 AdminOrderService和AdminOrderServiceImpl

#### 3、API端订单服务添加确认入住接口

由于上面的AdminOrderService使用了订单服务的内容，因此需要回到“api/order/service”和“api/order/service/impl”下面修改OrderService接口和OrderServiceImpl实现。

如图2所示，在接口和实现中加入inforConfirmOrder方法传入参数正是订单号和手机号。在方法中会调用updateOrderStatus方法，传入上述两个参数之外还传入了“CONFIRM”的订单状态，也就是确定订单。

再看updateOrderStatus方法中实际上是对“t_shop_order”表的更新，其主要目的就是根据订单号，将订单状态更新为“CONFIRM”。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqaahsl0r2e.png)图2 修改订单服务

在更新完订单状态之后，会调用OrderEventInformManager接口中的inforConfirmOrderEvent方法进行微信通知。

如图3所示，在“api/order/service”和“api/order/service/impl”下面修改OrderEventInformManager接口和OrderEventInformManagerImpl的实现，加入inforConfirmOrderEvent方法传入参数是orderInforDTO，其直接调用sendOrderMessage的方法给用户推送“确认订单”的消息通知。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqaayq70un1.png)图3 订单消息组件添加确认订单事件

#### 4、创建用户入住功能入口

由于在酒店后台管理系统中进行用户入住的操作，因此需要在admin中提供一个controller作为API服务。如图4所示，在“admin/controller”中建立AdminOrderController，对应的访问路径为“/admin/order”，同时建立confirmOrder的方法，其访问方式为get、访问路径为“/confirmOrder”，传入参数为订单号和手机号，在方法内部直接调用adminOrderService接口中的confirmOrder方法。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqabgx90yn7.png)图4 创建AdminOrderController

#### 4、总结

本节课给大家讲解了用户入住功能的代码实现，包括：创建管理端订单服务、API端订单服务添加确认入住接口、创建用户入住功能入口等，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week10/)给大家。

下节课给带大家测试用户入住功能。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### **55_阶段测试：提交代码后，再来验证一下客户是否入住成功？**

**1、开篇**

上节课给大家讲解了用户入住功能的代码实现，包括：创建管理端订单服务、API端订单服务添加确认入住接口、创建用户入住功能入口等。本节课主要讲解用户入住的代码实现，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 用户入住演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)

图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**用户入住演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

此时订单已经生成，如图14所示，

\1. 通过访问“https://project-practice-cloud.ruyuan2020.com/”利用购买课程的手机号登录酒店后台管理系统。

\2. 点击左侧菜单“酒店管理-订单管理”，展开右边的订单列表。

\3. 在订单记录中找到刚才下单的记录，点击“入住”按钮。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb0yiv0s4h.png)图14 进入后台管理系统进行用户入住操作

点击“入住”以后会弹出如图15所示的确认框体，点击“确定”完成入住。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1fdf06y7.png)

图15确认入住操作

如图16所示，完成上述操作以后会弹出“入住成功”的消息，同时原来操作中的“入住”也变成了“退房”。

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1ux00p4z.png)图16 入住成功消息

此时用户的微信中会接受到如图17 所示的服务通知，也就是用户入住以后的订单确认通知。

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb29t60zjs.png)

图17 订单确认通知

#### **5、**总结

本节课带大家测试了用户入住的代码，作为本周的最后一节课，我们来总结一下。本周从用户入住的业务流程说起，讲述了酒店小程序和酒店管理后台如何交互完成用下单到入住的流程流转，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week10/)给大家。

下周课程将聚焦于用户退房业务的介绍。下期见，拜拜。

### 56_一步一图：互联网酒店预订系统之用户退房整体业务逻辑梳理

 **1、开篇**

上周的课程从用户入住的业务流程说起，讲述了酒店小程序和酒店管理后台如何交互完成用户下单到入住的流程流转。本周的焦点在用户退房的业务实现，会将退房流程中的修改订单状态、下发优惠券以及消息通知等步骤给大家做介绍，还会基于RocketMQ的事务消息对系统优化。

今天是本周的第一节课，主要给大家讲解用户退房的业务流程，今天会学到以下内容：

- 用户退房业务流程

#### 2、用户退房业务流程

照旧在讲解今天的业务流程之前回顾一下之前的业务。在完成登录、授权、获取手机号等操作之后，通过查询酒店和房间进行下单。生成订单以后可以取消也可以走支付流程，支付完成以后客户到酒店入住，酒店的管理人员会对其进行确认，此时完成订单入住操作，同时客户也会接受到消息推送。

今天从确认入住往下介绍，用户在结束旅程之后会进行退房的操作，这个操作由酒店后台管理人员完成，在这之后会修改订单状态为“已完成”，并且下发优惠券，同时也会发送微信的消息通知。如图1 所示：

1. 确认入住以后，用户将度过美好的假期，当房间到期的时候会到酒店前台进行退房操作。此时酒店后台管理系统的管理人员会进行“退房”操作。
2. 退房之后会修改订单状态，将其修改为“已完成”。
3. 同时会下发优惠券，通过这种方式引导用户再次入住。
4. 最后，发送微信的消息通知，告诉用户已经完成退房的操作。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqc215j0utd.png)图1 用户退房业务流程

从整个流程上来看，退房操作起点在酒店后台管理系统，执行者是酒店后台管理人员。该功能是在管理后台，不过调用了酒店小程序后台API的部分功能。例如：修改订单状态、下发优惠券以及通用模块发送消息通知。

#### 3、总结

本节课作为本周的第一节课，给大家回顾了之前的业务流程，并且介绍了用户退房的流程，其中包括：退房、修改订单状态、下发优惠券以及发送微信消息通知。

下节课带大家将业务转化为代码，看看其是如何实现的。下期见，拜拜。

### 57_代码实战：编写代码，完成用户退房整体业务功能开发

 **1、开篇**

上节课作为本周的第一节课，给大家回顾了之前的业务流程，并且介绍了用户退房的流程，其中包括：退房、修改订单状态、下发优惠券以及发送微信消息通知。今天带大家实现用户退房的代码，今天会学到以下内容：

- 修改管理后台订单服务
- 修改小程序订单服务
- 修改消息通知服务
- 修改后台管理入口

#### 2、修改管理后台订单服务

正如上节课提到的，用户退房的动作是管理员在酒店管理后台完成的，因此需要在管理后台的API添加该功能，从而支持界面上的退房操作。

如图1 所示，在“admin/service/”和“admin/service/impl”下面分别修改AdminOrderService接口和AdminOrderServiceImpl，加入方法finishedOrder，传入订单号和手机号的信息。由于使用的是订单的业务，因此需要调用orderService的informFinishedOrder方法并且传入两个参数。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqc7foj04sy.png)图1 修改管理后台API

#### 3、修改小程序订单服务

顺着刚才的思路，针对订单业务的修改调用了orderService，因此也需要将小程序服务进行修改。如图2 所示，在“api/order/service”和“api/order/service/impl”下面分别修改OrderService和OrderServiceImpl的接口，分别加入informFinishedOrder方法，接受订单和手机号参数。

本方法通过订单号和手机号获取订单信息，通过updateOrderStatus方法将订单状态修改为“FINISHED”，再调用couponService中的distributeCoupon方法给用户下发优惠券，其中需要传入用户Id、优惠券Id和优惠券有效天数等信息。最后，再通过orderEventInformManager中的informOrderFinishEvent方法进行微信的消息通知。 

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqc82ar0u4j.png)图2 修改小程序订单服务

#### 4、修改消息通知服务

由于在订单服务中需要发送微信消息通知，如图3所示，在“api/order/service”和“api/order/service/impl”分别更新OrderEventInformManager接口和OrderEventInformManagerImpl 实现，加入informOrderFinishEvent方法，传入OrderInfoDO，通过sendOrderMessage方法发送“完成订单”的推送消息。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqcbw6f05wa.png)图3 修改消息通知服务

#### 5、修改后台管理入口

最后回到后台管理的入口处，修改RESTFUL API的Controller类。如图4所示，在“admin/controller”下面修改AdminOrderController类，加入finishedOrder方法，接受订单号和手机号作为参数，通过“/finishedOrder”的路由进行访问。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqccdtu0t5m.png)图4 修改后台管理入口

#### 6、总结

本节课给大家介绍用户退房的代码实现，其包括：修改管理后台API、修改小程序订单服务、修改消息通知服务以及修改后台管理入口，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week11_57讲/)给大家。

下节课带大家测试今天实现的代码。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### 58_阶段测试：提交代码后，再来验证一下客户是否退房成功？

**1、开篇**

上节课给大家介绍用户退房的代码实现，其包括：修改管理后台订单服务、修改小程序订单服务、修改消息通知服务以及修改后台管理入口。今天带大家对上节课编写的代码进行测试，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 用户退房演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“[https://project-practice-cloud.ruyuan2020.com/ ](https://project-practice-cloud.ruyuan2020.com/)“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**用户入住演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

此时订单已经生成，如图14所示，

\1. 通过访问“https://project-practice-cloud.ruyuan2020.com/”利用购买课程的手机号登录酒店后台管理系统。

\2. 点击左侧菜单“酒店管理-订单管理”，展开右边的订单列表。

\3. 在订单记录中找到刚才下单的记录，点击“入住”按钮。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb0yiv0s4h.png)图14 进入后台管理系统进行用户入住操作

点击“入住”以后会弹出如图15所示的确认框体，点击“确定”完成入住。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1fdf06y7.png)

图15确认入住操作

如图16所示，完成上述操作以后会弹出“入住成功”的消息，同时原来操作中的“入住”也变成了“退房”。

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1ux00p4z.png)图16 入住成功消息

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb29t60zjs.png)

图17 订单确认通知

在收到订单确认通知之后，在此回到后台管理系统中，如图18所示，点击“退房”按钮，在弹出的提示框中点击“确定”按钮。

![图片18.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqcqxjv0yqy.png)图18 确认退房

如图19所示，此时订单状态为“无操作”，表明已经完成订单操作。

![图片19.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqcrfry0ger.png)图19 订单状态为“无操作”

在小程序端的用户会收到对应的微信通知，如图20所示，在微信通知中描述了订单编号以及“订单结束通知”的说明。

![图片20.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqcrzzl0lzi.png)

图20 订单结束通知

#### **6、总结**

本节课将上节课编写的代码进行了测试，将登录、查询、下单、支付、入住、退房整个流程给大家走了一遍，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week11_57讲/)给大家。

下节课分析一下是否存在用户退房成功，但是优惠券没有到账的情况。下期见，拜拜。

### 59_打开脑洞：分析一下是否存在用户退房成功，但优惠券没有到账的情况？

**1、开篇**

上节课将讲退房业务编写的代码进行了测试，将登录、查询、下单、支付、入住、退房整个流程给大家走了一遍。今天带大家分析一下是否存在退房成功但是优惠券没有到账的情况，今天会学到以下内容：

- 现有用户退房流程存在的问题
- 基于RocketMQ分布式事务优化退房流程

#### 2、现有用户退房流程存在的问题

先回忆一下之前讲解过的用户退房的业务逻辑，如图1 所示，在酒店后台管理系统中进行退房之后，会进行“修改订单状态”和“下发优惠券”两个操作。

会存下如下可能性，当“修改订单状态”成功以后，因为服务宕机导致“下发优惠券”服务无法正常运行。导致的结果就是“修改订单状态”成功，但是优惠券没有下发。因此这里需要考虑将两个操作放到同一个事务里面执行，如果遇到“修改订单状态”成功而“下发优惠券”不成功的情况，需要将“修改订单状态”操作进行回滚。也就是说要么两个操作同时成功，要么两个操作都不执行。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqcz5mz034k.png)

图1 现有用户退房逻辑

同时订单服务和优惠券服务同步调用高度的耦合，当优惠券服务宕机时整个订单退房流程将不可用。

因此需要基于RocketMQ进行解耦，也就是在“修改订单”成功以后发送消息给“下发优惠券”服务，“下发优惠券”服务在接受到消息以后在执行对应的功能。

仔细想想虽然订单服务和优惠券解耦了，但是存在mq不可用，导致退房消息发送失败情况，需要不断的重试。为了解决以上问题，我们提出下面RocketMQ的分布式事务的方案。

#### 3、基于RocketMQ分布式事务优化退房流程

根据上面的分析得出的结论是将订单服务和优惠券服务进行解耦，同时在发送消息的时候还要保证两个服务中的操作的一致性，也就是分布式事务。因此我们作出如下方案设计，如图2所示：

1. 订单服务在执行退房订单的时候先向RocketMQ队列发送一个half消息，用来确定MQ的可用性。
2. 在接受到half消息以后，MQ会返回一个成功的响应。
3. 如果此时MQ不可用，那么订单服务就不需要继续执行更新订单的操作了。假设MQ运行正常，订单服务会去执行本地事务完成“更新订单状态”的操作。
4. 订单服务执行的本地事务成功与否，会发给MQ不同的信息。当本地事务成功了，会发送Commit消息，MQ内部会将消息投递到完成订单的topic中，也就是优惠券服务的消费者可以看到订单服务发送的消息。如果本地事务没有成功，就需要发送rollback消息，告诉MQ删除之前发送的half消息，意思是：“我的事务执行出错了，就当没有这回事，你该干嘛干嘛！”。
5. 但是有一种情况，订单服务执行本地事务以后在返回commit或者rollback结果MQ时，由于网络问题MQ没有收到，过一段时间以后MQ就会回调订单服务的接口，判断消息状态，询问是commit消息还是rollback消息。
6. 这里假设订单服务的本地事务执行成功发送给MQ commit信息。MQ收到以后内部会将消息投递到完成订单的topic中。
7. 优惠券服务中会有一个consumer一直监听这个消息。
8. 当收到完成订单消息以后就执行下发优惠券的操作，从而保证用户能够收到优惠券。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqd375j07bi.png)图2 改造后的用户退房流程

#### 4、总结

本节课分析了现在用户退房流程存在的问题，指出订单服务与优惠券服务耦合和一致性问题，并基于RocketMQ的分布式事务来解决这些问题。

下节课我们讲通过代码来实现本节课的方案。下期见，拜拜。

### 60_代码实战：引入mq的事务消息，保证优惠券能够到账

**1、开篇**

上节课分析了现在用户退房流程存在的问题，指出订单服务与优惠券服务耦合和一致性问题，并基于RocketMQ的分布式事务来解决这些问题。今天带大家完成该方案的代码实现，今天会学到以下内容：

- 修改订单服务
- 完成订单事务生产者的初始化与启动
- 创建RocketMQ回调的Listener
- 修改优惠券消费者 

#### 2、修改订单服务

由于管理后台在进行退房的时候，会调用订单服务，所以需要对该服务进行修改。如图1 所示，将之前修改订单、下发优惠券以及发送通知的代码替换成发送message的代码。这里通过调用orderFinishedTransactionMqProducer中的sendMessageInTransaction方法，将包含订单信息的orderInfoDTO对象发送出去。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmb0np06er.png)图1 修改订单服务

#### 3、完成订单事务生产者的初始化与启动

由于订单服务中调用了orderFinishedTransactionMqProducer是其发送订单完成的消息，因此需要对其进行初始化和启动。在“api/order/producer”中的OrderProducerConfiguration中创建orderTransactionMqProducer方法，并且定义对应的监听器为finishedOrderTransactionListener，在方法中初始化producer 并且设置了对应的name server address以及事件回调线程池处理。需要注意的是，这里的finishedOrderTransactionListener是用来接受MQ回调的listener，它的定义在下面会展开介绍。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmbj540sde.png)图2 OrderProducer的初始化与启动

#### 4、创建RocketMQ回调的Listener

为了处理MQ回调我们会创建对应响应回调的Listener，如图3所示，在“api/order/listener”中建立FinishedOrderTransactionListener类，该类会实现TransactionListener的接口，其中会override方法excuteLocalTransaction。这个方法在half消息发送成功之后供MQ回调。方法中会对订单的状态进行修改，并且发送消息通知。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmc6xz0u27.png)图3 创建RocketMQ回调的Listener – executeLocalTransaction方法

此外，这个类中还override另外一个方法checkLocalTransaction，如图4所示，它是在MQ没有收到commit或者rollback消息时回调订单服务的方法。它会判断订单服务本地事务的执行情况，如果执行成功会发送commit消息，否则会发送rollback消息。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmcp8y08hj.png)图4 创建RocketMQ回调的Listener – checkLocalTransaction方法

#### 5、修改优惠券消费者

说完了订单服务这边，它加入了产生订单完成消息的producer，同时也定义了MQ响应的回调Listener。接下来就是优惠券服务的部分了，由于订单完成以后会发送message，一旦订单服务的本地事务完成以后，优惠券这边的consumer就可以结束后到message了。

如图5所示，在“/api/coupon/consumer”的CouponConsumerConfiguration中添加一个finishedConsumer方法，对consumer进行初始化并且设置name server address和对应的topic。同时将其在应用启动时注入并且启动consumer。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmd8u70toy.png)图5 修改优惠券消费-加入订单退房消息的consumer

定义了consumer就会定义对应的listener来消费消息，如图6所示，在“api/coupon/listener”中建立orderFinishedMessageListener。在override方法cosumeMessage中，主要处理下发优惠券的逻辑。能够进入到这个方法，说明已经收到“完成订单”的消息了，此时会解析订单消息。

通过redisApi.setnx的方法确保退房订单的幂等性，保证同一个订单不会执行多次，而导致用户领取多张优惠券。在保证幂等性之后，会通过调用couponService中的distributeCoupon方法执行优惠券的下发工作，包括定义优惠券Id、有效天数、用户Id、电话等信息。

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqme0b50dlt.png)图6 修改优惠券消费-加入OrderFinishedMessageListener

#### 6、总结

本节课将订单服务和优惠券通过RocketMQ进行解耦并且实现分布式事务、包含如下代码实现：修改订单服务、OrderProducer的初始化与启动、创建RocketMQ回调的Listener、修改优惠券消费者，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week11_60讲/)给大家，将今天的代码进行测试。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### 61_阶段测试：最后再来验证一下改造后的退房逻辑

**1、开篇**

上节课将订单服务和优惠券通过RocketMQ进行解耦并且实现分布式事务、包含如下代码实现：修改订单服务、OrderProducer的初始化与启动、创建RocketMQ回调的Listener、修改优惠券消费者。今天带大家测试上节课写的代码，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 用户退房演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/“。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**用户退房演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

此时订单已经生成，如图14所示，

\1. 通过访问“https://project-practice-cloud.ruyuan2020.com/”利用购买课程的手机号登录酒店后台管理系统。

\2. 点击左侧菜单“酒店管理-订单管理”，展开右边的订单列表。

\3. 在订单记录中找到刚才下单的记录，点击“入住”按钮。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb0yiv0s4h.png)图14 进入后台管理系统进行用户入住操作

点击“入住”以后会弹出如图15所示的确认框体，点击“确定”完成入住。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1fdf06y7.png)

图15确认入住操作

如图16所示，完成上述操作以后会弹出“入住成功”的消息，同时原来操作中的“入住”也变成了“退房”。

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1ux00p4z.png)图16 入住成功消息

此时用户的微信中会接受到如图17 所示的服务通知，也就是用户入住以后的订单确认通知。

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb29t60zjs.png)

图17 订单确认通知

在收到订单确认通知之后，在此回到后台管理系统中，如图18所示，点击“退房”按钮，在弹出的提示框中点击“确定”按钮。

![图片18.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqml0s90w14.png)图18 确认退房

如图19所示，此时订单状态为“无操作”，表明已经完成订单操作。

![图片19.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmlkp509ip.png)图19 订单状态为“无操作”

在小程序端的用户会收到对应的微信通知，如图20所示，在微信通知中描述了订单编号以及“订单结束通知”的说明。

![图片20.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmlz4s0n9d.png)

图20 订单结束通知

至此退房逻辑从界面上来说和没有改造之前都是一样的，不过经过RocketMQ对订单服务和优惠券进行解耦以后，可以从日志中看出不同之处。

返回到ECS上查看日志。登录ECS以后，输入以下命令

vim /home/admin/little-project-rocketmq/logs/start.log

如图21所示，在安装目录下面的logs中保存了日志文件start.log，可以发现如下信息：

1. 查询订单和订单项信息，发送half消息。
2. MQ 回调执行本地事务。
3. 更新订单状态，执行完成订单。
4. 消息服务收到完成订单消息进行微信通知。
5. MQ收到commit消息后，投递到完成订单topic中。
6. 优惠券服务订阅到完成订单消息，下发优惠券。

![图片21.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmmmx20y6d.png)![图片21.1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmmmx40jcc.png)图21通过RocketMQ实现完成订单

#### 6、总结

本节课通过用户退房功能的演示，把整个酒店系统的业务流程包括：登录、授权、获取手机号、查询酒店、查询房间、下单、付款、入住以及退房。最后的退房部分，通过RocketMQ将订单服务和优惠券服务进行解耦，同时还保证了修改订单状态和下发优惠券两个操作的事务一致性。

本节课作为本周的最后一节课，这里做一个总结，本周从用户退房的业务流程切入，通过分析用户退房成功而优惠券没有到账的场景，推出通过RocketMQ保证其事务一致性的方案，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week11_60讲/)给大家。

下周课会围绕着设计模式的重构展开，看看如何对订单模块进行重构。下期见，拜拜。

### 62_新的思考：如何基于设计模式重构订单消息推送功能？

**1、开篇**

上周课程完成了用户退房的业务逻辑，作为整个课程业务的终点，我们完成了从登录、查询、下单、支付、入住、退房的全流程介绍。本周课程会在上周的基础上对架构进行重构，会围绕message模块加入设计模式，提高系统的扩展性。

今天将会基于工厂模式和模版方法模式对订单消息推送进行重构，今天会学到以下内容：

- 订单消息推送功能分析
- 加入工厂模式
- 加入模版方法模式 

#### 2、订单消息推送功能分析

在对订单消息推送模块进行优化之前先看看目前是如何实现的，如图1 所示，在“api/message/lisenter”下面的OrderMessageLisenter类主要实现消息推送的功能。

其中的consumerMessage方法在接受到消息以后会创建订单消息和订单内容，然后通过send方法进行发送。从红框的部分需要通过MessageTypeEnum来判断不同的消息类型，例如：创建订单、取消订单、支付订单等，来组件消息的内容。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqn1ex800ve.png)图1 原来的消息推送模块

#### 3、加入工厂模式

如果观察原来的消息推送模块，可以发现都是针对不同消息的推送。除了消息类型和消息体内容不同，整个生产消息发送消息的动作都是相同的。只要创建一种机制能够创建不同的消息就可以了。这里让人联想到了工厂模式，如图2所示：

- Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
- IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
- Product：具体产品类，是简单工厂模式的创建目标。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqn300y0tky.png)

图2 工厂模式类图

那么根据工厂模式的思路将生成消息的功能进行重构，如图3 所示：

1. 首先，将消息推送功能进行抽象，这里定义了接口OrderMesageCommand，其中定义了抽象方法send，传入参数是OrderInfo。
2. 然后，根据这个接口定义一个Abstract类，这个类需要实现send方法。除了send 方法之外，还定义了两个抽象方法分别是builderWxOrderMessage和getMessageType。builderWxOrderMessage用来实现订单消息体的创建，getMessageType用来设定消息类型（创建订单、取消订单等）。同样这两个方法需要具体的消息类（Command）来实现。
3. 接下来，就是具体消息类的实现了，这里列出了5个消息类，分别代表了5类订单消息推送。WaitPayOrderMessageCommand：创建订单；CancelOrderMessageCommand：取消订单；ConfirmOrderMessageCommand：确认订单；PayOrderMessageCommand：支付订单；FinishedOrderMessageCommand：完成订单。在这5个类中需要实现builderWxOrderMessage和getMessageType方法。
4. 最后，就是OrderMessageCommandFactory类了，它作为工厂类是用来生成不同订单消息（产品）的，其中定义了create方法传入参数是messageTypeEnum，也就是订单类型。返回的结果是OrderMessageCommand，在使用工厂类的时候只需要通过create生成订单类，这个类的实体取决于传入的订单类型参数，然后直接调用OrderMessageCommand的send方法就完成消息发送。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqn3syx0fnr.png)图3 通过工厂模式实现订单消息实体的生成

#### 4、加入模版方法模式

有了工厂模式以后就可以根据不同订单生成对应的消息推送，有新的订单消息就建立一个新的command和对应的订单类型，在工厂中定义对应的订单实现类，工厂可以根据订单类型生产出对应的订单消息类。

再把目光看下订单发送的过程，其中有两个步骤必不可少，分别是：生成订单消息体和发送消息。可以将这两个步骤进行抽象，让具体的订单实现类完成自身消息体的构建就可以了。这让人联想到了模版方法设计模式。

如图4所示，抽象类定义了算法的结构，每个算法结构的Process中包含了多个步骤：Step1、Step2、Step3。但是这些步骤并不是固定的，比如不同的订单类型生成消息体的内容就不一样，因此需要将这些步骤抽象出去对其进行解耦，让具体的实现子类去完成。在Concrete Class的实现类中去实现Abstract Class中对应的Step 步骤，例如：Step2、Step3.

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqn5dkb05mg.png)

图4 模版方法模式

介绍完了模版方法模式，我们回到订单消息推送的模块。如图5 所示在AbstractOrderMessageCommand中定义了发送方法send，可以理解为模版方法中的算法接口，其包括两个Step：Step1 通过builderWxOrderMessage创建订单消息体，Step2 调用微信推送的API发送消息。

对于Step2 来说是微信发送的通用方法，因此可以放到AbstractOrderMessageCommand中实现，对于具体的实现类不用关系。对于Step1 来说，需要实现类创建对应的消息体，因此ConfirmOrderMessageCommand作为具体的消息推送实现类就需要实现builderWxOrderMessage方法。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqn62bl034g.png)

图4 模版方法模式

**5、总结**

本节课从分析现有订单消息推送功能切入，为了提升程序的可读性以及扩展性，需要对功能模块进行解耦，做到高内聚低耦合。因此，引入了工厂模式和模版方法模式，并且将其应用到消息推送功能中。下节课会将上面的设计模式进行编码实践。下期见，拜拜。

### 63_精益求精：基于工厂模式+模板方法模式，优化订单消息推送功能

**1、开篇**

上节课从分析现有订单消息推送功能切入，为了提升程序的可读性以及扩展性，需要对功能模块进行解耦，做到高内聚低耦合。今天会将上节课的设计模式进行编码实践，今天会学到以下内容：

- 定义订单消息接口
- 定义订单消息实体类
- 定义消息发送工厂模式
- 通过工厂类发送订单消息

#### 2、定义订单消息接口

针对订单消息定义接口，如图1所示，在“api/message/manager”中创建OrderMessageCommand接口，接口中定义send方法，传入的参数是OrderInfo。Abstract class 会继承这个接口，继续实现的定义。后面的所有实体类都可以执行send方法。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqnfn5d0y4k.png)图1 OrderMessageCommand 接口定义

定义完接口以后，再来进行抽象类的定义，如图2所示在“api/message/manager”中创建AbstractOrderMessageCommand，其对OrderMessageCommand进行了实现。需要注意的是针对send方法实现的时候使用了模版方法模式。

这里有两个步骤：生成订单消息体（Step1）和发送消息（Step2）。Step1需要根据订单类型在消息通知的实体类中实现因此是一个abstract方法。Step2 的发送订单，接受参数是wxOrderMessage和phoneNumber，属于通用方法，因此就在AbstractOrderMessageCommand类中完成了实现。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqng8v30ino.png)

图2 定义AbstractOrderMessageCommand类

#### 3、定义订单消息实体类

有了订单消息的接口和抽象类定义之后，就需要针对不同的订单类型生成对应的实体类。这个消息类型上节课也提到了，包括：创建订单、取消订单、确认订单、支付订单、完成订单。这里我们以确认订单为例给大家介绍，其他订单的实体类创建和这个类似，只是具体实现根据订单类型不同而不同。

如图3所示，“api/message/manager”中创建ConfirmOrderMessageCommand类，有两个方法需要override，分别是builderWxOrderMessage和getMessageType。其中builderWxOrderMessage就是上面提到的Step1 用来创建具体订单消息体的方法。另外，getMessageType就是简单返回确认订单类型。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqngs8q05x0.png)图3 创建ConfirmOrderMessageCommand实体类

#### 4、定义消息发送工厂模式

准备好接口、抽象类和实体类以后，接下来就是轮到工厂登场了。如图4所示，在“api/message/manager”中创建OrderMessageCommandFactory，提供一个create方法作为生成消息通知实体的入口，传入MessageTypeEnum用来标示消息类型。然后根据不同的实体类型new出不同的订单消息对象。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqnh76i05pm.png)

图4 创建 OrderMessageCommandFactory

#### 5、通过工厂类发送订单消息

工厂类作为订单消息的入口，那么如何使用它发送订单消息呢？如图5所示，这里我们截取一段代码给大家介绍。代码中直接使用orderMessageCommandFactory的create方法传入MessageType并生成订单对象，由于订单对象对应的类都是继承与OrderMessageCommand的，因此会把引用赋给它，同时调用send方法传入OrderInfo然后进行消息通知的发送。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqnin050gy6.png)

图5 使用OrderMessageCommandFactory进行订单消息发送

#### 5、总结

本节课通过代码落地的方式，在原有的Message模块中加入了工厂和模版方法模式，其包括：定义订单消息接口、定义订单消息实体类、定义消息发送工厂模式、通过工厂类发送订单消息，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week12/)给大家，下节课，我们来测试一下今天编写的代码。下期见，拜拜。

友情提示：本章讲述代码只是部分核心代码，完整代码请查阅文末链接中代码，谢谢。

### 64_阶段测试：验证一下设计模式重构之后的订单系统整体逻辑是否正常

**1、开篇**

上节课从分析现有订单消息推送功能切入，为了提升程序的可读性以及扩展性，需要对功能模块进行解耦，做到高内聚低耦合。今天会将上节课的设计模式进行编码实践，今天会学到以下内容：

- 申请ECS 
- 打包部署
- 启动服务
- 全流程演示

#### **2、申请ECS** 

正如前面课程提到的，发布应用之前需要申请ECS，并且获取对应的登录密码。

如图1 所示，经过这几步的操作：

1. 登录使用购买课程的手机号和验证码登录网站：“https://project-practice-cloud.ruyuan2020.com/ “。
2. 点击“小实战课程”菜单栏。
3. 选择课程列表中RocketMQ小实战数据行。点击“分配机器”按钮，等待分配ECS服务器。
4. 大约1分钟左右，点击右上角的“刷新”按钮，刷新ECS 的信息。
5. 最后，获取ECS 的IP和登录密码，为发布做好准备。

![图片1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjahkb04fr.png)图1 申请ECS 服务器

#### **3、**打包部署

在上节课完成代码以后，我们将其打包并且进行部署。在这次介绍完毕以后，后面的实战项目也可以效仿类似的打包流程进行。

如图2所示，在IntelliJ IDEA 中输入“mvn clean install”对上节课的项目进行打包。

![图片2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjhbfi0m6j.png)

图2 mvn clean install 开始打包

如图3 所示，打包完成以后会看到“BUILD SUCCESS”的绿色字样，同时会在target目录下面看到little-project-rocketmq.jar 的打包文件，说明打包成功，接下来就是将jar包发布到ECS服务器了。

![图片3.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjq92e0e0l.png)

图3 编译成功

打包完成以后就使用scp命令将jar包拷贝到对应的ECS服务器上。也就是在IntelliJ IDEA的命令行中执行如下命令。

scp target/little-project-rocketmq.jar root@47.117.120.102:/home/admin/little-project-rocketmq/target

如图3 所示，输入命令以后会弹出密码的输入框，大家使用从小实战平台上申请的密码就可以了。另外注意scp中涉及到的ECS的IP地址需要使用你申请的，图中的例子是我使用的测试IP地址。

![图片4.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjqs1v0ydf.png)

图4 部署 jar包到ECS 服务器

部署完毕以后会出现，如图5中所示的100%进度完成的标示。

![图片5.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrbtf0ubu.png)图5完成部署

接下来就是要登录ECS服务器启动应用了。如图6所示，打开命令行工具输入以下代码，然后输入ECS的登录密码。

ssh root@{IP地址}

![图片6.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjrunk0sqm.png)

图6 登录ECS服务器

#### **4、**启动服务

在完成部署以后，就需要启动服务了。

如图7所示，在登录ECS服务器之后，做如下操作：

\1. 通过cd 命令到达”/home/admin/little-project-rocketmq/” 目录下面。

\2. 检查是否存在deploy.sh 文件，这个是服务启动的shell脚本文件，定义了对应的RocketMQ服务器端口号，以及环境参数等等。

\3. 执行“sh deploy.sh restart”命令启动服务。

\4. 当看到[http://127.0.0.1:8080 success](http://127.0.0.1:8080 success/)字样的时候就可以确认服务已经正常启动了。

![图片7.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klkjscrv0k0k.png)图7启动服务

#### **5、**用户退房演示

如图8 所示，登录授权获取手机以后查询酒店。

![图片8.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8ess50lr5.png)

图8 查询酒店

如图9 所示，在酒店查询结果中选择“儒猿酒店北京分店”。

![图片9.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8f7dc0zq4.png)

图9 酒店查询结果

如图10 所示，选择“儒猿北京分店”，显示该酒店的房间列表。依旧选择“test02”的房间。

![图片10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8fphb0nh0.png)

图10 房间列表

如图11所示，点击“test02”房间右边的“预订”按钮，进入确认订单页面。这里需要填写，入住、离店时间、房间数、入住人、手机号、优惠券、预计到店时间等信息。为了确认订单可以点击“立即付款”按钮。

![图片11.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8g5xx00rl.png)

图11 确认订单

如图12所示，在点击“立即付款”按钮以后，会弹出确认框，点击“确定”用来确认支付。

![图片12.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8gmn900rg.png)

图12 支付订单

如图13所示，在支付完成以后订单状态会修改为“待入住”。

![图片13.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klq8h2bw0hf0.png)

图13 支付完成

此时订单已经生成，如图14所示，

\1. 通过访问“https://project-practice-cloud.ruyuan2020.com/”利用购买课程的手机号登录酒店后台管理系统。

\2. 点击左侧菜单“酒店管理-订单管理”，展开右边的订单列表。

\3. 在订单记录中找到刚才下单的记录，点击“入住”按钮。

![图片14.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb0yiv0s4h.png)图14 进入后台管理系统进行用户入住操作

点击“入住”以后会弹出如图15所示的确认框体，点击“确定”完成入住。

![图片15.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1fdf06y7.png)图15确认入住操作

如图16所示，完成上述操作以后会弹出“入住成功”的消息，同时原来操作中的“入住”也变成了“退房”。

![图片16.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb1ux00p4z.png)图16 入住成功消息

此时用户的微信中会接受到如图17 所示的服务通知，也就是用户入住以后的订单确认通知。

![图片17.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqb29t60zjs.png)

图17 订单确认通知

在收到订单确认通知之后，在此回到后台管理系统中，如图18所示，点击“退房”按钮，在弹出的提示框中点击“确定”按钮。

![图片18.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqml0s90w14.png)图18 确认退房

如图19所示，此时订单状态为“无操作”，表明已经完成订单操作。

![图片19.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmlkp509ip.png)图19 订单状态为“无操作”

在小程序端的用户会收到对应的微信通知，如图20所示，在微信通知中描述了订单编号以及“订单结束通知”的说明。

![图片20.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqmlz4s0n9d.png)

图20 订单结束通知

如图21所示，此时订单状态为“无操作”，表明已经完成订单操作。

![图片21.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqnqpjd0bde.png)图21 订单状态为“无操作”

在小程序端的用户会收到对应的微信通知，如图22所示，在微信通知中描述了订单编号以及“订单结束通知”的说明。

![图片22.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/klqnr7fr0nad.png)

图22 订单结束通知

#### 6、总结

本节课作为本周课程的最后一节，在此总一个总结，本周课程从消息通知系统的设计模式切入，对原有的消息推送模块进行重构加入工厂模式、模版方法等设计模式。把整个登录、查询、下单、取消、支付、入住、退房的流程走了一遍，也将订单消息通知测试了一遍，这里将[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/week12/)给大家。

下节课时本次课程的最后一周课了，会带大家把12周的课程做一个总结看看我们从中学到了什么，还有哪些提升空间。下期见，拜拜。

### 65_回眸再看：通过实战互联网酒店预订系统，你收获了哪些能力？

**1、开篇**

不知不觉我们完成12周的课程，将整个互联网酒店预订系统从无到有进行了搭建。不仅从业务逻辑上进行了分析，也从技术架构上进行梳理。RocketMQ作为本节课的主角，在模块解耦、事务一致性、延迟消息等方面都起到了重要的作用。

今天带大家把整个系统的一些技术能力过一遍，看看都有哪些收获。今天会学到以下内容：

- 优化性能
- 解耦系统
- 延迟消息
- 顺序消息
- 消息幂等性处理
- 事务消息 

#### 2、优化性能

在用户第一次微信登录小程序之后，系统自动给用户发放优惠券。一般的做法都是在微信小程序登录时进行授权，之后判断是否第一次登录，后台再根据判断结果发放优惠券。在课程中将微信登录之后，将其登录消息发送到RocketMQ中之后接着进行后面的业务流程。

由对应的Consumer去处理登录消息，根据业务作出后续的操作，例如：发放优惠券。这种做法提升了登录接口的性能，让其在大流量的场景下处理更多的请求，RocketMQ充当的系统的缓冲区，从而提升系统整体性能。

#### 3、解耦系统

传统的系统架构都是将所有业务逻辑放在一起，通过单应用的方式支撑所有业务。随着业务的复杂度提升，以及大流量高并发的场景频发，导致系统的开发部署都成分布式的趋势。

因此会将系统根据业务进行拆解，按照模块划分应用由于模块运行在不同的进程甚至是服务器，那么模块之间的沟通和信息同步就显得尤为重要，RocketMQ恰恰可以成为这些模块之间的桥梁。

例如用户登录模块处理完登录以后，会往MQ发一条信息，优惠券模块会监听这个信息，进行发放优惠券的操作，而消息通知模块利用这条消息可以发起微信消息通知，告知用户登录的情况。

大家可以发挥想象，利用MQ解耦以后可以让支付模块、物流模块、积分模块各司其职又保持信息沟通的通常。

#### 4、延迟消息

记得在取消订单那个章节提到了在下单超过一定时间（30分钟），用户如果还没有支付，系统会自动取消订单。

传统的做法需要通过Job扫表的方式才能完成以上功能。

有了RocketMQ的延迟消息以后，用户下单预定时就会往MQ中发送一条30分钟的延迟消息，Consumer在30分钟以后接受到消息，判断订单状态是否为待支付，是则取消订单。大大节省了系统轮询的开销，提高系统运行效率。

#### 5、顺序消息

预定客户下单之后，订单数据会推送到MQ供其他系统消费，从而达到进行解耦的目的。而订单状态比如下单成功、支付成功、取消预订、成功入住、成功退房等，会随着用户下单、支付、入住、退房等业务功能被更新，也就是通过订单状态的更新让订单流转起来。

根据订单号发送到RocketMQ订单topic的同一个MessageQueue中，保证订单消息的顺序性，这样消费服务受到的订单消息同样也是有序，保证推送用户订单状态不会错乱，同时可以和系统解耦场景配合起来使用。

#### 6、消息幂等性处理

在系统中经常遇到幂等性的问题，例如：重复登录是否发放多次优惠券、订单支付是否存在重复支付的情况。

在系统设计中我们使用Redis的方式，将这部分信息保存到缓存中，在执行操作的时候从缓存中获取这部分信息，并将其与当前请求信息对比，保证操作的幂等性。保存的信息中把唯一确定记录的信息作为Key，例如：手机号、订单号，将保存的内容作为Value，例如：登录信息、订单信息。

#### 7、事务消息

当RocketMQ连接两个关联性较高的操作时，需要使用事务消息保证事务执行的一致性。记得在退房功能描述的时候，用户完成订单和发放优惠券需要一同完成。

但是由于网络或者MQ可用性等问题，有可能造成一个操作完成，发送消息此时MQ挂掉，导致另外一个操作接受不到消息，从而不能执行后续步骤，最终导致订单完成了但是优惠券没有收到的尴尬局面。

在加入RocketMQ的事物消息以后，完成订单状态更新以后会发送half消息确定MQ运行正常，然后再执行本地事务，在事务提交之后再执行发送消息的操作。这样不仅保证了MQ的可用性，也保证了整个事务的一致性。

#### 8、总结

本节课对整个课程的技术要点进行了总结，包括：性能优化、解耦系统、延迟消息、顺序消息、延迟消息、消息幂等性处理以及事务消息等。这里将课程的完整[**代码**](https://gitee.com/project-practice-cloud/little-project-rocketmq/tree/master/)给大家，下期见，拜拜。

