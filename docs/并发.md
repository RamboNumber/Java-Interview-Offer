# 并发

## 1.CountDownLatch

CountDownLatch类位于java.util.concurrent包下，是一个同步工具类，允许一个或多个线程一直等待其他线程的操作执行完后再执行相关操作。

CountDownLatch基于线程计数器来实现并发访问控制，主要用于主线程等待其他子线程都执行完毕后执行相关操作。其使用过程为：在主线程中定义CountDownLatch，并将线程计数器的初始值设置为子线程的个数，多个子线程并发执行，每个子线程在执行完毕后都会调用countDown函数将计数器的值减1，直到线程计数器为0，表示所有的子线程任务都已执行完毕，此时在CountDownLatch上等待的主线程将被唤醒并继续执行。

我们利用CountDownLatch可以实现类似计数器的功能。比如有一个主任务，它要等待其他两个任务都执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能。

```
//定义大小为1的CountDownLatch
final CountDownLatch latch=new CountDownLatch(1);
new Thread(){
	public void run(){
		try{
			latch.countDown();//在子线程1执行完毕后调用countDown方法
		}catch(Exception e){
		}
	}
}.start();
try{
	latch.await();//在CountDownLatch上等待子程序执行完毕
	//子程序执行完毕，开始执行主程序
}
```

以上代码片段先定义了一个大小为1的CountDownLatch，然后定义了一个子线程并启动该子线程，子线程执行完业务代码后在执行latch.countDown()时减少一个信号量，表示自己已经执行完成。主线程调用latch.await()阻塞等待，在所有线程都执行完成并调用了countDown函数时，表示所有线程均执行完成，这时程序会主动唤醒主线程并开始执行主线程的业务逻辑。

## 2.CyclicBarrier

CyclicBarrier（循环屏障）是一个同步工具，可以实现让一组线程等待至某个状态之后再全部同时执行。在所有等待线程都被释放之后，CyclicBarrier可以被重用。CyclicBarrier的运行状态叫作Barrier状态，在调用await方法后，线程就处于Barrier状态。

CyclicBarrier中最重要的方法是await方法，它有两种实现。

- public intawait()：挂起当前线程直到所有线程都为Barrier状态再同时执行后续的任务。
- public int await(long timeout, TimeUnit unit)：设置一个超时时间，在超时时间过后，如果还有线程未达到Barrier状态，则不再等待，让达到Barrier状态的线程继续执行后续的任务。

定义一个CyclicBarrier，然后循环启动了多个线程，每个线程都通过构造函数将CyclicBarrier传入线程中，在线程内部开始执行第1阶段的工作，比如查询数据等；等第1阶段的工作处理完成后，再调用cyclicBarrier.await方法等待其他线程也完成第1阶段的工作（CyclicBarrier让一组线程等待到达某个状态再一起执行）；等其他线程也执行完第1阶段的工作，便可执行并发操作的下一项任务，比如数据分发等。

## 3.Semaphore

Semaphore指信号量，用于控制同时访问某些资源的线程个数，具体做法为通过调用acquire()获取一个许可，如果没有许可，则等待，在许可使用完毕后通过release()释放该许可，以便其他线程使用。

Semaphore常被用于多个线程需要共享有限资源的情况，比如办公室有两台打印机，但是有5个员工需要使用，一台打印机同时只能被一个员工使用，其他员工排队等候，且只有该打印机被使用完毕并释放后其他员工方可使用，这时就可以通过Semaphore来实现。

定义了一个数量为 2的Semaphore，然后定义了一个工作线程Worker并通过构造函数将Semaphore传入线程内部。在线程调用semaphore.acquire()时开始申请许可并执行业务逻辑，在线程业务逻辑执行完成后调用semaphore.release()释放许可以便其他线程使用。

在Semaphore类中有以下几个比较重要的方法。

- public void acquire()：以阻塞的方式获取一个许可，在有可用许可时返回该许可，在没有可用许可时阻塞等待，直到获得许可。
- public void acquire(int permits)：同时获取permits个许可。
- public void release()：释放某个许可。
- public void release(int permits)：释放permits个许可。
- public boolean tryAcquire()：以非阻塞方式获取一个许可，在有可用许可时获取该许可并返回true，否则返回false，不会等待。
- public boolean tryAcquire(long timeout,TimeUnit unit)：如果在指定的时间内获取到可用许可，则返回true，否则返回false。
- public boolean tryAcquire(int permits)：如果成功获取permits个许可，则返回true，否则立即返回false。
- public boolean tryAcquire(int permits,longtimeout,TimeUnit unit)：如果在指定的时间内成功获取permits个许可，则返回true，否则返回false。
- availablePermits()：查询可用的许可数量。

## 4.CountDownLatch、CyclicBarrier、Semaphore的区别

- CountDownLatch和CyclicBarrier都用于实现多线程之间的相互等待，但二者的关注点不同。CountDownLatch主要用于主线程等待其他子线程任务均执行完毕后再执行接下来的业务逻辑单元，而CyclicBarrier主要用于一组线程互相等待大家都达到某个状态后，再同时执行接下来的业务逻辑单元。此外，CountDownLatch是不可以重用的，而CyclicBarrier是可以重用的。
- Semaphore和Java中的锁功能类似，主要用于控制资源的并发访问。

## 5.volatile关键字的作用

Java除了使用了synchronized保证变量的同步，还使用了稍弱的同步机制，即volatile变量。volatile也用于确保将变量的更新操作通知到其他线程。

volatile变量具备两种特性：一种是保证该变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的；一种是volatile禁止指令重排，即volatile变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

因为在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。volatile主要适用于一个变量被多个线程共享，多个线程均可针对这个变量执行赋值或者读取的操作。

在有多个线程对普通变量进行读写时，每个线程都首先需要将数据从内存中复制变量到CPU缓存中，如果计算机有多个CPU，则线程可能都在不同的CPU中被处理，这意味着每个线程都需要将同一个数据复制到不同的CPU Cache中，这样在每个线程都针对同一个变量的数据做了不同的处理后就可能存在数据不一致的情况。

如果将变量声明为volatile，JVM就能保证每次读取变量时都直接从内存中读取，跳过CPU Cache这一步，有效解决了多线程数据同步的问题。

需要说明的是，volatile关键字可以严格保障变量的单次读、写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。volatile在某些场景下可以代替synchronized，但是volatile不能完全取代synchronized的位置，只有在一些特殊场景下才适合使用volatile。比如，必须同时满足下面两个条件才能保证并发环境的线程安全。

- 对变量的写操作不依赖于当前值（比如i++），或者说是单纯的变量赋值（boolean flag=true）。
- 该变量没有被包含在具有其他变量的不变式中，也就是说在不同的volatile变量之间不能互相依赖，只有在状态真正独立于程序内的其他内容时才能使用volatile。

volatile关键字的使用方法比较简单，直接在定义变量时加上volatile关键字即可：

```
volatile boolean flag=true;
```

在应用时需要注意的是，如果两个线程AddRunnable和DecRunnable需要保证数据操作的原子性和一致性，就必须在传参时使用同一个data对象入参。这样无论启动多少个线程执行对data数据的操作，都能保证数据的一致性。

## 6.ConcurrentHashMap并发

ConcurrentHashMap和HashMap的实现方式类似，不同的是它采用分段锁的思想支持并发操作，所以是线程安全的。下面介绍ConcurrentHashMap是如何采用分段锁的思想来实现多线程并发下的数据安全的。

### 减小锁粒度

减小锁粒度指通过缩小锁定对象的范围来减少锁冲突的可能性，最终提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效方法，ConcurrentHashMap并发下的安全机制就是基于该方法实现的。

ConcurrentHashMap是线程安全的Map，对于HashMap而言，最重要的方法是get和set方法，如果为了线程安全对整个HashMap加锁，则可以得到线程安全的对象，但是加锁粒度太大，意味着同时只能有一个线程操作HashMap，在效率上就会大打折扣；而ConcurrentHashMap在内部使用多个Segment，在操作数据时会给每个Segment都加锁，这样就通过减小锁粒度提高了并发度。

### ConcurrentHashMap的实现

ConcurrentHashMap在内部细分为若干个小的HashMap，叫作数据段（Segment）。在默认情况下，一个ConcurrentHashMap被细分为 16个数据段，对每个数据段的数据都单独进行加锁操作。Segment的个数为锁的并发度。

ConcurrentHashMap是由Segment数组和HashEntry数组组成的。Segment继承了可重入锁（ReentrantLock），它在ConcurrentHashMap里扮演锁的角色。HashEntry则用于存储键值对数据。

在每一个ConcurrentHashMap里都包含一个Segment数组，Segment的结构和HashMap类似，是数组和链表结构。在每个Segment里都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据，每个Segment都守护一个HashEntry数组里的元素，在对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。

在操作ConcurrentHashMap时，如果需要在其中添加一个新的数据，则并不是将整个HashMap加锁，而是先根据HashCode查询该数据应该被存放在哪个段，然后对该段加锁并完成put操作。在多线程环境下，如果多个线程同时进行put操作，则只要加入的数据被存放在不同的段中，在线程间就可以做到并行的线程安全。

## 7.什么是CAS

### CAS的概念：比较并交换

CAS（Compare And Swap）指比较并交换。CAS算法CAS(V,E,N)包含3个参数，V表示要更新的变量，E表示预期的值，N表示新值。在且仅在 V值等于 E值时，才会将V值设为 N，如果 V值和 E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后，CAS返回当前V的真实值。

### CAS的特性：乐观锁

CAS操作采用了乐观锁的思想，总是认为自己可以成功完成操作。在有多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然，也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。

## 8.CAS自旋等待

在JDK的原子包java.util.concurrent.atomic里面提供了一组原子类，这些原子类的基本特性就是在多线程环境下，在有多个线程同时执行这些类的实例包含的方法时，会有排他性。其内部便是基于CAS算法实现的，即在某个线程进入方法中执行其中的指令时，不会被其他线程打断；而别的线程就像自旋锁一样，一直等到该方法执行完成才由JVM从等待的队列中选择另一个线程进入。

相对于synchronized阻塞算法，CAS是非阻塞算法的一种常见实现。由于CPU的切换比CPU指令集的操作更加耗时，所以CAS的自旋操作在性能上有了很大的提升。

## 9.ABA问题

对CAS算法的实现有一个重要的前提：需要取出内存中某时刻的数据，然后在下一时刻进行比较、替换，在这个时间差内可能数据已经发生了变化，导致产生ABA问题。

ABA问题指第1个线程从内存的V位置取出A，这时第2个线程也从内存中取出A，并将V位置的数据首先修改为B，接着又将V位置的数据修改为A，这时第1个线程在进行CAS操作时会发现在内存中仍然是A，然后第1个线程操作成功。尽管从第1个线程的角度来说，CAS操作是成功的，但在该过程中其实V位置的数据发生了变化，只是第1个线程没有感知到罢了，这在某些应用场景下可能出现过程数据不一致的问题。

部分乐观锁是通过版本号（version）来解决ABA问题的，具体的操作是乐观锁每次在执行数据的修改操作时都会带上一个版本号，在预期的版本号和数据的版本号一致时就可以执行修改操作，并对版本号执行加1操作，否则执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加，不会减少。、

## 10.什么是AQS

AQS（Abstract Queued Synchronizer）是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State）和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。

## 11.AQS的原理

AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度，具体的流程如图 3-14所示。许多同步类的实现都依赖于AQS，例如常用的ReentrantLock、Semaphore和CountDownLatch。

## 12.state：状态

Abstract Queued Synchronizer维护了一个volatile int类型的变量，用于表示当前的同步状态。Volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。

state的访问方式有三种：getState()、setState()和compareAndSetState()，均是原子操作，其中，compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()。

## 13.AQS共享资源的方式：独占式和共享式

AQS定义了两种资源共享方式：独占式（Exclusive）和共享式（Share）。

- 独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。
- 共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。

AQS只是一个框架，只定义了一个接口，具体资源的获取、释放都交由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等，AQS已经在顶层实现好，不需要具体的同步器再做处理。

- isHeldExclusively()：查询该线程是否正在独占资源，只有用到condition才需要去实现它
- try Acquire(int)：独占方式，尝试获取资源，成功则返回true，失败则返回false
- tryRelease(int)：独占方式，尝试是否资源，成功则返回true，失败则返回false
- tryAcquireShared(int)：共享方式，尝试获取资源，负数表示失败，0表示成功，但没有剩余可用资源，正数表示成功，且有剩余资源
- tryReleaseShared(int)：共享方式，尝试释放资源，如果释放资源后允许唤醒后续等待线程，则返回true，否则返回false

同步器的实现是AQS的核心内存。ReentrantLock对AQS的独占方式实现为：ReentrantLock中的state初始值为0时表示无锁状态。在线程执行tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire()获取锁时均会失败，直到该线程释放锁后state再次为 0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1，因此ReentrantLock也属于可重入锁。但获取多少次锁就要释放多少次锁，这样才能保证state最终为 0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。

CountDownLatch对AQS的共享方式实现为：CountDownLatch将任务分为N个子线程去执行，将state也初始化为N，N与线程的个数一致，N个子线程是并行执行的，每个子线程都在执行完成后countDown()一次，state会执行CAS操作并减1。在所有子线程都执行完成（state=0）时会unpark()主线程，然后主线程会从await()返回，继续执行后续的动作。

一般来说，自定义同步器要么采用独占方式，要么采用共享方式，实现类只需实现tryAcquire、tryRelease或tryAcquireShared、tryReleaseShared中的一组即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，例如ReentrantReadWriteLock在读取时采用了共享方式，在写入时采用了独占方式。